<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>SciML Workshop Exercises Â· The SciML Tutorials</title><script data-outdated-warner src="../../assets/warner.js"></script><link rel="canonical" href="https://docs.sciml.ai/SciMLTutorialsOutput/stable/exercises/01-workshop_exercises/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="The SciML Tutorials logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">The SciML Tutorials</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">SciMLTutorials.jl: Tutorials for Scientific Machine Learning (SciML) and Equation Solvers</a></li><li><span class="tocitem">Ordinary Differential Equation (ODE) Examples</span><ul><li><a class="tocitem" href="../../odes/01-ode_minmax/">Finding Maxima and Minima of Ordinary Differential Equation Solutions</a></li></ul></li><li><span class="tocitem">Special Analyses of ODEs</span><ul><li><a class="tocitem" href="../../type_handling/02-uncertainties/">Numbers with Uncertainties</a></li><li><a class="tocitem" href="../../type_handling/03-unitful/">Unit Checked Arithmetic via Unitful.jl</a></li></ul></li><li><span class="tocitem">Mixing Julia Types with Differential Equations</span><ul><li><a class="tocitem" href="../../models/01-classical_physics/">Classical Physics Models</a></li><li><a class="tocitem" href="../../models/02-conditional_dosing/">Conditional Dosing Pharmacometric Example</a></li><li><a class="tocitem" href="../../models/03-kepler_problem/">Kepler Problem</a></li><li><a class="tocitem" href="../../models/04-spiking_neural_systems/">Spiking Neural Systems</a></li><li><a class="tocitem" href="../../models/05-outer_solar_system/">The Outer Solar System</a></li></ul></li><li><span class="tocitem">Inference and Parameter Estimation on ODEs</span><ul><li><a class="tocitem" href="../../model_inference/01-pendulum_bayesian_inference/">Bayesian Inference on a Pendulum using DiffEqBayes.jl</a></li><li><a class="tocitem" href="../../model_inference/02-monte_carlo_parameter_estim/">Monte Carlo Parameter Estimation From Data</a></li></ul></li><li><span class="tocitem">Analyzing Jump Process Equations</span><ul><li class="is-active"><a class="tocitem" href>SciML Workshop Exercises</a><ul class="internal"><li class="toplevel"><a class="tocitem" href="#Problem-1:-Investigating-Sources-of-Randomness-and-Uncertainty-in-a-Stiff-Biological-System-(B)"><span>Problem 1: Investigating Sources of Randomness and Uncertainty in a Stiff Biological System (B)</span></a></li><li><a class="tocitem" href="#Part-1:-Simulating-the-Oregonator-ODE-model"><span>Part 1: Simulating the Oregonator ODE model</span></a></li><li><a class="tocitem" href="#Part-2:-Investigating-Stiffness"><span>Part 2: Investigating Stiffness</span></a></li><li><a class="tocitem" href="#(Optional)-Part-3:-Specifying-Analytical-Jacobians-(I)"><span>(Optional) Part 3: Specifying Analytical Jacobians (I)</span></a></li><li><a class="tocitem" href="#(Optional)-Part-4:-Automatic-Symbolicification-and-Analytical-Jacobian-Calculations"><span>(Optional) Part 4: Automatic Symbolicification and Analytical Jacobian Calculations</span></a></li><li><a class="tocitem" href="#Part-5:-Adding-stochasticity-with-stochastic-differential-equations"><span>Part 5: Adding stochasticity with stochastic differential equations</span></a></li><li><a class="tocitem" href="#Part-6:-Gillespie-jump-models-of-discrete-stochasticity"><span>Part 6: Gillespie jump models of discrete stochasticity</span></a></li><li><a class="tocitem" href="#Part-7:-Probabilistic-Programming-/-Bayesian-Parameter-Estimation-with-DiffEqBayes.jl-Turing.jl-(I)"><span>Part 7: Probabilistic Programming / Bayesian Parameter Estimation with DiffEqBayes.jl + Turing.jl (I)</span></a></li><li><a class="tocitem" href="#(Optional)-Part-8:-Using-DiffEqBiological&#39;s-Reaction-Network-DSL"><span>(Optional) Part 8: Using DiffEqBiological&#39;s Reaction Network DSL</span></a></li><li class="toplevel"><a class="tocitem" href="#Problem-2:-Fitting-Hybrid-Delay-Pharmacokinetic-Models-with-Automated-Responses-(B)"><span>Problem 2: Fitting Hybrid Delay Pharmacokinetic Models with Automated Responses (B)</span></a></li><li><a class="tocitem" href="#Part-1:-Defining-an-ODE-with-Predetermined-Doses"><span>Part 1: Defining an ODE with Predetermined Doses</span></a></li><li><a class="tocitem" href="#Part-2:-Adding-Delays"><span>Part 2: Adding Delays</span></a></li><li><a class="tocitem" href="#Part-3:-Automatic-Differentiation-(AD)-for-Optimization-(I)"><span>Part 3: Automatic Differentiation (AD) for Optimization (I)</span></a></li><li><a class="tocitem" href="#Part-4:-Fitting-Known-Quantities-with-DiffEqParamEstim.jl-Optim.jl"><span>Part 4: Fitting Known Quantities with DiffEqParamEstim.jl + Optim.jl</span></a></li><li><a class="tocitem" href="#Part-5:-Implementing-Control-Based-Logic-with-ContinuousCallbacks-(I)"><span>Part 5: Implementing Control-Based Logic with ContinuousCallbacks (I)</span></a></li><li><a class="tocitem" href="#Part-6:-Global-Sensitivity-Analysis-with-the-Morris-and-Sobol-Methods"><span>Part 6: Global Sensitivity Analysis with the Morris and Sobol Methods</span></a></li><li class="toplevel"><a class="tocitem" href="#Problem-3:-Differential-Algebraic-Equation-Modeling-of-a-Double-Pendulum-(B)"><span>Problem 3: Differential-Algebraic Equation Modeling of a Double Pendulum (B)</span></a></li><li><a class="tocitem" href="#Part-1:-Simple-Introduction-to-DAEs:-Mass-Matrix-Robertson-Equations"><span>Part 1: Simple Introduction to DAEs: Mass-Matrix Robertson Equations</span></a></li><li><a class="tocitem" href="#Part-2:-Solving-the-Implicit-Robertson-Equations-with-IDA"><span>Part 2: Solving the Implicit Robertson Equations with IDA</span></a></li><li><a class="tocitem" href="#Part-3:-Manual-Index-Reduction-of-the-Single-Pendulum"><span>Part 3: Manual Index Reduction of the Single Pendulum</span></a></li><li><a class="tocitem" href="#Part-2:-Optimizing-the-BRUSS-Code"><span>Part 2: Optimizing the BRUSS Code</span></a></li><li><a class="tocitem" href="#Part-3:-Exploiting-Jacobian-Sparsity-with-Color-Differentiation"><span>Part 3: Exploiting Jacobian Sparsity with Color Differentiation</span></a></li><li><a class="tocitem" href="#(Optional)-Part-4:-Structured-Jacobians"><span>(Optional) Part 4: Structured Jacobians</span></a></li><li><a class="tocitem" href="#(Optional)-Part-5:-Automatic-Symbolicification-and-Analytical-Jacobian"><span>(Optional) Part 5: Automatic Symbolicification and Analytical Jacobian</span></a></li><li><a class="tocitem" href="#Part-6:-Utilizing-Preconditioned-GMRES-Linear-Solvers"><span>Part 6: Utilizing Preconditioned-GMRES Linear Solvers</span></a></li><li><a class="tocitem" href="#Part-7:-Exploring-IMEX-and-Exponential-Integrator-Techniques-(E)"><span>Part 7: Exploring IMEX and Exponential Integrator Techniques (E)</span></a></li><li><a class="tocitem" href="#Part-8:-Work-Precision-Diagrams-for-Benchmarking-Solver-Choices"><span>Part 8: Work-Precision Diagrams for Benchmarking Solver Choices</span></a></li><li><a class="tocitem" href="#Part-9:-GPU-Parallelism-for-PDEs-(E)"><span>Part 9: GPU-Parallelism for PDEs (E)</span></a></li><li><a class="tocitem" href="#Part-10:-Adjoint-Sensitivity-Analysis-for-Gradients-of-PDEs"><span>Part 10: Adjoint Sensitivity Analysis for Gradients of PDEs</span></a></li><li class="toplevel"><a class="tocitem" href="#Problem-5:-Global-Parameter-Sensitivity-and-Optimality-with-GPU-and-Distributed-Ensembles-(B)"><span>Problem 5: Global Parameter Sensitivity and Optimality with GPU and Distributed Ensembles (B)</span></a></li><li><a class="tocitem" href="#Part-1:-Implementing-the-Henon-Heiles-System-(B)"><span>Part 1: Implementing the Henon-Heiles System (B)</span></a></li><li><a class="tocitem" href="#(Optional)-Part-2:-Alternative-Dynamical-Implmentations-of-Henon-Heiles-(B)"><span>(Optional) Part 2: Alternative Dynamical Implmentations of Henon-Heiles (B)</span></a></li><li><a class="tocitem" href="#Part-3:-Parallelized-Ensemble-Solving"><span>Part 3: Parallelized Ensemble Solving</span></a></li><li><a class="tocitem" href="#Part-4:-Parallelized-GPU-Ensemble-Solving"><span>Part 4: Parallelized GPU Ensemble Solving</span></a></li><li class="toplevel"><a class="tocitem" href="#Problem-6:-Training-Neural-Stochastic-Differential-Equations-with-GPU-acceleration-(I)"><span>Problem 6: Training Neural Stochastic Differential Equations with GPU acceleration (I)</span></a></li><li><a class="tocitem" href="#Part-1:-Constructing-and-Training-a-Basic-Neural-ODE"><span>Part 1: Constructing and Training a Basic Neural ODE</span></a></li><li><a class="tocitem" href="#Part-2:-GPU-accelerating-the-Neural-ODE-Process"><span>Part 2: GPU-accelerating the Neural ODE Process</span></a></li><li><a class="tocitem" href="#Part-3:-Defining-and-Training-a-Mixed-Neural-ODE"><span>Part 3: Defining and Training a Mixed Neural ODE</span></a></li><li><a class="tocitem" href="#Part-4:-Constructing-a-Basic-Neural-SDE"><span>Part 4: Constructing a Basic Neural SDE</span></a></li><li><a class="tocitem" href="#Part-5:-Optimizing-the-training-behavior-with-minibatching-(E)"><span>Part 5: Optimizing the training behavior with minibatching (E)</span></a></li></ul></li><li><a class="tocitem" href="../02-workshop_solutions/">SciML Workshop Exercise Solutions</a></li></ul></li><li><span class="tocitem">Advanced ODE Examples</span><ul><li><a class="tocitem" href="../../advanced/01-beeler_reuter/">An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model</a></li><li><a class="tocitem" href="../../advanced/02-diffusion_implicit_heat_equation/">Solving the heat equation with diffusion-implicit time-stepping</a></li></ul></li><li><span class="tocitem">Symbolic-Numeric Approaches</span><ul><li><a class="tocitem" href="../../perturbation/01-perturbation_algebraic/">Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations</a></li><li><a class="tocitem" href="../../perturbation/02-perturbation_differential/">Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations</a></li></ul></li><li><span class="tocitem">Workshop Exercises</span><ul><li><a class="tocitem" href="../../jumps/spatial/">Tutorial on using spatial SSAs in DiffEqJump</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Analyzing Jump Process Equations</a></li><li class="is-active"><a href>SciML Workshop Exercises</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>SciML Workshop Exercises</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/SciML/SciMLTutorialsOutput/blob/main/docs/src/exercises/01-workshop_exercises.md" title="Edit on GitHub"><span class="docs-icon fab">ï</span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="SciML-Workshop-Exercises"><a class="docs-heading-anchor" href="#SciML-Workshop-Exercises">SciML Workshop Exercises</a><a id="SciML-Workshop-Exercises-1"></a><a class="docs-heading-anchor-permalink" href="#SciML-Workshop-Exercises" title="Permalink"></a></h1><p>These exercises teach common workflows which involve SciML&#39;s tools like DifferentialEquations.jl, DiffEqFlux.jl, and the connections to parts like stochastic differential equations and Bayesian estimation. The designation (B) is for &quot;Beginner&quot;, meaning that a user new to the package should feel comfortable trying this exercise. An exercise designated (I) is for &quot;Intermediate&quot;, meaning the user may want to have some previous background in DifferentialEquations.jl or try some (B) exercises first. The additional (E) designation is for &quot;Experienced&quot;, which are portions of exercises which may take some work.</p><p>The exercises are described as follows:</p><ul><li>Exercise 1 takes the user through solving a stiff ordinary differential equation and using the ModelingToolkit.jl to automatically convert the function to a symbolic form to derive the analytical Jacobian to speed up the solver. The same biological system is then solved with stochasticity, utilizing EnsembleProblems to understand 95% bounds on the solution. Finally, probabilistic programming is employed to perform Bayesian parameter estimation of the parameters against data.</li><li>Exercise 2 takes the user through defining hybrid delay differential equation, that is a differential equation with events, and using differentiable programming techniques (automatic differentiation) to to perform gradient-based parameter estimation.</li><li>Exercise 3 takes the user through differential-algebraic equation (DAE) modeling, the concept of index, and using both mass-matrix and implicit ODE representations. This will require doing a bit of math, but the student will understand how to change their equations to make their DAE numerically easier for the integrators.</li><li>Exercise 4 takes the user through optimizing a PDE solver, utilizing automatic sparsity pattern recognition, automatic conversion of numerical codes to symbolic codes for analytical construction of the Jacobian, preconditioned GMRES, and setting up a solver for IMEX and GPUs, and compute adjoints of PDEs.</li><li>Exercise 5 focuses on a chaotic orbit, utilizing parallel ensembles across supercomputers and GPUs to quickly describe phase space.</li><li>Exercise 6 takes the user through training a neural stochastic differential equation, using GPU-accleration and adjoints through Flux.jl&#39;s neural network framework to build efficient training codes.</li></ul><p>This exercise worksheet is meant to be a living document leading new users through a deep dive of the DifferentialEquations.jl feature set. If you further suggestions or want to contribute new problems, please open an issue or PR at the SciMLTutorials.jl repository.</p><h1 id="Problem-1:-Investigating-Sources-of-Randomness-and-Uncertainty-in-a-Stiff-Biological-System-(B)"><a class="docs-heading-anchor" href="#Problem-1:-Investigating-Sources-of-Randomness-and-Uncertainty-in-a-Stiff-Biological-System-(B)">Problem 1: Investigating Sources of Randomness and Uncertainty in a Stiff Biological System (B)</a><a id="Problem-1:-Investigating-Sources-of-Randomness-and-Uncertainty-in-a-Stiff-Biological-System-(B)-1"></a><a class="docs-heading-anchor-permalink" href="#Problem-1:-Investigating-Sources-of-Randomness-and-Uncertainty-in-a-Stiff-Biological-System-(B)" title="Permalink"></a></h1><p>In this problem we will walk through the basics of simulating models with DifferentialEquations.jl. Let&#39;s take the <a href="https://www.radford.edu/~thompson/vodef90web/problems/demosnodislin/Demos_Pitagora/DemoOrego/demoorego.pdf">Oregonator model of the Belousov-Zhabotinskii chemical reaction system</a>. This system describes a classical example in non-equilibrium thermodynmics and is a well-known natural chemical oscillator.</p><h2 id="Part-1:-Simulating-the-Oregonator-ODE-model"><a class="docs-heading-anchor" href="#Part-1:-Simulating-the-Oregonator-ODE-model">Part 1: Simulating the Oregonator ODE model</a><a id="Part-1:-Simulating-the-Oregonator-ODE-model-1"></a><a class="docs-heading-anchor-permalink" href="#Part-1:-Simulating-the-Oregonator-ODE-model" title="Permalink"></a></h2><p>When modeling, usually one starts off by investigating the deterministic model. The deterministic ODE formulation of the Oregonator is given by the equations</p><p class="math-container">\[\begin{align}
\frac{dx}{dt} &amp;= s(y-xy + x - qx^2)\\
\frac{dy}{dt} &amp;= (-y - xy + z)/s\\
\frac{dz}{dt} &amp;= w(x - z)\end{align}\]</p><p>with parameter values <span>$s=77.27$</span>, <span>$w=0.161$</span>, and <span>$q=8.375 \times 10^{-6}$</span>, and initial conditions <span>$x(0)=1$</span>, <span>$y(0)=2$</span>, and <span>$z(0)=3$</span>. Use <a href="https://docs.juliadiffeq.org/dev/tutorials/ode_example">the tutorial on solving ODEs</a> to solve this differential equation on the timespan of <span>$t\in[0,360]$</span> with the default ODE solver. To investigate the result, plot the solution of all components over time, and plot the phase space plot of the solution (hint: use <code>vars=(1,2,3)</code>). What shape is being drawn in phase space?</p><h2 id="Part-2:-Investigating-Stiffness"><a class="docs-heading-anchor" href="#Part-2:-Investigating-Stiffness">Part 2: Investigating Stiffness</a><a id="Part-2:-Investigating-Stiffness-1"></a><a class="docs-heading-anchor-permalink" href="#Part-2:-Investigating-Stiffness" title="Permalink"></a></h2><p>Because the reaction rates of <code>q</code> vs <code>s</code> is very large, this model has a &quot;fast&quot; system and a &quot;slow&quot; system. This is typical of ODEs which exhibit a property known as stiffness. Stiffness changes the ODE solvers which can handle the equation well. <a href="https://docs.juliadiffeq.org/dev/solvers/ode_solve">Take a look at the ODE solver page</a> and investigate solving the equation using methods for non-stiff equations (ex: <code>Tsit5</code>) and stiff equations (ex: <code>Rodas5</code>).</p><p>Benchmark using <span>$t\in[0,50]$</span> using <code>@btime</code> from BenchmarkTools.jl. What happens when you increase the timespan?</p><h2 id="(Optional)-Part-3:-Specifying-Analytical-Jacobians-(I)"><a class="docs-heading-anchor" href="#(Optional)-Part-3:-Specifying-Analytical-Jacobians-(I)">(Optional) Part 3: Specifying Analytical Jacobians (I)</a><a id="(Optional)-Part-3:-Specifying-Analytical-Jacobians-(I)-1"></a><a class="docs-heading-anchor-permalink" href="#(Optional)-Part-3:-Specifying-Analytical-Jacobians-(I)" title="Permalink"></a></h2><p>Stiff ODE solvers internally utilize the Jacobian of the ODE system in order to improve the stepsizes in the solution. However, computing and factorizing the Jacobian is costly, and thus it can be beneficial to provide the analytical solution.</p><p>Use the <a href="https://docs.juliadiffeq.org/dev/features/performance_overloads">ODEFunction definition page</a> to define an <code>ODEFunction</code> which holds both the OREGO ODE and its Jacobian, and solve using <code>Rodas5</code>.</p><h2 id="(Optional)-Part-4:-Automatic-Symbolicification-and-Analytical-Jacobian-Calculations"><a class="docs-heading-anchor" href="#(Optional)-Part-4:-Automatic-Symbolicification-and-Analytical-Jacobian-Calculations">(Optional) Part 4: Automatic Symbolicification and Analytical Jacobian Calculations</a><a id="(Optional)-Part-4:-Automatic-Symbolicification-and-Analytical-Jacobian-Calculations-1"></a><a class="docs-heading-anchor-permalink" href="#(Optional)-Part-4:-Automatic-Symbolicification-and-Analytical-Jacobian-Calculations" title="Permalink"></a></h2><p>Deriving Jacobians by hand is tedious. Thankfully symbolic mathematical systems can do the work for you. And thankfully, DifferentialEquations.jl has tools to automatically convert numerical problems into symbolic problems to perform the analysis on!</p><p>follow the <a href="https://github.com/JuliaDiffEq/ModelingToolkit.jl">ModelingToolkit.jl README</a> to automatically convert your ODE definition to its symbolic form using <code>modelingtoolkitize</code> and calculate the analytical Jacobian. Use the compilation functions to build the <code>ODEFunction</code> with the embedded analytical solution.</p><h2 id="Part-5:-Adding-stochasticity-with-stochastic-differential-equations"><a class="docs-heading-anchor" href="#Part-5:-Adding-stochasticity-with-stochastic-differential-equations">Part 5: Adding stochasticity with stochastic differential equations</a><a id="Part-5:-Adding-stochasticity-with-stochastic-differential-equations-1"></a><a class="docs-heading-anchor-permalink" href="#Part-5:-Adding-stochasticity-with-stochastic-differential-equations" title="Permalink"></a></h2><p>How does this system react in the presense of stochasticity? We can investigate this question by using stochastic differential equations. A stochastic differential equation formulation of this model is known as the multiplicative noise model, is created with:</p><p class="math-container">\[\begin{align}
dx &amp;= s(y-xy + x - qx^2)dt + \sigma_1 x dW_1\\
dy &amp;= \frac{-y - xy + z}{s}dt + \sigma_2 y dW_2\\
dz &amp;= w(x - z)dt + \sigma_3 z dW_3\end{align}\]</p><p>with <span>$\sigma_i = 0.1$</span> where the <code>dW</code> terms describe a Brownian motion, a continuous random process with normally distributed increments. Use the <a href="https://docs.juliadiffeq.org/dev/tutorials/sde_example">tutorial on solving SDEs</a> to solve simulate this model. Then, <a href="https://docs.juliadiffeq.org/dev/features/ensemble">use the <code>EnsembleProblem</code></a> to generate and plot 100 trajectories of the stochastic model, and use <code>EnsembleSummary</code> to plot the mean and 5%-95% region over time.</p><p>Try solving with the <code>ImplicitRKMil</code> and <code>SOSRI</code> methods. Notice that it isn&#39;t stiff every single time!</p><p>(For fun, see if you can make the Euler-Maruyama <code>EM()</code> method solve this equation. This requires a choice of <code>dt</code> small enough to be stable. This is the &quot;standard&quot; method!)</p><h2 id="Part-6:-Gillespie-jump-models-of-discrete-stochasticity"><a class="docs-heading-anchor" href="#Part-6:-Gillespie-jump-models-of-discrete-stochasticity">Part 6: Gillespie jump models of discrete stochasticity</a><a id="Part-6:-Gillespie-jump-models-of-discrete-stochasticity-1"></a><a class="docs-heading-anchor-permalink" href="#Part-6:-Gillespie-jump-models-of-discrete-stochasticity" title="Permalink"></a></h2><p>When biological models have very few particles, continuous models no longer make sense, and instead using the full discrete formulation can be required to accuracy describe the dynamics. A discrete differential equation, or Gillespie model, is a continuous-time Markov chain with Poisson-distributed jumps. A discrete description of the Oregonator model is given by a chemical reaction systems:</p><pre><code class="language-julia hljs">
A+Y -&gt; X+P
X+Y -&gt; 2P
A+X -&gt; 2X + 2Z
2X  -&gt; A + P (note: this has rate kX^2!)
B + Z -&gt; Y</code></pre><p>where reactions take place at a rate which is propoertional to its components, i.e. the first reaction has a rate <code>k*A*Y</code> for some <code>k</code>. Use the <a href="https://docs.juliadiffeq.org/dev/tutorials/discrete_stochastic_example">tutorial on Gillespie SSA models</a> to implement the <code>JumpProblem</code> for this model, and use the <code>EnsembleProblem</code> and <code>EnsembleSummary</code> to characterize the stochastic trajectories.</p><p>For what rate constants does the model give the oscillatory dynamics for the ODE approximation? For information on the true reaction rates, consult <a href="https://pubs.acs.org/doi/abs/10.1021/ja00780a001">the original paper</a>.</p><h2 id="Part-7:-Probabilistic-Programming-/-Bayesian-Parameter-Estimation-with-DiffEqBayes.jl-Turing.jl-(I)"><a class="docs-heading-anchor" href="#Part-7:-Probabilistic-Programming-/-Bayesian-Parameter-Estimation-with-DiffEqBayes.jl-Turing.jl-(I)">Part 7: Probabilistic Programming / Bayesian Parameter Estimation with DiffEqBayes.jl + Turing.jl (I)</a><a id="Part-7:-Probabilistic-Programming-/-Bayesian-Parameter-Estimation-with-DiffEqBayes.jl-Turing.jl-(I)-1"></a><a class="docs-heading-anchor-permalink" href="#Part-7:-Probabilistic-Programming-/-Bayesian-Parameter-Estimation-with-DiffEqBayes.jl-Turing.jl-(I)" title="Permalink"></a></h2><p>In many casees, one comes to understand the proper values for their model&#39;s parameters by utilizing data fitting techniques. In this case, we will use the DiffEqBayes.jl library to perform a Bayesian estimation of the parameters. For our data we will the following potential output:</p><pre><code class="language-julia hljs">
t = 0.0:1.0:30.0
data = [1.0 2.05224 2.11422 2.1857 2.26827 2.3641 2.47618 2.60869 2.7677 2.96232 3.20711 3.52709 3.97005 4.64319 5.86202 9.29322 536.068 82388.9 57868.4 1.00399 1.00169 1.00117 1.00094 1.00082 1.00075 1.0007 1.00068 1.00066 1.00065 1.00065 1.00065
        2.0 1.9494 1.89645 1.84227 1.78727 1.73178 1.67601 1.62008 1.56402 1.50772 1.45094 1.39322 1.33366 1.2705 1.19958 1.10651 0.57194 0.180316 0.431409 251.774 591.754 857.464 1062.78 1219.05 1335.56 1419.88 1478.22 1515.63 1536.25 1543.45 1539.98
        3.0 2.82065 2.68703 2.58974 2.52405 2.48644 2.47449 2.48686 2.52337 2.58526 2.67563 2.80053 2.9713 3.21051 3.5712 4.23706 12.0266 14868.8 24987.8 23453.4 19202.2 15721.6 12872.0 10538.8 8628.66 7064.73 5784.29 4735.96 3877.66 3174.94 2599.6]</code></pre><p><a href="https://docs.juliadiffeq.org/latest/analysis/parameter_estimation/#Bayesian-Inference-Examples-1">Follow the exmaples on the parameter estimation page</a> to perform a Bayesian parameter estimation. What are the most likely parameters for the model given the posterior parameter distributions?</p><p>Use the <code>ODEProblem</code> to perform the fit. If you have time, use the <code>EnsembleProblem</code> of <code>SDEProblem</code>s to perform a fit over averages of the SDE solutions. Note that the SDE fit will take significantly more computational resources! See the GPU parallelism section for details on how to accelerate this.</p><h2 id="(Optional)-Part-8:-Using-DiffEqBiological&#39;s-Reaction-Network-DSL"><a class="docs-heading-anchor" href="#(Optional)-Part-8:-Using-DiffEqBiological&#39;s-Reaction-Network-DSL">(Optional) Part 8: Using DiffEqBiological&#39;s Reaction Network DSL</a><a id="(Optional)-Part-8:-Using-DiffEqBiological&#39;s-Reaction-Network-DSL-1"></a><a class="docs-heading-anchor-permalink" href="#(Optional)-Part-8:-Using-DiffEqBiological&#39;s-Reaction-Network-DSL" title="Permalink"></a></h2><p>DiffEqBiological.jl is a helper library for the DifferentialEquations.jl ecosystem for defining chemical reaction systems at a high leevel for easy simulation in these various forms. Use the descrption <a href="https://docs.juliadiffeq.org/dev/models/biological">from the Chemical Reaction Networks documentation page</a> to build a reaction network and generate the ODE/SDE/jump equations, and compare the result to your handcoded versions.</p><h1 id="Problem-2:-Fitting-Hybrid-Delay-Pharmacokinetic-Models-with-Automated-Responses-(B)"><a class="docs-heading-anchor" href="#Problem-2:-Fitting-Hybrid-Delay-Pharmacokinetic-Models-with-Automated-Responses-(B)">Problem 2: Fitting Hybrid Delay Pharmacokinetic Models with Automated Responses (B)</a><a id="Problem-2:-Fitting-Hybrid-Delay-Pharmacokinetic-Models-with-Automated-Responses-(B)-1"></a><a class="docs-heading-anchor-permalink" href="#Problem-2:-Fitting-Hybrid-Delay-Pharmacokinetic-Models-with-Automated-Responses-(B)" title="Permalink"></a></h1><p>Hybrid differential equations are differential equations with events, where events are some interaction that occurs according to a prespecified condition. For example, the bouncing ball is a classic hybrid differential equation given by an ODE (Newton&#39;s Law of Gravity) mixed with the fact that, whenever the ball hits the floor (<code>x=0</code>), then the velocity of the ball flips (<code>v=-v</code>).</p><p>In addition, many models incorporate delays, that is the driving force of the equation is dependent not on the current values, but values from the past. These delay differential equations model how individuals in the economy act on old information, or that biological processes take time to adapt to a new environment.</p><p>In this equation we will build a hybrid delayed pharmacokinetic model and use the parameter estimation techniques to fit this it to a data.</p><h2 id="Part-1:-Defining-an-ODE-with-Predetermined-Doses"><a class="docs-heading-anchor" href="#Part-1:-Defining-an-ODE-with-Predetermined-Doses">Part 1: Defining an ODE with Predetermined Doses</a><a id="Part-1:-Defining-an-ODE-with-Predetermined-Doses-1"></a><a class="docs-heading-anchor-permalink" href="#Part-1:-Defining-an-ODE-with-Predetermined-Doses" title="Permalink"></a></h2><p>First, let&#39;s define the simplest hybrid ordinary differential equation: an ODE where the events take place at fixed times. The ODE we will use is known as the one-compartment model:</p><p class="math-container">\[\begin{align}
\frac{d[Depot]}{dt} &amp;= -K_a [Depot] + R\\
\frac{d[Central]}{dt} &amp;= K_a [Depot] - K_e [Central]\end{align}\]</p><p>with <span>$t \in [0,90]$</span>, <span>$u_0 = [100.0,0]$</span>, and <span>$p=[K_a,K_e]=[2.268,0.07398]$</span>.</p><p>With this model, use <a href="https://docs.juliadiffeq.org/dev/features/callback_functions">the event handling documentation page</a> to define a <code>DiscreteCallback</code> which fires at <code>t â [24,48,72]</code> and adds a dose of 100 into <code>[Depot]</code>. (Hint: you&#39;ll want to set <code>tstops=[24,48,72]</code> to force the ODE solver to step at these times).</p><h2 id="Part-2:-Adding-Delays"><a class="docs-heading-anchor" href="#Part-2:-Adding-Delays">Part 2: Adding Delays</a><a id="Part-2:-Adding-Delays-1"></a><a class="docs-heading-anchor-permalink" href="#Part-2:-Adding-Delays" title="Permalink"></a></h2><p>Now let&#39;s assume that instead of there being one compartment, there are many transit compartment that the drug must move through in order to reach the central compartment. This effectively delays the effect of the transition from <code>[Depot]</code> to <code>[Central]</code>. To model this effect, we will use the delay differential equation which utilizes a fixed time delay <span>$\tau$</span>:</p><p class="math-container">\[\begin{align}
\frac{d[Depot]}{dt} &amp;= -K_a [Depot](t)\\
\frac{d[Central]}{dt} &amp;= K_a [Depot](t-\tau) - K_e [Central]\end{align}\]</p><p>where the parameter <span>$Ï = 6.0$</span>. <a href="https://docs.juliadiffeq.org/dev/tutorials/dde_example">Use the DDE tutorial</a> to define and solve this delayed version of the hybrid model.</p><h2 id="Part-3:-Automatic-Differentiation-(AD)-for-Optimization-(I)"><a class="docs-heading-anchor" href="#Part-3:-Automatic-Differentiation-(AD)-for-Optimization-(I)">Part 3: Automatic Differentiation (AD) for Optimization (I)</a><a id="Part-3:-Automatic-Differentiation-(AD)-for-Optimization-(I)-1"></a><a class="docs-heading-anchor-permalink" href="#Part-3:-Automatic-Differentiation-(AD)-for-Optimization-(I)" title="Permalink"></a></h2><p>In order to fit parameters <span>$(K_a,K_e,\tau)$</span> we will want to be able to calculate the gradient of the solution with respect to the initial conditions. One way to do this is via Automatic Differentition (AD). For small numbers of parameters (&lt;100), it is fastest to use Forward-Mode Automatic Differentition (even faster than using adjoint sensitivity analysis!). Thus for this problem we will make use of ForwardDiff.jl to use Dual number arithmetic to retrive both the solution and its derivative w.r.t. parameters in a single solve.</p><p><a href="https://docs.juliadiffeq.org/dev/analysis/sensitivity">Use the information from the page on local sensitvity analysis</a> to define the input dual numbers, solve the equation, and plot both the solution over time and the derivative of the solution w.r.t. the parameters.</p><h2 id="Part-4:-Fitting-Known-Quantities-with-DiffEqParamEstim.jl-Optim.jl"><a class="docs-heading-anchor" href="#Part-4:-Fitting-Known-Quantities-with-DiffEqParamEstim.jl-Optim.jl">Part 4: Fitting Known Quantities with DiffEqParamEstim.jl + Optim.jl</a><a id="Part-4:-Fitting-Known-Quantities-with-DiffEqParamEstim.jl-Optim.jl-1"></a><a class="docs-heading-anchor-permalink" href="#Part-4:-Fitting-Known-Quantities-with-DiffEqParamEstim.jl-Optim.jl" title="Permalink"></a></h2><p>Now let&#39;s fit the delayed model to a dataset. For the data, use the array</p><pre><code class="language-julia hljs">
t = 0.0:12.0:90.0
data = [100.0 0.246196 0.000597933 0.24547 0.000596251 0.245275 0.000595453 0.245511
        0.0 53.7939 16.8784 58.7789 18.3777 59.1879 18.5003 59.2611]</code></pre><p>Use <a href="https://docs.juliadiffeq.org/dev/analysis/parameter_estimation">the parameter estimation page</a> to define a loss function with <code>build_loss_objective</code> and optimize the parameters against the data. What parameters were used to generate the data?</p><h2 id="Part-5:-Implementing-Control-Based-Logic-with-ContinuousCallbacks-(I)"><a class="docs-heading-anchor" href="#Part-5:-Implementing-Control-Based-Logic-with-ContinuousCallbacks-(I)">Part 5: Implementing Control-Based Logic with ContinuousCallbacks (I)</a><a id="Part-5:-Implementing-Control-Based-Logic-with-ContinuousCallbacks-(I)-1"></a><a class="docs-heading-anchor-permalink" href="#Part-5:-Implementing-Control-Based-Logic-with-ContinuousCallbacks-(I)" title="Permalink"></a></h2><p>Now that we have fit our delay differential equation model to the dataset, we want to start testing out automated treatment strategies. Let&#39;s assume that instead of giving doses at fixed time points, we invent a wearable which monitors the patient and administers a dose whenever the internal drug concentration falls below 25. To model this effect, we will need to use <code>ContinuousCallbacks</code> to define a callback that triggers when <code>[Central]</code> falls below the threshold value.</p><p><a href="https://docs.juliadiffeq.org/dev/features/callback_functions">Use the documentation on the event handling page</a> to define such a callback, and plot the solution over time. How many times does the auto-doser administer a dose? How much does this change as you change the delay time <span>$\tau$</span>?</p><h2 id="Part-6:-Global-Sensitivity-Analysis-with-the-Morris-and-Sobol-Methods"><a class="docs-heading-anchor" href="#Part-6:-Global-Sensitivity-Analysis-with-the-Morris-and-Sobol-Methods">Part 6: Global Sensitivity Analysis with the Morris and Sobol Methods</a><a id="Part-6:-Global-Sensitivity-Analysis-with-the-Morris-and-Sobol-Methods-1"></a><a class="docs-heading-anchor-permalink" href="#Part-6:-Global-Sensitivity-Analysis-with-the-Morris-and-Sobol-Methods" title="Permalink"></a></h2><p>To understand how the parameters effect the solution in a global sense, one wants to use Global Sensitivity Analysis. Use the <a href="https://docs.juliadiffeq.org/dev/analysis/global_sensitivity">GSA documentation page</a> perform global sensitivity analysis and quantify the effect of the various parameters on the solution.</p><h1 id="Problem-3:-Differential-Algebraic-Equation-Modeling-of-a-Double-Pendulum-(B)"><a class="docs-heading-anchor" href="#Problem-3:-Differential-Algebraic-Equation-Modeling-of-a-Double-Pendulum-(B)">Problem 3: Differential-Algebraic Equation Modeling of a Double Pendulum (B)</a><a id="Problem-3:-Differential-Algebraic-Equation-Modeling-of-a-Double-Pendulum-(B)-1"></a><a class="docs-heading-anchor-permalink" href="#Problem-3:-Differential-Algebraic-Equation-Modeling-of-a-Double-Pendulum-(B)" title="Permalink"></a></h1><p>Differential-Algebraic Equaton (DAE) systems are like ODEs but allow for adding constraints into the models. This problem will look at solving the double penulum problem with enforcement of the rigid body constraints, requiring that the total distance <code>L</code> is constant throughout the simulation. While these equations can be rewritten in an ODE form, in many cases it can be simpler to solve the equation directly with the constraints. This tutorial will cover both the idea of index, how to manually perform index reduction, and how to make use of mass matrix and implicit ODE solvers to handle these problems.</p><h2 id="Part-1:-Simple-Introduction-to-DAEs:-Mass-Matrix-Robertson-Equations"><a class="docs-heading-anchor" href="#Part-1:-Simple-Introduction-to-DAEs:-Mass-Matrix-Robertson-Equations">Part 1: Simple Introduction to DAEs: Mass-Matrix Robertson Equations</a><a id="Part-1:-Simple-Introduction-to-DAEs:-Mass-Matrix-Robertson-Equations-1"></a><a class="docs-heading-anchor-permalink" href="#Part-1:-Simple-Introduction-to-DAEs:-Mass-Matrix-Robertson-Equations" title="Permalink"></a></h2><p>A mass-matrix ordinary differential equation (ODE) is an ODE where the left-hand side, the derivative side, is multiplied by a matrix known as the mass matrix. This is described as:</p><p class="math-container">\[Mu&#39; = f(u,p,t)\]</p><p>where <span>$M$</span> is the mass matrix. When <span>$M$</span> is invertible, there is an ODE which is equivalent to this formulation. When <span>$M$</span> is not invertible, this can have a distinctly different behavior and is as Differential-Algebraic Equation (DAE).</p><p>Solve the Robertson DAE:</p><p class="math-container">\[\begin{align}
\frac{dy_1}{dt} &amp;= -0.04y_1 + 10^4 y_2y_3\\
\frac{dy_2}{dt} &amp;=  0.04y_1 - 10^4 y_2y_3 - 3\times 10^7 y_2^2\\
1 &amp;= y_1 + y_2 + y_3\end{align}\]</p><p>with <span>$y(0) = [1,0,0]$</span> and <span>$dy(0) = [-0.04,0.04,0.0]$</span> using the mass-matrix formulation and <code>Rodas5()</code>. Use the <a href="https://docs.juliadiffeq.org/dev/types/ode_types">ODEProblem page</a> to find out how to declare a mass matrix.</p><p>(Hint: what if the last row has all zeros?)</p><h2 id="Part-2:-Solving-the-Implicit-Robertson-Equations-with-IDA"><a class="docs-heading-anchor" href="#Part-2:-Solving-the-Implicit-Robertson-Equations-with-IDA">Part 2: Solving the Implicit Robertson Equations with IDA</a><a id="Part-2:-Solving-the-Implicit-Robertson-Equations-with-IDA-1"></a><a class="docs-heading-anchor-permalink" href="#Part-2:-Solving-the-Implicit-Robertson-Equations-with-IDA" title="Permalink"></a></h2><p>Use the <a href="https://docs.juliadiffeq.org/dev/tutorials/dae_example">DAE Tutorial</a> to define a DAE in its implicit form and solve the Robertson equation with IDA. Why is <code>differential_vars = [true,true,false]</code>?</p><h2 id="Part-3:-Manual-Index-Reduction-of-the-Single-Pendulum"><a class="docs-heading-anchor" href="#Part-3:-Manual-Index-Reduction-of-the-Single-Pendulum">Part 3: Manual Index Reduction of the Single Pendulum</a><a id="Part-3:-Manual-Index-Reduction-of-the-Single-Pendulum-1"></a><a class="docs-heading-anchor-permalink" href="#Part-3:-Manual-Index-Reduction-of-the-Single-Pendulum" title="Permalink"></a></h2><p>The index of a DAE is a notion used to measure distance from its related ODE. There are many different definitions of index, but we&#39;re going to stick to the idea of differential index: the number of differentiations required to convert a system of DAEs into explicit ODE form. DAEs of high index are usually transformed via a procedure called index reduction. The following example will demonstrate this.</p><p>Consider the index 3 DAE system of the cartesian pendulum. After writing down the force equations in both directions, we arrive at the following DAE:</p><p class="math-container">\[
\begin{align}
m\ddot{x} &amp;= \frac{x}{L}T \\
m\ddot{y} &amp;= \frac{y}{L}T - mg \\
x^2 + y^2 &amp;= L
\end{align}
$$

Notice that we don&#39;t have an equation describing the
behaviour of `T`. Let us now perform index reduction to
extract an equation for `T`

Differentiate this third equation twice with respect to time
to reduce it from index 3 to index 1.

## Part 4: Single Pendulum Solution with IDA
Write these equations in implicit form and solve the system using
IDA.

## Part 5: Solving the Double Penulum DAE System

The following equations describe a double
pendulum system:
$$
\begin{align}
m_2\ddot{x_2} &amp;= \frac{x_2}{L_2}T_2 \\
m_2\ddot{y_2} &amp;= \frac{y_2}{L_2}T_2 - m_2g \\
{x_2}^2 + {y_2}^2 &amp;= L_2 \\
m_1\ddot{x_1} &amp;= \frac{x_1}{L_1}T_1 - \frac{x_2}{L_2}T_2 \\
m_2\ddot{y_1} &amp;= \frac{y_1}{L_1}T_2 - m_1g - \frac{y_2}{L_2}T_2 \\
{x_1}^2 + {y_1}^2 &amp;= L_1 \\
\end{align}
$$

Perform index reduction and solve it like in the previous example.

# Problem 4: Performance Optimizing and Parallelizing Semilinear PDE Solvers (I)

This problem will focus on implementing and optimizing the solution of the
2-dimensional Brusselator equations. The BRUSS equations are a well-known
highly stiff oscillatory system of partial differential equations which are
used in stiff ODE solver benchmarks. In this tutorial we will walk first
through a simple implementation, then do allocation-free implementations and
looking deep into solver options and benchmarking.

## Part 1: Implementing the BRUSS PDE System as ODEs

The Brusselator PDE is defined as follows:

$$\begin{align}
\frac{\partial u}{\partial t} &amp;= 1 + u^2v - 4.4u + \alpha(\frac{\partial^2 u}{\partial x^2} + \frac{\partial^2 u}{\partial y^2}) + f(x, y, t)\\
\frac{\partial v}{\partial t} &amp;= 3.4u - u^2v + \alpha(\frac{\partial^2 u}{\partial x^2} + \frac{\partial^2 u}{\partial y^2})\end{align}\]</p><p>where</p><p class="math-container">\[f(x, y, t) = \begin{cases}
5 &amp; \quad \text{if } (x-0.3)^2+(y-0.6)^2 â¤ 0.1^2 \text{ and } t â¥ 1.1 \\
0 &amp; \quad \text{else}\end{cases}\]</p><p>and the initial conditions are</p><p class="math-container">\[\begin{align}
u(x, y, 0) &amp;= 22\cdot y(1-y)^{3/2} \\
v(x, y, 0) &amp;= 27\cdot x(1-x)^{3/2}\end{align}\]</p><p>with the periodic boundary condition</p><p class="math-container">\[\begin{align}
u(x+1,y,t) &amp;= u(x,y,t) \\
u(x,y+1,t) &amp;= u(x,y,t)\end{align}\]</p><p>on a timespan of <span>$t \in [0,22]$</span>.</p><p>To solve this PDE, we will discretize it into a system of ODEs with the finite difference method. We discretize <code>u</code> and <code>v</code> into arrays of the values at each time point: <code>u[i,j] = u(i*dx,j*dy)</code> for some choice of <code>dx</code>/<code>dy</code>, and same for <code>v</code>. Then our ODE is defined with <code>U[i,j,k] = [u v]</code>. The second derivative operator, the Laplacian, discretizes to become a tridiagonal matrix with <code>[1 -2 1]</code> and a <code>1</code> in the top right and bottom left corners. The nonlinear functions are then applied at each point in space (they are broadcast). Use <code>dx=dy=1/32</code>.</p><p>You will know when you have the correct solution when you plot the solution at <code>x=y=0</code> and see a periodic orbit, e.g., <code>ts=0:0.05:22; plot(ts, sol1.(ts, idxs=1))</code>.</p><p>If you are not familiar with this process, see <a href="http://tutorials.juliadiffeq.org/html/introduction/03-optimizing_diffeq_code.html">the Gierer-Meinhardt example from the SciMLTutorials.</a></p><p>Note: Start by doing the simplest implementation!</p><h2 id="Part-2:-Optimizing-the-BRUSS-Code"><a class="docs-heading-anchor" href="#Part-2:-Optimizing-the-BRUSS-Code">Part 2: Optimizing the BRUSS Code</a><a id="Part-2:-Optimizing-the-BRUSS-Code-1"></a><a class="docs-heading-anchor-permalink" href="#Part-2:-Optimizing-the-BRUSS-Code" title="Permalink"></a></h2><p>PDEs are expensive to solve, and so we will go nowhere without some code optimizing! Follow the steps described in the <a href="http://tutorials.juliadiffeq.org/html/introduction/03-optimizing_diffeq_code.html">the Gierer-Meinhardt example from the SciMLTutorials</a> to optimize your Brusselator code. Try other formulations and see what ends up the fastest! Find a trade-off between performance and simplicity that suits your needs.</p><h2 id="Part-3:-Exploiting-Jacobian-Sparsity-with-Color-Differentiation"><a class="docs-heading-anchor" href="#Part-3:-Exploiting-Jacobian-Sparsity-with-Color-Differentiation">Part 3: Exploiting Jacobian Sparsity with Color Differentiation</a><a id="Part-3:-Exploiting-Jacobian-Sparsity-with-Color-Differentiation-1"></a><a class="docs-heading-anchor-permalink" href="#Part-3:-Exploiting-Jacobian-Sparsity-with-Color-Differentiation" title="Permalink"></a></h2><p>Use the <code>sparsity!</code> function from <a href="https://github.com/JuliaDiffEq/SparseDiffTools.jl">SparseDiffTools</a> to generate the sparsity pattern for the Jacobian of this problem. Follow the documentations <a href="https://docs.juliadiffeq.org/dev/features/performance_overloads">on the DiffEqFunction page</a> to specify the sparsity pattern of the Jacobian. Generate an add the color vector to speed up the computation of the Jacobian.</p><h2 id="(Optional)-Part-4:-Structured-Jacobians"><a class="docs-heading-anchor" href="#(Optional)-Part-4:-Structured-Jacobians">(Optional) Part 4: Structured Jacobians</a><a id="(Optional)-Part-4:-Structured-Jacobians-1"></a><a class="docs-heading-anchor-permalink" href="#(Optional)-Part-4:-Structured-Jacobians" title="Permalink"></a></h2><p>Specify the sparsity pattern using a BlockBandedMatrix from <a href="https://github.com/JuliaMatrices/BlockBandedMatrices.jl">BlockBandedMatrices.jl</a> to accelerate the previous sparsity handling tricks.</p><h2 id="(Optional)-Part-5:-Automatic-Symbolicification-and-Analytical-Jacobian"><a class="docs-heading-anchor" href="#(Optional)-Part-5:-Automatic-Symbolicification-and-Analytical-Jacobian">(Optional) Part 5: Automatic Symbolicification and Analytical Jacobian</a><a id="(Optional)-Part-5:-Automatic-Symbolicification-and-Analytical-Jacobian-1"></a><a class="docs-heading-anchor-permalink" href="#(Optional)-Part-5:-Automatic-Symbolicification-and-Analytical-Jacobian" title="Permalink"></a></h2><p>Use the <code>modelingtoolkitize</code> function from ModelingToolkit.jl to convert your numerical ODE function into a symbolic ODE function and use that to compute and solve with an analytical sparse Jacobian.</p><h2 id="Part-6:-Utilizing-Preconditioned-GMRES-Linear-Solvers"><a class="docs-heading-anchor" href="#Part-6:-Utilizing-Preconditioned-GMRES-Linear-Solvers">Part 6: Utilizing Preconditioned-GMRES Linear Solvers</a><a id="Part-6:-Utilizing-Preconditioned-GMRES-Linear-Solvers-1"></a><a class="docs-heading-anchor-permalink" href="#Part-6:-Utilizing-Preconditioned-GMRES-Linear-Solvers" title="Permalink"></a></h2><p>Use the <a href="https://docs.juliadiffeq.org/dev/features/linear_nonlinear">linear solver specification page</a> to solve the equation with <code>TRBDF2</code> with GMRES. Use the Sundials documentation to solve the equation with <code>CVODE_BDF</code> with Sundials&#39; special internal GMRES. To both of these, use the <a href="https://github.com/JuliaLinearAlgebra/AlgebraicMultigrid.jl">AlgebraicMultigrid.jl</a> to add a preconditioner to the GMRES solver.</p><h2 id="Part-7:-Exploring-IMEX-and-Exponential-Integrator-Techniques-(E)"><a class="docs-heading-anchor" href="#Part-7:-Exploring-IMEX-and-Exponential-Integrator-Techniques-(E)">Part 7: Exploring IMEX and Exponential Integrator Techniques (E)</a><a id="Part-7:-Exploring-IMEX-and-Exponential-Integrator-Techniques-(E)-1"></a><a class="docs-heading-anchor-permalink" href="#Part-7:-Exploring-IMEX-and-Exponential-Integrator-Techniques-(E)" title="Permalink"></a></h2><p>Instead of using the standard <code>ODEProblem</code>, define a <a href="https://docs.juliadiffeq.org/dev/types/split_ode_types"><code>SplitODEProblem</code></a> to move some of the equation to the &quot;non-stiff part&quot;. Try different splits and solve with <code>KenCarp4</code> to see if the solution can be accelerated.</p><p>Next, use <code>MatrixFreeOperator</code> and <code>DiffEqArrayOperator</code> to define part of the equation as linear, and use the <code>ETDRK4</code> exponential integrator to solve the equation. Note that this technique is not appropriate for this equation since it relies on the nonlinear term being non-stiff for best results.</p><h2 id="Part-8:-Work-Precision-Diagrams-for-Benchmarking-Solver-Choices"><a class="docs-heading-anchor" href="#Part-8:-Work-Precision-Diagrams-for-Benchmarking-Solver-Choices">Part 8: Work-Precision Diagrams for Benchmarking Solver Choices</a><a id="Part-8:-Work-Precision-Diagrams-for-Benchmarking-Solver-Choices-1"></a><a class="docs-heading-anchor-permalink" href="#Part-8:-Work-Precision-Diagrams-for-Benchmarking-Solver-Choices" title="Permalink"></a></h2><p>Use the <code>WorkPrecisionSet</code> method from <a href="https://github.com/JuliaDiffEq/DiffEqDevTools.jl">DiffEqDevTools.jl</a> to benchmark multiple different solver methods and find out what combination is most efficient. <a href="https://github.com/JuliaDiffEq/DiffEqBenchmarks.jl">Take a look at DiffEqBenchmarks.jl</a> for usage examples.</p><h2 id="Part-9:-GPU-Parallelism-for-PDEs-(E)"><a class="docs-heading-anchor" href="#Part-9:-GPU-Parallelism-for-PDEs-(E)">Part 9: GPU-Parallelism for PDEs (E)</a><a id="Part-9:-GPU-Parallelism-for-PDEs-(E)-1"></a><a class="docs-heading-anchor-permalink" href="#Part-9:-GPU-Parallelism-for-PDEs-(E)" title="Permalink"></a></h2><p>Fully vectorize your implementation of the ODE and use a <code>CuArray</code> from <a href="https://github.com/JuliaGPU/CuArrays.jl">CuArrays.jl</a> as the initial condition to cause the whole solution to be GPU accelerated.</p><h2 id="Part-10:-Adjoint-Sensitivity-Analysis-for-Gradients-of-PDEs"><a class="docs-heading-anchor" href="#Part-10:-Adjoint-Sensitivity-Analysis-for-Gradients-of-PDEs">Part 10: Adjoint Sensitivity Analysis for Gradients of PDEs</a><a id="Part-10:-Adjoint-Sensitivity-Analysis-for-Gradients-of-PDEs-1"></a><a class="docs-heading-anchor-permalink" href="#Part-10:-Adjoint-Sensitivity-Analysis-for-Gradients-of-PDEs" title="Permalink"></a></h2><p>In order to optimize the parameters of a PDE, you need to be able to compute the gradient of the solution with respect to the parameters. This is done through sensitivity analysis. For PDEs, generally the system is at a scale where forward sensitivity analysis (forward-mode automatic differentiation) is no longer suitable, and for these cases one uses adjoint sensitivity analysis.</p><p>Rewrite the PDE so the constant terms are parameters, and use the <a href="https://docs.juliadiffeq.org/latest/analysis/sensitivity/#Adjoint-Sensitivity-Analysis-1">adjoint sensitivity analysis</a> documentation to solve for the solution gradient with a cost function being the L2 distance of the solution from the value 1. Solve with interpolated and checkpointed adjoints. Play with using reverse-mode automatic differentiation vs direct computation of vector-Jacobian products using the <code>autojacvec</code> option of the <code>SensitivityAlg</code>. Find the set of options most suitable for this PDE.</p><p>If you have compute time, use this adjoint to optimize the parameters of the PDE with respect to this cost function.</p><h1 id="Problem-5:-Global-Parameter-Sensitivity-and-Optimality-with-GPU-and-Distributed-Ensembles-(B)"><a class="docs-heading-anchor" href="#Problem-5:-Global-Parameter-Sensitivity-and-Optimality-with-GPU-and-Distributed-Ensembles-(B)">Problem 5: Global Parameter Sensitivity and Optimality with GPU and Distributed Ensembles (B)</a><a id="Problem-5:-Global-Parameter-Sensitivity-and-Optimality-with-GPU-and-Distributed-Ensembles-(B)-1"></a><a class="docs-heading-anchor-permalink" href="#Problem-5:-Global-Parameter-Sensitivity-and-Optimality-with-GPU-and-Distributed-Ensembles-(B)" title="Permalink"></a></h1><p>In this example we will investigate how the parameters &quot;generally&quot; effect the solution in the chaotic Henon-Heiles system. By &quot;generally&quot; we will use global sensitivity analysis methods to get an average global characterization of the parameters on the solution. In addition to a global sensitivity approach, we will generate large ensembles of solutions with different parameters using a GPU-based parallelism approach.</p><h2 id="Part-1:-Implementing-the-Henon-Heiles-System-(B)"><a class="docs-heading-anchor" href="#Part-1:-Implementing-the-Henon-Heiles-System-(B)">Part 1: Implementing the Henon-Heiles System (B)</a><a id="Part-1:-Implementing-the-Henon-Heiles-System-(B)-1"></a><a class="docs-heading-anchor-permalink" href="#Part-1:-Implementing-the-Henon-Heiles-System-(B)" title="Permalink"></a></h2><p>The Henon-Heiles Hamiltonian system is described by the ODEs:</p><p class="math-container">\[\begin{align}
\frac{dp_1}{dt} &amp;= -q_1 (1 + 2q_2)\\
\frac{dp_2}{dt} &amp;= -q_2 - (q_1^2 - q_2^2)\\
\frac{dq_1}{dt} &amp;= p_1\\
\frac{dq_2}{dt} &amp;= p_2\end{align}\]</p><p>with initial conditions <span>$u_0 = [0.1,0.0,0.0,0.5]$</span>. Solve this system over the timespan <span>$t\in[0,1000]$</span></p><h2 id="(Optional)-Part-2:-Alternative-Dynamical-Implmentations-of-Henon-Heiles-(B)"><a class="docs-heading-anchor" href="#(Optional)-Part-2:-Alternative-Dynamical-Implmentations-of-Henon-Heiles-(B)">(Optional) Part 2: Alternative Dynamical Implmentations of Henon-Heiles (B)</a><a id="(Optional)-Part-2:-Alternative-Dynamical-Implmentations-of-Henon-Heiles-(B)-1"></a><a class="docs-heading-anchor-permalink" href="#(Optional)-Part-2:-Alternative-Dynamical-Implmentations-of-Henon-Heiles-(B)" title="Permalink"></a></h2><p>The Henon-Heiles defines a Hamiltonian system with certain structures which can be utilized for a more efficient solution. Use <a href="https://docs.juliadiffeq.org/dev/types/dynamical_types">the Dynamical problems page</a> to define a <code>SecondOrderODEProblem</code> corresponding to the acceleration terms:</p><p class="math-container">\[\begin{align}
\frac{d^2q_1}{dt^2} &amp;= -q_1 (1 + 2q_2)\\
\frac{d^2q_2}{dt^2} &amp;= -q_2 - (q_1^2 - q_2^2)\end{align}\]</p><p>Solve this with a method that is specific to dynamical problems, like <code>DPRKN6</code>.</p><p>The Hamiltonian can also be directly described:</p><p class="math-container">\[H(p,q) = \frac{1}{2}(p_1^2 + p_2^2) + \frac{1}{2}(q_1^2+q_2^2+2q_1^2 q_2 - \frac{2}{3}q_2^3)\]</p><p>Solve this problem using the <code>HamiltonianProblem</code> constructor from DiffEqPhysics.jl.</p><h2 id="Part-3:-Parallelized-Ensemble-Solving"><a class="docs-heading-anchor" href="#Part-3:-Parallelized-Ensemble-Solving">Part 3: Parallelized Ensemble Solving</a><a id="Part-3:-Parallelized-Ensemble-Solving-1"></a><a class="docs-heading-anchor-permalink" href="#Part-3:-Parallelized-Ensemble-Solving" title="Permalink"></a></h2><p>To understand the orbits of the Henon-Heiles system, it can be useful to solve the system with many different initial conditions. Use the <a href="https://docs.juliadiffeq.org/dev/features/ensemble">ensemble interface</a> to solve with randomized initial conditions in parallel using threads with <code>EnsembleThreads()</code>. Then, use <code>addprocs()</code> to add more cores and solve using <code>EnsembleDistributed()</code>. The former will solve using all of the cores on a single computer, while the latter will use all of the cores on which there are processors, which can include thousands across a supercomputer! See <a href="https://docs.julialang.org/en/v1/manual/parallel-computing/index.html">Julia&#39;s parallel computing setup page</a> for more details on the setup.</p><h2 id="Part-4:-Parallelized-GPU-Ensemble-Solving"><a class="docs-heading-anchor" href="#Part-4:-Parallelized-GPU-Ensemble-Solving">Part 4: Parallelized GPU Ensemble Solving</a><a id="Part-4:-Parallelized-GPU-Ensemble-Solving-1"></a><a class="docs-heading-anchor-permalink" href="#Part-4:-Parallelized-GPU-Ensemble-Solving" title="Permalink"></a></h2><p>Setup the CUDAnative.jl library and use the <code>EnsembleGPUArray()</code> method to parallelize the solution across the thousands of cores of a GPU. Note that this will efficiency solve for hundreds of thousands of trajectores.</p><h1 id="Problem-6:-Training-Neural-Stochastic-Differential-Equations-with-GPU-acceleration-(I)"><a class="docs-heading-anchor" href="#Problem-6:-Training-Neural-Stochastic-Differential-Equations-with-GPU-acceleration-(I)">Problem 6: Training Neural Stochastic Differential Equations with GPU acceleration (I)</a><a id="Problem-6:-Training-Neural-Stochastic-Differential-Equations-with-GPU-acceleration-(I)-1"></a><a class="docs-heading-anchor-permalink" href="#Problem-6:-Training-Neural-Stochastic-Differential-Equations-with-GPU-acceleration-(I)" title="Permalink"></a></h1><p>In the previous models we had to define a model. Now let&#39;s shift the burden of model-proofing onto data by utilizing neural differential equations. A neural differential equation is a differential equation where the model equations are replaced, either in full or in part, by a neural network. For example, a neural ordinary differential equation is an equation <span>$u^\prime = f(u,p,t)$</span> where <span>$f$</span> is a neural network. We can learn this neural network from data using various methods, the easiest of which is known as the single shooting method, where one chooses neural network parameters, solves the equation, and checks the ODE&#39;s solution against data as a loss.</p><p>In this example we will define and train various forms of neural differential equations. Note that all of the differential equation types are compatible with neural differential equations, so this is only going to scratch the surface of the possibilites!</p><h2 id="Part-1:-Constructing-and-Training-a-Basic-Neural-ODE"><a class="docs-heading-anchor" href="#Part-1:-Constructing-and-Training-a-Basic-Neural-ODE">Part 1: Constructing and Training a Basic Neural ODE</a><a id="Part-1:-Constructing-and-Training-a-Basic-Neural-ODE-1"></a><a class="docs-heading-anchor-permalink" href="#Part-1:-Constructing-and-Training-a-Basic-Neural-ODE" title="Permalink"></a></h2><p>Use the <a href="https://github.com/JuliaDiffEq/DiffEqFlux.jl">DiffEqFlux.jl README</a> to construct a neural ODE to train against the training data:</p><pre><code class="language-julia hljs">
u0 = Float32[2.; 0.]
datasize = 30
tspan = (0.0f0,1.5f0)

function trueODEfunc(du,u,p,t)
    true_A = [-0.1 2.0; -2.0 -0.1]
    du .= ((u.^3)&#39;true_A)&#39;
end
t = range(tspan[1],tspan[2],length=datasize)
prob = ODEProblem(trueODEfunc,u0,tspan)
ode_data = Array(solve(prob,Tsit5(),saveat=t))</code></pre><h2 id="Part-2:-GPU-accelerating-the-Neural-ODE-Process"><a class="docs-heading-anchor" href="#Part-2:-GPU-accelerating-the-Neural-ODE-Process">Part 2: GPU-accelerating the Neural ODE Process</a><a id="Part-2:-GPU-accelerating-the-Neural-ODE-Process-1"></a><a class="docs-heading-anchor-permalink" href="#Part-2:-GPU-accelerating-the-Neural-ODE-Process" title="Permalink"></a></h2><p>Use the <code>gpu</code> function from Flux.jl to transform all of the calculations onto the GPU and train the neural ODE using GPU-accelerated <code>Tsit5</code> with adjoints.</p><h2 id="Part-3:-Defining-and-Training-a-Mixed-Neural-ODE"><a class="docs-heading-anchor" href="#Part-3:-Defining-and-Training-a-Mixed-Neural-ODE">Part 3: Defining and Training a Mixed Neural ODE</a><a id="Part-3:-Defining-and-Training-a-Mixed-Neural-ODE-1"></a><a class="docs-heading-anchor-permalink" href="#Part-3:-Defining-and-Training-a-Mixed-Neural-ODE" title="Permalink"></a></h2><p>Gather data from the Lotka-Volterra equation:</p><pre><code class="language-julia hljs">
function lotka_volterra(du,u,p,t)
  x, y = u
  Î±, Î², Î´, Î³ = p
  du[1] = dx = Î±*x - Î²*x*y
  du[2] = dy = -Î´*y + Î³*x*y
end
u0 = [1.0,1.0]
tspan = (0.0,10.0)
p = [1.5,1.0,3.0,1.0]
prob = ODEProblem(lotka_volterra,u0,tspan,p)
sol = Array(solve(prob,Tsit5())(0.0:1.0:10.0))</code></pre><p>Now use the <a href="https://github.com/JuliaDiffEq/DiffEqFlux.jl#mixed-neural-des">mixed neural section of the documentation</a> to define the mixed neural ODE where the functional form of <span>$\frac{dx}{dt}$</span> is known, and try to derive a neural formulation for <span>$\frac{dy}{dt}$</span> directly from the data.</p><h2 id="Part-4:-Constructing-a-Basic-Neural-SDE"><a class="docs-heading-anchor" href="#Part-4:-Constructing-a-Basic-Neural-SDE">Part 4: Constructing a Basic Neural SDE</a><a id="Part-4:-Constructing-a-Basic-Neural-SDE-1"></a><a class="docs-heading-anchor-permalink" href="#Part-4:-Constructing-a-Basic-Neural-SDE" title="Permalink"></a></h2><p>Generate data from the Lotka-Volterra equation with multiplicative noise</p><pre><code class="language-julia hljs">
function lotka_volterra(du,u,p,t)
  x, y = u
  Î±, Î², Î´, Î³ = p
  du[1] = dx = Î±*x - Î²*x*y
  du[2] = dy = -Î´*y + Î³*x*y
end
function lv_noise(du,u,p,t)
  du[1] = p[5]*u[1]
  du[2] = p[6]*u[2]
end
u0 = [1.0,1.0]
tspan = (0.0,10.0)
p = [1.5,1.0,3.0,1.0,0.1,0.1]
prob = SDEProblem(lotka_volterra,lv_noise,u0,tspan,p)
sol = [Array(solve(prob,SOSRI())(0.0:1.0:10.0)) for i in 1:20] # 20 solution samples</code></pre><p>Train a neural stochastic differential equation <span>$dX = f(X)dt + g(X)dW_t$</span> where both the drift (<span>$f$</span>) and the diffusion (<span>$g$</span>) functions are neural networks. See if constraining <span>$g$</span> can make the problem easier to fit.</p><h2 id="Part-5:-Optimizing-the-training-behavior-with-minibatching-(E)"><a class="docs-heading-anchor" href="#Part-5:-Optimizing-the-training-behavior-with-minibatching-(E)">Part 5: Optimizing the training behavior with minibatching (E)</a><a id="Part-5:-Optimizing-the-training-behavior-with-minibatching-(E)-1"></a><a class="docs-heading-anchor-permalink" href="#Part-5:-Optimizing-the-training-behavior-with-minibatching-(E)" title="Permalink"></a></h2><p>Use minibatching on the data to improve the training procedure. An example <a href="https://github.com/FluxML/model-zoo/pull/88">can be found at this PR</a>.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../model_inference/02-monte_carlo_parameter_estim/">Â« Monte Carlo Parameter Estimation From Data</a><a class="docs-footer-nextpage" href="../02-workshop_solutions/">SciML Workshop Exercise Solutions Â»</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.23 on <span class="colophon-date" title="Saturday 3 December 2022 00:55">Saturday 3 December 2022</span>. Using Julia version 1.8.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
