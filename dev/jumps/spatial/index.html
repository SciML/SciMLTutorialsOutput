<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Tutorial on using spatial SSAs in DiffEqJump · The SciML Tutorials</title><script data-outdated-warner src="../../assets/warner.js"></script><link rel="canonical" href="https://tutorials.sciml.ai/stable/jumps/spatial/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">The SciML Tutorials</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">SciMLTutorials.jl: Tutorials for Scientific Machine Learning (SciML), Equation Solvers, and AI for Science</a></li><li><span class="tocitem">DiffEqUncertainty</span><ul><li><a class="tocitem" href="../../DiffEqUncertainty/01-expectation_introduction/">An Intro to Expectations via DiffEqUncertainty.jl</a></li><li><a class="tocitem" href="../../DiffEqUncertainty/02-AD_and_optimization/">Optimization Under Uncertainty with DiffEqUncertainty.jl</a></li></ul></li><li><span class="tocitem">advanced</span><ul><li><a class="tocitem" href="../../advanced/01-beeler_reuter/">An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model</a></li><li><a class="tocitem" href="../../advanced/02-diffusion_implicit_heat_equation/">Solving the heat equation with diffusion-implicit time-stepping</a></li></ul></li><li><span class="tocitem">exercises</span><ul><li><a class="tocitem" href="../../exercises/01-workshop_exercises/">SciML Workshop Exercises</a></li><li><a class="tocitem" href="../../exercises/02-workshop_solutions/">SciML Workshop Exercise Solutions</a></li></ul></li><li><span class="tocitem">jumps</span><ul><li class="is-active"><a class="tocitem" href>Tutorial on using spatial SSAs in DiffEqJump</a><ul class="internal"><li><a class="tocitem" href="#Installing-DiffEqJump"><span>Installing <code>DiffEqJump</code></span></a></li><li><a class="tocitem" href="#Reversible-binding-model-on-a-grid"><span>Reversible binding model on a grid</span></a></li><li><a class="tocitem" href="#Animation"><span>Animation</span></a></li><li><a class="tocitem" href="#Making-changes-to-the-model"><span>Making changes to the model</span></a></li><li><a class="tocitem" href="#References"><span>References</span></a></li></ul></li></ul></li><li><span class="tocitem">model_inference</span><ul><li><a class="tocitem" href="../../model_inference/01-pendulum_bayesian_inference/">Bayesian Inference on a Pendulum using DiffEqBayes.jl</a></li><li><a class="tocitem" href="../../model_inference/02-monte_carlo_parameter_estim/">Monte Carlo Parameter Estimation From Data</a></li></ul></li><li><span class="tocitem">models</span><ul><li><a class="tocitem" href="../../models/01-classical_physics/">Classical Physics Models</a></li><li><a class="tocitem" href="../../models/02-conditional_dosing/">Conditional Dosing Pharmacometric Example</a></li><li><a class="tocitem" href="../../models/03-kepler_problem/">Kepler Problem</a></li><li><a class="tocitem" href="../../models/04-spiking_neural_systems/">Spiking Neural Systems</a></li></ul></li><li><span class="tocitem">odes</span><ul><li><a class="tocitem" href="../../odes/01-ode_minmax/">Finding Maxima and Minima of Ordinary Differential Equation Solutions</a></li></ul></li><li><span class="tocitem">perturbation</span><ul><li><a class="tocitem" href="../../perturbation/01-perturbation_algebraic/">Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations</a></li><li><a class="tocitem" href="../../perturbation/02-perturbation_differential/">Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations</a></li></ul></li><li><span class="tocitem">type_handling</span><ul><li><a class="tocitem" href="../../type_handling/02-uncertainties/">Numbers with Uncertainties</a></li><li><a class="tocitem" href="../../type_handling/03-unitful/">Unit Checked Arithmetic via Unitful.jl</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">jumps</a></li><li class="is-active"><a href>Tutorial on using spatial SSAs in DiffEqJump</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Tutorial on using spatial SSAs in DiffEqJump</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/SciML/SciMLTutorialsOutput/blob/main/docs/src/jumps/spatial.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Tutorial-on-using-spatial-SSAs-in-DiffEqJump"><a class="docs-heading-anchor" href="#Tutorial-on-using-spatial-SSAs-in-DiffEqJump">Tutorial on using spatial SSAs in DiffEqJump</a><a id="Tutorial-on-using-spatial-SSAs-in-DiffEqJump-1"></a><a class="docs-heading-anchor-permalink" href="#Tutorial-on-using-spatial-SSAs-in-DiffEqJump" title="Permalink"></a></h1><p>This tutorial shows how to use spatial solvers added to <a href="https://github.com/SciML/DiffEqJump.jl"><code>DiffEqJump</code></a> in summer 2021. See <a href="https://diffeq.sciml.ai/latest/types/jump_types/">the documentation</a> for a tutorial on getting started with <code>DiffEqJump</code>.</p><h2 id="Installing-DiffEqJump"><a class="docs-heading-anchor" href="#Installing-DiffEqJump">Installing <code>DiffEqJump</code></a><a id="Installing-DiffEqJump-1"></a><a class="docs-heading-anchor-permalink" href="#Installing-DiffEqJump" title="Permalink"></a></h2><p>Once in REPL, do <code>] add DiffEqJump</code>. After the installation finishes, you will be able to use all the functionality described below.</p><h2 id="Reversible-binding-model-on-a-grid"><a class="docs-heading-anchor" href="#Reversible-binding-model-on-a-grid">Reversible binding model on a grid</a><a id="Reversible-binding-model-on-a-grid-1"></a><a class="docs-heading-anchor-permalink" href="#Reversible-binding-model-on-a-grid" title="Permalink"></a></h2><p>A 5 by 5 Cartesian grid:</p><table><tr><th style="text-align: right">&lt;!– –&gt;</th><th style="text-align: right">&lt;!– –&gt;</th><th style="text-align: right">&lt;!– –&gt;</th><th style="text-align: right">&lt;!– –&gt;</th><th style="text-align: right">&lt;!– –&gt;</th></tr><tr><td style="text-align: right">.</td><td style="text-align: right">.</td><td style="text-align: right">.</td><td style="text-align: right">.</td><td style="text-align: right">B</td></tr><tr><td style="text-align: right">.</td><td style="text-align: right">.</td><td style="text-align: right">.</td><td style="text-align: right">.</td><td style="text-align: right">.</td></tr><tr><td style="text-align: right">.</td><td style="text-align: right">.</td><td style="text-align: right">.</td><td style="text-align: right">.</td><td style="text-align: right">.</td></tr><tr><td style="text-align: right">.</td><td style="text-align: right">.</td><td style="text-align: right">.</td><td style="text-align: right">.</td><td style="text-align: right">.</td></tr><tr><td style="text-align: right">A</td><td style="text-align: right">.</td><td style="text-align: right">.</td><td style="text-align: right">.</td><td style="text-align: right">.</td></tr></table><p>Suppose we have a reversible binding system described by <span>$A+B \to C$</span> at rate <span>$k_1$</span> and <span>$C \to A+B$</span> at rate <span>$k_2$</span>. Further suppose that all <span>$A$</span> molecules start in the lower left corner, while all <span>$B$</span> molecules start in the upper right corner of a 5 by 5 grid. There are no <span>$C$</span> molecules at the start.</p><p>We first create the grid:</p><pre><code class="language-julia hljs">using DiffEqJump
dims = (5,5)
num_nodes = prod(dims) # number of sites
grid = CartesianGrid(dims) # or use LightGraphs.grid(dims)</code></pre><pre><code class="nohighlight hljs">A Cartesian grid with dimensions (5, 5)</code></pre><p>Now we set the initial state of the simulation. It has to be a matrix with entry <span>$(s,i)$</span> being the number of species <span>$s$</span> at site <span>$i$</span> (with the standard column-major ordering of the grid).</p><pre><code class="language-julia hljs">num_species = 3
starting_state = zeros(Int, num_species, num_nodes)
starting_state[1,1] = 25
starting_state[2,end] = 25
starting_state</code></pre><pre><code class="nohighlight hljs">3×25 Matrix{Int64}:
 25  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0
0
  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  2
5
  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0
0</code></pre><p>We now set the time-span of the simulation and the reaction rates. These can be chosen arbitrarily.</p><pre><code class="language-julia hljs">tspan = (0.0, 3.0)
rates = [6.0, 0.05] # k_1 = rates[1], k_2 = rates[2]</code></pre><pre><code class="nohighlight hljs">2-element Vector{Float64}:
 6.0
 0.05</code></pre><p>Now we can create the <code>DiscreteProblem</code>:</p><pre><code class="language-julia hljs">prob = DiscreteProblem(starting_state, tspan, rates)</code></pre><pre><code class="nohighlight hljs">DiscreteProblem with uType Matrix{Int64} and tType Float64. In-place: true
timespan: (0.0, 3.0)
u0: 3×25 Matrix{Int64}:
 25  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0
0
  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  2
5
  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0
0</code></pre><p>Since both reactions are <a href="https://en.wikipedia.org/wiki/Law_of_mass_action">massaction reactions</a>, we put them together in a <code>MassActionJump</code>. In order to do that we create two stoichiometry vectors. The net stoichiometry vector describes which molecules change in number and how much after each reaction; for example, <code>[1 =&gt; -1]</code> is the first molecule disappearing. The reaction stoichiometry vector describes what the reactants of each reaction are; for example, <code>[1 =&gt; 1, 2 =&gt; 1]</code> would mean that the reactants are one molecule of type 1 and one molecule of type 2.</p><pre><code class="language-julia hljs">netstoch = [[1 =&gt; -1, 2 =&gt; -1, 3 =&gt; 1],[1 =&gt; 1, 2 =&gt; 1, 3 =&gt; -1]]
reactstoch = [[1 =&gt; 1, 2 =&gt; 1],[3 =&gt; 1]]
majumps = MassActionJump(rates, reactstoch, netstoch)</code></pre><pre><code class="nohighlight hljs">DiffEqJump.MassActionJump{Vector{Float64}, Vector{Vector{Pair{Int64, Int64}
}}, Vector{Vector{Pair{Int64, Int64}}}, Nothing}([6.0, 0.05], [[1 =&gt; 1, 2 =
&gt; 1], [3 =&gt; 1]], [[1 =&gt; -1, 2 =&gt; -1, 3 =&gt; 1], [1 =&gt; 1, 2 =&gt; 1, 3 =&gt; -1]], n
othing)</code></pre><p>The last thing to set up is the hopping constants – the probability per time of an individual molecule of each species hopping from one site to another site. In practice this parameter, as well as reaction rates, are obtained empirically. Suppose that molecule <span>$C$</span> cannot diffuse, while molecules <span>$A$</span> and <span>$B$</span> diffuse at probability per time 1 (i.e. the time of the diffusive hop is exponentially distributed with mean 1). Entry <span>$(s,i)$</span> of <code>hopping_constants</code> is the hopping rate of species <span>$s$</span> at site <span>$i$</span> to any of its neighboring sites (diagonal hops are not allowed).</p><pre><code class="language-julia hljs">hopping_constants = ones(num_species, num_nodes)
hopping_constants[3, :] .= 0.0
hopping_constants</code></pre><pre><code class="nohighlight hljs">3×25 Matrix{Float64}:
 1.0  1.0  1.0  1.0  1.0  1.0  1.0  1.0  …  1.0  1.0  1.0  1.0  1.0  1.0  1
.0
 1.0  1.0  1.0  1.0  1.0  1.0  1.0  1.0     1.0  1.0  1.0  1.0  1.0  1.0  1
.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0  0
.0</code></pre><p>We are now ready to set up the <code>JumpProblem</code> with the Next Subvolume Method.</p><pre><code class="language-julia hljs">alg = NSM()
jump_prob = JumpProblem(prob, alg, majumps, hopping_constants=hopping_constants, spatial_system = grid, save_positions=(true, false))</code></pre><pre><code class="nohighlight hljs">Number of constant rate jumps: 0
Number of variable rate jumps: 0
Have a mass action jump</code></pre><p>The <code>save_positions</code> keyword tells the solver to save the positions just before the jumps. To solve the jump problem do</p><pre><code class="language-julia hljs">solution = solve(jump_prob, SSAStepper())</code></pre><pre><code class="nohighlight hljs">retcode: Default
Interpolation: Piecewise constant interpolation
t: 401-element Vector{Float64}:
 0.0
 0.01805156477589096
 0.021927208873289517
 0.025769109693334135
 0.03515984244149274
 0.041941982193058974
 0.052156972679011
 0.07268000778197724
 0.08516521051878839
 0.09139750379283877
 ⋮
 2.959136931928465
 2.9646237117842693
 2.9651086896415113
 2.9728489281258383
 2.9739124562005443
 2.9757635813669086
 2.9813576277964904
 2.994984074931063
 3.0
u: 401-element Vector{Matrix{Int64}}:
 [25 0 … 0 0; 0 0 … 0 25; 0 0 … 0 0]
 [24 1 … 0 0; 0 0 … 0 25; 0 0 … 0 0]
 [24 0 … 0 0; 0 0 … 0 25; 0 0 … 0 0]
 [24 0 … 0 0; 0 0 … 0 24; 0 0 … 0 0]
 [24 0 … 0 0; 0 0 … 0 23; 0 0 … 0 0]
 [24 0 … 0 0; 0 0 … 0 22; 0 0 … 0 0]
 [23 1 … 0 0; 0 0 … 0 22; 0 0 … 0 0]
 [22 2 … 0 0; 0 0 … 0 22; 0 0 … 0 0]
 [22 2 … 0 0; 0 0 … 0 23; 0 0 … 0 0]
 [21 2 … 0 0; 0 0 … 0 23; 0 0 … 0 0]
 ⋮
 [1 4 … 0 0; 0 0 … 1 0; 0 0 … 0 0]
 [1 4 … 0 0; 0 0 … 1 0; 0 0 … 0 0]
 [2 3 … 0 0; 0 0 … 1 0; 0 0 … 0 0]
 [2 3 … 0 0; 0 0 … 2 0; 0 0 … 0 0]
 [2 3 … 0 0; 0 0 … 2 0; 0 0 … 0 0]
 [2 3 … 0 0; 0 0 … 2 0; 0 0 … 0 0]
 [2 3 … 0 0; 0 0 … 2 1; 0 0 … 0 0]
 [2 2 … 0 0; 0 0 … 2 1; 0 0 … 0 0]
 [2 2 … 0 0; 0 0 … 2 1; 0 0 … 0 0]</code></pre><h2 id="Animation"><a class="docs-heading-anchor" href="#Animation">Animation</a><a id="Animation-1"></a><a class="docs-heading-anchor-permalink" href="#Animation" title="Permalink"></a></h2><p>Visualizing solutions of spatial jump problems is best done with animations.</p><pre><code class="language-julia hljs">using Plots
is_static(spec) = (spec == 3) # true if spec does not hop
&quot;get frame k&quot;
function get_frame(k, sol, linear_size, labels, title)
    num_species = length(labels)
    h = 1/linear_size
    t = sol.t[k]
    state = sol.u[k]
    xlim=(0,1+3h/2); ylim=(0,1+3h/2);
    plt = plot(xlim=xlim, ylim=ylim, title = &quot;$title, $(round(t, sigdigits=3)) seconds&quot;)

    species_seriess_x = [[] for i in 1:num_species]
    species_seriess_y = [[] for i in 1:num_species]
    CI = CartesianIndices((linear_size, linear_size))
    for ci in CartesianIndices(state)
        species, site = Tuple(ci)
        x,y = Tuple(CI[site])
        num_molecules = state[ci]
        sizehint!(species_seriess_x[species], num_molecules)
        sizehint!(species_seriess_y[species], num_molecules)
        if !is_static(species)
            randsx = rand(num_molecules)
            randsy = rand(num_molecules)
        else
            randsx = zeros(num_molecules)
            randsy = zeros(num_molecules)
        end
        for k in 1:num_molecules
            push!(species_seriess_x[species], x*h - h/4 + 0.5h*randsx[k])
            push!(species_seriess_y[species], y*h - h/4 + 0.5h*randsy[k])
        end
    end
    for species in 1:num_species
        scatter!(plt, species_seriess_x[species], species_seriess_y[species], label = labels[species], marker = 6)
    end
    xticks!(plt, range(xlim...,length = linear_size+1))
    yticks!(plt, range(ylim...,length = linear_size+1))
    xgrid!(plt, 1, 0.7)
    ygrid!(plt, 1, 0.7)
    return plt
end

&quot;make an animation of solution sol in 2 dimensions&quot;
function animate_2d(sol, linear_size; species_labels, title, verbose = true)
    num_frames = length(sol.t)
    anim = @animate for k=1:num_frames
        verbose &amp;&amp; println(&quot;Making frame $k&quot;)
        get_frame(k, sol, linear_size, species_labels, title)
    end
    anim
end
# animate
anim=animate_2d(solution, 5, species_labels = [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;], title = &quot;A + B &lt;--&gt; C&quot;, verbose = false)
fps = 5
gif(anim, fps = fps)</code></pre><pre><code class="nohighlight hljs">Plots.AnimatedGif(&quot;/var/lib/buildkite-agent/builds/7-amdci4-julia-csail-mit
-edu/julialang/scimltutorials-dot-jl/markdown/jumps/tmp.gif&quot;)</code></pre><h2 id="Making-changes-to-the-model"><a class="docs-heading-anchor" href="#Making-changes-to-the-model">Making changes to the model</a><a id="Making-changes-to-the-model-1"></a><a class="docs-heading-anchor-permalink" href="#Making-changes-to-the-model" title="Permalink"></a></h2><p>Now suppose we want to make some changes to the reversible binding model above. There are three &quot;dimensions&quot; that can be changed: the topology of the system, the structure of hopping rates and the solver. The supported topologies are <code>CartesianGrid</code> – used above, and any <code>AbstractGraph</code> from <code>LightGraphs</code>. The supported forms of hopping rates are <span>$D_{s,i}, D_{s,i,j}, D_s * L_{i,j}$</span>, and <span>$D_{s,i} * L_{i,j}$</span>, where <span>$s$</span> denotes the species, <span>$i$</span> – the source site, and <span>$j$</span> – the destination. The supported solvers are <code>NSM</code>, <code>DirectCRDirect</code> and any of the standard non-spatial solvers.</p><h3 id="Topology"><a class="docs-heading-anchor" href="#Topology">Topology</a><a id="Topology-1"></a><a class="docs-heading-anchor-permalink" href="#Topology" title="Permalink"></a></h3><p>If our mesh is a grid (1D, 2D and 3D are supported), we can create the mesh as follows.</p><pre><code class="language-julia hljs">dims = (2,3,4) # can pass in a 1-Tuple, a 2-Tuple or a 3-Tuple
num_nodes = prod(dims)
grid = CartesianGrid(dims)</code></pre><pre><code class="nohighlight hljs">A Cartesian grid with dimensions (2, 3, 4)</code></pre><p>The interface is the same as for <a href="https://juliagraphs.org/LightGraphs.jl/latest/generators/#LightGraphs.SimpleGraphs.grid-Union{Tuple{AbstractVector{T}},%20Tuple{T}}%20where%20T%3C:Integer"><code>LightGraphs.grid</code></a>. If we want to use an unstructured mesh, we can simply use any <code>AbstractGraph</code> from <code>LightGraphs</code> as follows:</p><pre><code class="language-julia hljs">using LightGraphs
graph = cycle_digraph(5) # directed cyclic graph on 5 nodes</code></pre><pre><code class="nohighlight hljs">{5, 5} directed simple Int64 graph</code></pre><p>Now either <code>graph</code> or <code>grid</code> can be used as <code>spatial_system</code> in creation of the <code>JumpProblem</code>.</p><h3 id="Hopping-rates"><a class="docs-heading-anchor" href="#Hopping-rates">Hopping rates</a><a id="Hopping-rates-1"></a><a class="docs-heading-anchor-permalink" href="#Hopping-rates" title="Permalink"></a></h3><p>The most general form of hopping rates that is supported is <span>$D_{s,i,j}$</span> – each (species, source, destination) triple gets its own independent hopping rate. To use this, <code>hopping_constants</code> must be of type <code>Matrix{Vector{F}} where F &lt;: Number</code> (usually <code>F</code> is <code>Float64</code>) with <code>hopping_constants[s,i][j]</code> being the hopping rate of species <span>$s$</span> at site <span>$i$</span> to neighbor at index <span>$j$</span>. Note that neighbors are in ascending order, like in <code>LightGraphs</code>. Here is an example where only hopping up and left is allowed.</p><pre><code class="language-julia hljs">hopping_constants = Matrix{Vector{Float64}}(undef, num_species, num_nodes)
for ci in CartesianIndices(hopping_constants)
    (species, site) = Tuple(ci)
    hopping_constants[species, site] = zeros(outdegree(grid, site))
    for (n, nb) in enumerate(neighbors(grid, site))
        if nb &lt; site
            hopping_constants[species, site][n] = 1.0
        end
    end
end</code></pre><p>To pass in <code>hopping_constants</code> of form <span>$D_s * L_{i,j}$</span> we need two vectors – one for <span>$D_s$</span> and one for <span>$L_{i,j}$</span>. Here is an example.</p><pre><code class="language-julia hljs">species_hop_constants = ones(num_species)
site_hop_constants = Vector{Vector{Float64}}(undef, num_nodes)
for site in 1:num_nodes
    site_hop_constants[site] = ones(outdegree(grid, site))
end
hopping_constants=Pair(species_hop_constants, site_hop_constants)</code></pre><pre><code class="nohighlight hljs">[1.0, 1.0, 1.0] =&gt; [[1.0, 1.0, 1.0], [1.0, 1.0, 1.0], [1.0, 1.0, 1.0, 1.0],
 [1.0, 1.0, 1.0, 1.0], [1.0, 1.0, 1.0], [1.0, 1.0, 1.0], [1.0, 1.0, 1.0, 1.
0], [1.0, 1.0, 1.0, 1.0], [1.0, 1.0, 1.0, 1.0, 1.0], [1.0, 1.0, 1.0, 1.0, 1
.0]  …  [1.0, 1.0, 1.0, 1.0, 1.0], [1.0, 1.0, 1.0, 1.0, 1.0], [1.0, 1.0, 1.
0, 1.0], [1.0, 1.0, 1.0, 1.0], [1.0, 1.0, 1.0], [1.0, 1.0, 1.0], [1.0, 1.0,
 1.0, 1.0], [1.0, 1.0, 1.0, 1.0], [1.0, 1.0, 1.0], [1.0, 1.0, 1.0]]</code></pre><p>We must combine both vectors into a pair as in the last line above.</p><p>Finally, to use in <code>hopping_constants</code> of form <span>$D_{s,i} * L_{i,j}$</span> we construct a matrix instead of a vector for <span>$D_{s,j}$</span>.</p><pre><code class="language-julia hljs">species_hop_constants = ones(num_species, num_nodes)
site_hop_constants = Vector{Vector{Float64}}(undef, num_nodes)
for site in 1:num_nodes
    site_hop_constants[site] = ones(outdegree(grid, site))
end
hopping_constants=Pair(species_hop_constants, site_hop_constants)</code></pre><pre><code class="nohighlight hljs">[1.0 1.0 … 1.0 1.0; 1.0 1.0 … 1.0 1.0; 1.0 1.0 … 1.0 1.0] =&gt; [[1.0, 1.0, 1.
0], [1.0, 1.0, 1.0], [1.0, 1.0, 1.0, 1.0], [1.0, 1.0, 1.0, 1.0], [1.0, 1.0,
 1.0], [1.0, 1.0, 1.0], [1.0, 1.0, 1.0, 1.0], [1.0, 1.0, 1.0, 1.0], [1.0, 1
.0, 1.0, 1.0, 1.0], [1.0, 1.0, 1.0, 1.0, 1.0]  …  [1.0, 1.0, 1.0, 1.0, 1.0]
, [1.0, 1.0, 1.0, 1.0, 1.0], [1.0, 1.0, 1.0, 1.0], [1.0, 1.0, 1.0, 1.0], [1
.0, 1.0, 1.0], [1.0, 1.0, 1.0], [1.0, 1.0, 1.0, 1.0], [1.0, 1.0, 1.0, 1.0],
 [1.0, 1.0, 1.0], [1.0, 1.0, 1.0]]</code></pre><p>We can use either of the four versions of <code>hopping_constants</code> to construct a <code>JumpProblem</code> with the same syntax as in the original example. The different forms of hopping rates are supported not only for convenience but also for better memory usage and performance. So it is recommended that the most specialized form of hopping rates is used.</p><h3 id="Solvers"><a class="docs-heading-anchor" href="#Solvers">Solvers</a><a id="Solvers-1"></a><a class="docs-heading-anchor-permalink" href="#Solvers" title="Permalink"></a></h3><p>There are currently two specialized &quot;spatial&quot; solvers: <code>NSM</code> and <code>DirectCRDirect</code>. The former stands for Next Subvolume Method <sup class="footnote-reference"><a id="citeref-1" href="#footnote-1">[1]</a></sup>. The latter employs Composition-Rejection to sample the next site to fire, similar to the ordinary DirectCR method. For larger networks <code>DirectCRDirect</code> is expected to be faster. Both methods can be used interchangeably.</p><p>Additionally, all standard solvers are supported as well, although they are expected to use more memory and be slower. They &quot;flatten&quot; the problem, i.e. turn all hops into reactions, resulting in a much larger system. For example, to use the Next Reaction Method (<code>NRM</code>), simply pass in <code>NRM()</code> instead of <code>NSM()</code> in the construction of the <code>JumpProblem</code>. Importantly, you <em>must</em> pass in <code>hopping_constants</code> in the <code>D_{s,i,j}</code> or <code>D_{s,i}</code> form to use any of the non-specialized solvers.</p><h2 id="References"><a class="docs-heading-anchor" href="#References">References</a><a id="References-1"></a><a class="docs-heading-anchor-permalink" href="#References" title="Permalink"></a></h2><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-1"><a class="tag is-link" href="#citeref-1">1</a>Elf, Johan and Ehrenberg, Mäns. “Spontaneous separation of bi-stable biochemical systems into spatial domains of opposite phases”. In: <em>Systems biology</em> 1.2 (2004), pp. 230–236.</li></ul></section></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../exercises/02-workshop_solutions/">« SciML Workshop Exercise Solutions</a><a class="docs-footer-nextpage" href="../../model_inference/01-pendulum_bayesian_inference/">Bayesian Inference on a Pendulum using DiffEqBayes.jl »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.22 on <span class="colophon-date" title="Saturday 13 August 2022 04:49">Saturday 13 August 2022</span>. Using Julia version 1.7.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
