var documenterSearchIndex = {"docs":
[{"location":"type_handling/03-unitful/#Unit-Checked-Arithmetic-via-Unitful.jl","page":"Unit Checked Arithmetic via Unitful.jl","title":"Unit Checked Arithmetic via Unitful.jl","text":"","category":"section"},{"location":"type_handling/03-unitful/","page":"Unit Checked Arithmetic via Unitful.jl","title":"Unit Checked Arithmetic via Unitful.jl","text":"Units and dimensional analysis are standard tools across the sciences for checking the correctness of your equation. However, most ODE solvers only allow for the equation to be in dimensionless form, leaving it up to the user to both convert the equation to a dimensionless form, punch in the equations, and hopefully not make an error along the way.","category":"page"},{"location":"type_handling/03-unitful/","page":"Unit Checked Arithmetic via Unitful.jl","title":"Unit Checked Arithmetic via Unitful.jl","text":"DifferentialEquations.jl allows for one to use Unitful.jl to have unit-checked arithmetic natively in the solvers. Given the dispatch implementation of the Unitful, this has little overhead.","category":"page"},{"location":"type_handling/03-unitful/#Using-Unitful","page":"Unit Checked Arithmetic via Unitful.jl","title":"Using Unitful","text":"","category":"section"},{"location":"type_handling/03-unitful/","page":"Unit Checked Arithmetic via Unitful.jl","title":"Unit Checked Arithmetic via Unitful.jl","text":"To use Unitful, you need to have the package installed. Then you can add units to your variables. For example:","category":"page"},{"location":"type_handling/03-unitful/","page":"Unit Checked Arithmetic via Unitful.jl","title":"Unit Checked Arithmetic via Unitful.jl","text":"using Unitful\nt = 1.0u\"s\"","category":"page"},{"location":"type_handling/03-unitful/","page":"Unit Checked Arithmetic via Unitful.jl","title":"Unit Checked Arithmetic via Unitful.jl","text":"1.0 s","category":"page"},{"location":"type_handling/03-unitful/","page":"Unit Checked Arithmetic via Unitful.jl","title":"Unit Checked Arithmetic via Unitful.jl","text":"Notice that t is a variable with units in seconds. If we make another value with seconds, they can add","category":"page"},{"location":"type_handling/03-unitful/","page":"Unit Checked Arithmetic via Unitful.jl","title":"Unit Checked Arithmetic via Unitful.jl","text":"t2 = 1.02u\"s\"\nt+t2","category":"page"},{"location":"type_handling/03-unitful/","page":"Unit Checked Arithmetic via Unitful.jl","title":"Unit Checked Arithmetic via Unitful.jl","text":"2.02 s","category":"page"},{"location":"type_handling/03-unitful/","page":"Unit Checked Arithmetic via Unitful.jl","title":"Unit Checked Arithmetic via Unitful.jl","text":"and they can multiply:","category":"page"},{"location":"type_handling/03-unitful/","page":"Unit Checked Arithmetic via Unitful.jl","title":"Unit Checked Arithmetic via Unitful.jl","text":"t*t2","category":"page"},{"location":"type_handling/03-unitful/","page":"Unit Checked Arithmetic via Unitful.jl","title":"Unit Checked Arithmetic via Unitful.jl","text":"1.02 s^2","category":"page"},{"location":"type_handling/03-unitful/","page":"Unit Checked Arithmetic via Unitful.jl","title":"Unit Checked Arithmetic via Unitful.jl","text":"You can even do rational roots:","category":"page"},{"location":"type_handling/03-unitful/","page":"Unit Checked Arithmetic via Unitful.jl","title":"Unit Checked Arithmetic via Unitful.jl","text":"sqrt(t)","category":"page"},{"location":"type_handling/03-unitful/","page":"Unit Checked Arithmetic via Unitful.jl","title":"Unit Checked Arithmetic via Unitful.jl","text":"1.0 s^1/2","category":"page"},{"location":"type_handling/03-unitful/","page":"Unit Checked Arithmetic via Unitful.jl","title":"Unit Checked Arithmetic via Unitful.jl","text":"Many operations work. These operations will check to make sure units are correct, and will throw an error for incorrect operations:","category":"page"},{"location":"type_handling/03-unitful/","page":"Unit Checked Arithmetic via Unitful.jl","title":"Unit Checked Arithmetic via Unitful.jl","text":"t + sqrt(t)","category":"page"},{"location":"type_handling/03-unitful/","page":"Unit Checked Arithmetic via Unitful.jl","title":"Unit Checked Arithmetic via Unitful.jl","text":"Error: DimensionError: 1.0 s and 1.0 s^1/2 are not dimensionally compatible.","category":"page"},{"location":"type_handling/03-unitful/#Using-Unitful-with-DifferentialEquations.jl","page":"Unit Checked Arithmetic via Unitful.jl","title":"Using Unitful with DifferentialEquations.jl","text":"","category":"section"},{"location":"type_handling/03-unitful/","page":"Unit Checked Arithmetic via Unitful.jl","title":"Unit Checked Arithmetic via Unitful.jl","text":"Just like with other number systems, you can choose the units for your numbers by simply specifying the units of the initial condition and the timestep. For example, to solve the linear ODE where the variable has units of Newton's and t is in Seconds, we would use:","category":"page"},{"location":"type_handling/03-unitful/","page":"Unit Checked Arithmetic via Unitful.jl","title":"Unit Checked Arithmetic via Unitful.jl","text":"using DifferentialEquations\nf = (y,p,t) -> 0.5*y\nu0 = 1.5u\"N\"\nprob = ODEProblem(f,u0,(0.0u\"s\",1.0u\"s\"))\nsol = solve(prob,Tsit5())","category":"page"},{"location":"type_handling/03-unitful/","page":"Unit Checked Arithmetic via Unitful.jl","title":"Unit Checked Arithmetic via Unitful.jl","text":"Error: DimensionError: N s^-1 and 0.75 N are not dimensionally compatible.","category":"page"},{"location":"type_handling/03-unitful/","page":"Unit Checked Arithmetic via Unitful.jl","title":"Unit Checked Arithmetic via Unitful.jl","text":"Notice that we recieved a unit mismatch error. This is correctly so! Remember that for an ODE:","category":"page"},{"location":"type_handling/03-unitful/","page":"Unit Checked Arithmetic via Unitful.jl","title":"Unit Checked Arithmetic via Unitful.jl","text":"fracdydt = f(ty)","category":"page"},{"location":"type_handling/03-unitful/","page":"Unit Checked Arithmetic via Unitful.jl","title":"Unit Checked Arithmetic via Unitful.jl","text":"we must have that f is a rate, i.e. f is a change in y per unit time. So we need to fix the units of f in our example to be N/s. Notice that we then do not receive an error if we do the following:","category":"page"},{"location":"type_handling/03-unitful/","page":"Unit Checked Arithmetic via Unitful.jl","title":"Unit Checked Arithmetic via Unitful.jl","text":"f = (y,p,t) -> 0.5*y/3.0u\"s\"\nprob = ODEProblem(f,u0,(0.0u\"s\",1.0u\"s\"))\nsol = solve(prob,Tsit5())","category":"page"},{"location":"type_handling/03-unitful/","page":"Unit Checked Arithmetic via Unitful.jl","title":"Unit Checked Arithmetic via Unitful.jl","text":"retcode: Success\nInterpolation: specialized 4th order \"free\" interpolation\nt: 3-element Array{Unitful.Quantity{Float64,𝐓,Unitful.FreeUnits{(s,),𝐓,nothing}},1}:\n                 0.0 s\n 0.14311598261241779 s\n                 1.0 s\nu: 3-element Array{Unitful.Quantity{Float64,𝐋 𝐌 𝐓^-2,Unitful.FreeUnits{(N,),𝐋 𝐌 𝐓^-2,nothing}},1}:\n                1.5 N\n 1.5362091208988309 N\n 1.7720406194871123 N","category":"page"},{"location":"type_handling/03-unitful/","page":"Unit Checked Arithmetic via Unitful.jl","title":"Unit Checked Arithmetic via Unitful.jl","text":"This gives a a normal solution object. Notice that the values are all with the correct units:","category":"page"},{"location":"type_handling/03-unitful/","page":"Unit Checked Arithmetic via Unitful.jl","title":"Unit Checked Arithmetic via Unitful.jl","text":"print(sol[:])","category":"page"},{"location":"type_handling/03-unitful/","page":"Unit Checked Arithmetic via Unitful.jl","title":"Unit Checked Arithmetic via Unitful.jl","text":"Unitful.Quantity{Float64,𝐋 𝐌 𝐓^-2,Unitful.FreeUnits{(N,),𝐋 𝐌 𝐓^-2,nothing}}[1.5 N, 1.5362091208988309 N, 1.7720406194871123 N]","category":"page"},{"location":"type_handling/03-unitful/","page":"Unit Checked Arithmetic via Unitful.jl","title":"Unit Checked Arithmetic via Unitful.jl","text":"We can plot the solution by removing the units:","category":"page"},{"location":"type_handling/03-unitful/","page":"Unit Checked Arithmetic via Unitful.jl","title":"Unit Checked Arithmetic via Unitful.jl","text":"using Plots\ngr()\nplot(ustrip(sol.t),ustrip(sol[:]),lw=3)","category":"page"},{"location":"type_handling/03-unitful/","page":"Unit Checked Arithmetic via Unitful.jl","title":"Unit Checked Arithmetic via Unitful.jl","text":"(Image: )","category":"page"},{"location":"type_handling/03-unitful/#Appendix","page":"Unit Checked Arithmetic via Unitful.jl","title":"Appendix","text":"","category":"section"},{"location":"type_handling/03-unitful/","page":"Unit Checked Arithmetic via Unitful.jl","title":"Unit Checked Arithmetic via Unitful.jl","text":"This tutorial is part of the SciMLTutorials.jl repository, found at: https://github.com/SciML/SciMLTutorials.jl.  For more information on doing scientific machine learning (SciML) with open source software, check out https://sciml.ai/.","category":"page"},{"location":"type_handling/03-unitful/","page":"Unit Checked Arithmetic via Unitful.jl","title":"Unit Checked Arithmetic via Unitful.jl","text":"To locally run this tutorial, do the following commands:","category":"page"},{"location":"type_handling/03-unitful/","page":"Unit Checked Arithmetic via Unitful.jl","title":"Unit Checked Arithmetic via Unitful.jl","text":"using SciMLTutorials\nSciMLTutorials.weave_file(\"type_handling\",\"03-unitful.jmd\")","category":"page"},{"location":"type_handling/03-unitful/","page":"Unit Checked Arithmetic via Unitful.jl","title":"Unit Checked Arithmetic via Unitful.jl","text":"Computer Information:","category":"page"},{"location":"type_handling/03-unitful/","page":"Unit Checked Arithmetic via Unitful.jl","title":"Unit Checked Arithmetic via Unitful.jl","text":"Julia Version 1.4.2\nCommit 44fa15b150* (2020-05-23 18:35 UTC)\nPlatform Info:\n  OS: Linux (x86_64-pc-linux-gnu)\n  CPU: Intel(R) Core(TM) i7-9700K CPU @ 3.60GHz\n  WORD_SIZE: 64\n  LIBM: libopenlibm\n  LLVM: libLLVM-8.0.1 (ORCJIT, skylake)\nEnvironment:\n  JULIA_LOAD_PATH = /builds/JuliaGPU/DiffEqTutorials.jl:\n  JULIA_DEPOT_PATH = /builds/JuliaGPU/DiffEqTutorials.jl/.julia\n  JULIA_CUDA_MEMORY_LIMIT = 2147483648\n  JULIA_NUM_THREADS = 8\n","category":"page"},{"location":"type_handling/03-unitful/","page":"Unit Checked Arithmetic via Unitful.jl","title":"Unit Checked Arithmetic via Unitful.jl","text":"Package Information:","category":"page"},{"location":"type_handling/03-unitful/","page":"Unit Checked Arithmetic via Unitful.jl","title":"Unit Checked Arithmetic via Unitful.jl","text":"Status `/builds/JuliaGPU/DiffEqTutorials.jl/tutorials/type_handling/Project.toml`\n[7e558dbc-694d-5a72-987c-6f4ebed21442] ArbNumerics 1.2.1\n[55939f99-70c6-5e9b-8bb0-5071ed7d61fd] DecFP 1.0.0\n[abce61dc-4473-55a0-ba07-351d65e31d42] Decimals 0.4.1\n[0c46a032-eb83-5123-abaf-570d42b7fbaa] DifferentialEquations 6.15.0\n[497a8b3b-efae-58df-a0af-a86822472b78] DoubleFloats 1.1.13\n[eff96d63-e80a-5855-80a2-b1b0885c5ab7] Measurements 2.3.0\n[1dea7af3-3e70-54e6-95c3-0bf5283fa5ed] OrdinaryDiffEq 5.43.0\n[91a5bcdd-55d7-5caf-9e0b-520d859cae80] Plots 1.6.12\n[1986cc42-f94f-5a68-af5c-568840ba703d] Unitful 1.5.0","category":"page"},{"location":"exercises/01-workshop_exercises/#SciML-Workshop-Exercises","page":"SciML Workshop Exercises","title":"SciML Workshop Exercises","text":"","category":"section"},{"location":"exercises/01-workshop_exercises/","page":"SciML Workshop Exercises","title":"SciML Workshop Exercises","text":"These exercises teach common workflows which involve SciML's tools like DifferentialEquations.jl, DiffEqFlux.jl, and the connections to parts like stochastic differential equations and Bayesian estimation. The designation (B) is for \"Beginner\", meaning that a user new to the package should feel comfortable trying this exercise. An exercise designated (I) is for \"Intermediate\", meaning the user may want to have some previous background in DifferentialEquations.jl or try some (B) exercises first. The additional (E) designation is for \"Experienced\", which are portions of exercises which may take some work.","category":"page"},{"location":"exercises/01-workshop_exercises/","page":"SciML Workshop Exercises","title":"SciML Workshop Exercises","text":"The exercises are described as follows:","category":"page"},{"location":"exercises/01-workshop_exercises/","page":"SciML Workshop Exercises","title":"SciML Workshop Exercises","text":"Exercise 1 takes the user through solving a stiff ordinary differential equation and using the ModelingToolkit.jl to automatically convert the function to a symbolic form to derive the analytical Jacobian to speed up the solver. The same biological system is then solved with stochasticity, utilizing EnsembleProblems to understand 95% bounds on the solution. Finally, probabilistic programming is employed to perform Bayesian parameter estimation of the parameters against data.\nExercise 2 takes the user through defining hybrid delay differential equation, that is a differential equation with events, and using differentiable programming techniques (automatic differentiation) to to perform gradient-based parameter estimation.\nExercise 3 takes the user through differential-algebraic equation (DAE) modeling, the concept of index, and using both mass-matrix and implicit ODE representations. This will require doing a bit of math, but the student will understand how to change their equations to make their DAE numerically easier for the integrators.\nExercise 4 takes the user through optimizing a PDE solver, utilizing automatic sparsity pattern recognition, automatic conversion of numerical codes to symbolic codes for analytical construction of the Jacobian, preconditioned GMRES, and setting up a solver for IMEX and GPUs, and compute adjoints of PDEs.\nExercise 5 focuses on a chaotic orbit, utilizing parallel ensembles across supercomputers and GPUs to quickly describe phase space.\nExercise 6 takes the user through training a neural stochastic differential equation, using GPU-accleration and adjoints through Flux.jl's neural network framework to build efficient training codes.","category":"page"},{"location":"exercises/01-workshop_exercises/","page":"SciML Workshop Exercises","title":"SciML Workshop Exercises","text":"This exercise worksheet is meant to be a living document leading new users through a deep dive of the DifferentialEquations.jl feature set. If you further suggestions or want to contribute new problems, please open an issue or PR at the SciMLTutorials.jl repository.","category":"page"},{"location":"exercises/01-workshop_exercises/#Problem-1:-Investigating-Sources-of-Randomness-and-Uncertainty-in-a-Stiff-Biological-System-(B)","page":"SciML Workshop Exercises","title":"Problem 1: Investigating Sources of Randomness and Uncertainty in a Stiff Biological System (B)","text":"","category":"section"},{"location":"exercises/01-workshop_exercises/","page":"SciML Workshop Exercises","title":"SciML Workshop Exercises","text":"In this problem we will walk through the basics of simulating models with DifferentialEquations.jl. Let's take the Oregonator model of the Belousov-Zhabotinskii chemical reaction system. This system describes a classical example in non-equilibrium thermodynmics and is a well-known natural chemical oscillator.","category":"page"},{"location":"exercises/01-workshop_exercises/#Part-1:-Simulating-the-Oregonator-ODE-model","page":"SciML Workshop Exercises","title":"Part 1: Simulating the Oregonator ODE model","text":"","category":"section"},{"location":"exercises/01-workshop_exercises/","page":"SciML Workshop Exercises","title":"SciML Workshop Exercises","text":"When modeling, usually one starts off by investigating the deterministic model. The deterministic ODE formulation of the Oregonator is given by the equations","category":"page"},{"location":"exercises/01-workshop_exercises/","page":"SciML Workshop Exercises","title":"SciML Workshop Exercises","text":"beginalign\nfracdxdt = s(y-xy + x - qx^2)\nfracdydt = (-y - xy + z)s\nfracdzdt = w(x - z)endalign","category":"page"},{"location":"exercises/01-workshop_exercises/","page":"SciML Workshop Exercises","title":"SciML Workshop Exercises","text":"with parameter values s=7727, w=0161, and q=8375 times 10^-6, and initial conditions x(0)=1, y(0)=2, and z(0)=3. Use the tutorial on solving ODEs to solve this differential equation on the timespan of tin0360 with the default ODE solver. To investigate the result, plot the solution of all components over time, and plot the phase space plot of the solution (hint: use vars=(1,2,3)). What shape is being drawn in phase space?","category":"page"},{"location":"exercises/01-workshop_exercises/#Part-2:-Investigating-Stiffness","page":"SciML Workshop Exercises","title":"Part 2: Investigating Stiffness","text":"","category":"section"},{"location":"exercises/01-workshop_exercises/","page":"SciML Workshop Exercises","title":"SciML Workshop Exercises","text":"Because the reaction rates of q vs s is very large, this model has a \"fast\" system and a \"slow\" system. This is typical of ODEs which exhibit a property known as stiffness. Stiffness changes the ODE solvers which can handle the equation well. Take a look at the ODE solver page and investigate solving the equation using methods for non-stiff equations (ex: Tsit5) and stiff equations (ex: Rodas5).","category":"page"},{"location":"exercises/01-workshop_exercises/","page":"SciML Workshop Exercises","title":"SciML Workshop Exercises","text":"Benchmark using tin050 using @btime from BenchmarkTools.jl. What happens when you increase the timespan?","category":"page"},{"location":"exercises/01-workshop_exercises/#(Optional)-Part-3:-Specifying-Analytical-Jacobians-(I)","page":"SciML Workshop Exercises","title":"(Optional) Part 3: Specifying Analytical Jacobians (I)","text":"","category":"section"},{"location":"exercises/01-workshop_exercises/","page":"SciML Workshop Exercises","title":"SciML Workshop Exercises","text":"Stiff ODE solvers internally utilize the Jacobian of the ODE system in order to improve the stepsizes in the solution. However, computing and factorizing the Jacobian is costly, and thus it can be beneficial to provide the analytical solution.","category":"page"},{"location":"exercises/01-workshop_exercises/","page":"SciML Workshop Exercises","title":"SciML Workshop Exercises","text":"Use the ODEFunction definition page to define an ODEFunction which holds both the OREGO ODE and its Jacobian, and solve using Rodas5.","category":"page"},{"location":"exercises/01-workshop_exercises/#(Optional)-Part-4:-Automatic-Symbolicification-and-Analytical-Jacobian-Calculations","page":"SciML Workshop Exercises","title":"(Optional) Part 4: Automatic Symbolicification and Analytical Jacobian Calculations","text":"","category":"section"},{"location":"exercises/01-workshop_exercises/","page":"SciML Workshop Exercises","title":"SciML Workshop Exercises","text":"Deriving Jacobians by hand is tedious. Thankfully symbolic mathematical systems can do the work for you. And thankfully, DifferentialEquations.jl has tools to automatically convert numerical problems into symbolic problems to perform the analysis on!","category":"page"},{"location":"exercises/01-workshop_exercises/","page":"SciML Workshop Exercises","title":"SciML Workshop Exercises","text":"follow the ModelingToolkit.jl README to automatically convert your ODE definition to its symbolic form using modelingtoolkitize and calculate the analytical Jacobian. Use the compilation functions to build the ODEFunction with the embedded analytical solution.","category":"page"},{"location":"exercises/01-workshop_exercises/#Part-5:-Adding-stochasticity-with-stochastic-differential-equations","page":"SciML Workshop Exercises","title":"Part 5: Adding stochasticity with stochastic differential equations","text":"","category":"section"},{"location":"exercises/01-workshop_exercises/","page":"SciML Workshop Exercises","title":"SciML Workshop Exercises","text":"How does this system react in the presense of stochasticity? We can investigate this question by using stochastic differential equations. A stochastic differential equation formulation of this model is known as the multiplicative noise model, is created with:","category":"page"},{"location":"exercises/01-workshop_exercises/","page":"SciML Workshop Exercises","title":"SciML Workshop Exercises","text":"beginalign\ndx = s(y-xy + x - qx^2)dt + sigma_1 x dW_1\ndy = frac-y - xy + zsdt + sigma_2 y dW_2\ndz = w(x - z)dt + sigma_3 z dW_3endalign","category":"page"},{"location":"exercises/01-workshop_exercises/","page":"SciML Workshop Exercises","title":"SciML Workshop Exercises","text":"with sigma_i = 01 where the dW terms describe a Brownian motion, a continuous random process with normally distributed increments. Use the tutorial on solving SDEs to solve simulate this model. Then, use the EnsembleProblem to generate and plot 100 trajectories of the stochastic model, and use EnsembleSummary to plot the mean and 5%-95% region over time.","category":"page"},{"location":"exercises/01-workshop_exercises/","page":"SciML Workshop Exercises","title":"SciML Workshop Exercises","text":"Try solving with the ImplicitRKMil and SOSRI methods. Notice that it isn't stiff every single time!","category":"page"},{"location":"exercises/01-workshop_exercises/","page":"SciML Workshop Exercises","title":"SciML Workshop Exercises","text":"(For fun, see if you can make the Euler-Maruyama EM() method solve this equation. This requires a choice of dt small enough to be stable. This is the \"standard\" method!)","category":"page"},{"location":"exercises/01-workshop_exercises/#Part-6:-Gillespie-jump-models-of-discrete-stochasticity","page":"SciML Workshop Exercises","title":"Part 6: Gillespie jump models of discrete stochasticity","text":"","category":"section"},{"location":"exercises/01-workshop_exercises/","page":"SciML Workshop Exercises","title":"SciML Workshop Exercises","text":"When biological models have very few particles, continuous models no longer make sense, and instead using the full discrete formulation can be required to accuracy describe the dynamics. A discrete differential equation, or Gillespie model, is a continuous-time Markov chain with Poisson-distributed jumps. A discrete description of the Oregonator model is given by a chemical reaction systems:","category":"page"},{"location":"exercises/01-workshop_exercises/","page":"SciML Workshop Exercises","title":"SciML Workshop Exercises","text":"\nA+Y -> X+P\nX+Y -> 2P\nA+X -> 2X + 2Z\n2X  -> A + P (note: this has rate kX^2!)\nB + Z -> Y","category":"page"},{"location":"exercises/01-workshop_exercises/","page":"SciML Workshop Exercises","title":"SciML Workshop Exercises","text":"where reactions take place at a rate which is propoertional to its components, i.e. the first reaction has a rate k*A*Y for some k. Use the tutorial on Gillespie SSA models to implement the JumpProblem for this model, and use the EnsembleProblem and EnsembleSummary to characterize the stochastic trajectories.","category":"page"},{"location":"exercises/01-workshop_exercises/","page":"SciML Workshop Exercises","title":"SciML Workshop Exercises","text":"For what rate constants does the model give the oscillatory dynamics for the ODE approximation? For information on the true reaction rates, consult the original paper.","category":"page"},{"location":"exercises/01-workshop_exercises/#Part-7:-Probabilistic-Programming-/-Bayesian-Parameter-Estimation-with-DiffEqBayes.jl-Turing.jl-(I)","page":"SciML Workshop Exercises","title":"Part 7: Probabilistic Programming / Bayesian Parameter Estimation with DiffEqBayes.jl + Turing.jl (I)","text":"","category":"section"},{"location":"exercises/01-workshop_exercises/","page":"SciML Workshop Exercises","title":"SciML Workshop Exercises","text":"In many casees, one comes to understand the proper values for their model's parameters by utilizing data fitting techniques. In this case, we will use the DiffEqBayes.jl library to perform a Bayesian estimation of the parameters. For our data we will the following potential output:","category":"page"},{"location":"exercises/01-workshop_exercises/","page":"SciML Workshop Exercises","title":"SciML Workshop Exercises","text":"\nt = 0.0:1.0:30.0\ndata = [1.0 2.05224 2.11422 2.1857 2.26827 2.3641 2.47618 2.60869 2.7677 2.96232 3.20711 3.52709 3.97005 4.64319 5.86202 9.29322 536.068 82388.9 57868.4 1.00399 1.00169 1.00117 1.00094 1.00082 1.00075 1.0007 1.00068 1.00066 1.00065 1.00065 1.00065\n        2.0 1.9494 1.89645 1.84227 1.78727 1.73178 1.67601 1.62008 1.56402 1.50772 1.45094 1.39322 1.33366 1.2705 1.19958 1.10651 0.57194 0.180316 0.431409 251.774 591.754 857.464 1062.78 1219.05 1335.56 1419.88 1478.22 1515.63 1536.25 1543.45 1539.98\n        3.0 2.82065 2.68703 2.58974 2.52405 2.48644 2.47449 2.48686 2.52337 2.58526 2.67563 2.80053 2.9713 3.21051 3.5712 4.23706 12.0266 14868.8 24987.8 23453.4 19202.2 15721.6 12872.0 10538.8 8628.66 7064.73 5784.29 4735.96 3877.66 3174.94 2599.6]","category":"page"},{"location":"exercises/01-workshop_exercises/","page":"SciML Workshop Exercises","title":"SciML Workshop Exercises","text":"Follow the exmaples on the parameter estimation page to perform a Bayesian parameter estimation. What are the most likely parameters for the model given the posterior parameter distributions?","category":"page"},{"location":"exercises/01-workshop_exercises/","page":"SciML Workshop Exercises","title":"SciML Workshop Exercises","text":"Use the ODEProblem to perform the fit. If you have time, use the EnsembleProblem of SDEProblems to perform a fit over averages of the SDE solutions. Note that the SDE fit will take significantly more computational resources! See the GPU parallelism section for details on how to accelerate this.","category":"page"},{"location":"exercises/01-workshop_exercises/#(Optional)-Part-8:-Using-DiffEqBiological's-Reaction-Network-DSL","page":"SciML Workshop Exercises","title":"(Optional) Part 8: Using DiffEqBiological's Reaction Network DSL","text":"","category":"section"},{"location":"exercises/01-workshop_exercises/","page":"SciML Workshop Exercises","title":"SciML Workshop Exercises","text":"DiffEqBiological.jl is a helper library for the DifferentialEquations.jl ecosystem for defining chemical reaction systems at a high leevel for easy simulation in these various forms. Use the descrption from the Chemical Reaction Networks documentation page to build a reaction network and generate the ODE/SDE/jump equations, and compare the result to your handcoded versions.","category":"page"},{"location":"exercises/01-workshop_exercises/#Problem-2:-Fitting-Hybrid-Delay-Pharmacokinetic-Models-with-Automated-Responses-(B)","page":"SciML Workshop Exercises","title":"Problem 2: Fitting Hybrid Delay Pharmacokinetic Models with Automated Responses (B)","text":"","category":"section"},{"location":"exercises/01-workshop_exercises/","page":"SciML Workshop Exercises","title":"SciML Workshop Exercises","text":"Hybrid differential equations are differential equations with events, where events are some interaction that occurs according to a prespecified condition. For example, the bouncing ball is a classic hybrid differential equation given by an ODE (Newton's Law of Gravity) mixed with the fact that, whenever the ball hits the floor (x=0), then the velocity of the ball flips (v=-v).","category":"page"},{"location":"exercises/01-workshop_exercises/","page":"SciML Workshop Exercises","title":"SciML Workshop Exercises","text":"In addition, many models incorporate delays, that is the driving force of the equation is dependent not on the current values, but values from the past. These delay differential equations model how individuals in the economy act on old information, or that biological processes take time to adapt to a new environment.","category":"page"},{"location":"exercises/01-workshop_exercises/","page":"SciML Workshop Exercises","title":"SciML Workshop Exercises","text":"In this equation we will build a hybrid delayed pharmacokinetic model and use the parameter estimation techniques to fit this it to a data.","category":"page"},{"location":"exercises/01-workshop_exercises/#Part-1:-Defining-an-ODE-with-Predetermined-Doses","page":"SciML Workshop Exercises","title":"Part 1: Defining an ODE with Predetermined Doses","text":"","category":"section"},{"location":"exercises/01-workshop_exercises/","page":"SciML Workshop Exercises","title":"SciML Workshop Exercises","text":"First, let's define the simplest hybrid ordinary differential equation: an ODE where the events take place at fixed times. The ODE we will use is known as the one-compartment model:","category":"page"},{"location":"exercises/01-workshop_exercises/","page":"SciML Workshop Exercises","title":"SciML Workshop Exercises","text":"beginalign\nfracdDepotdt = -K_a Depot + R\nfracdCentraldt = K_a Depot - K_e Centralendalign","category":"page"},{"location":"exercises/01-workshop_exercises/","page":"SciML Workshop Exercises","title":"SciML Workshop Exercises","text":"with t in 090, u_0 = 10000, and p=K_aK_e=2268007398.","category":"page"},{"location":"exercises/01-workshop_exercises/","page":"SciML Workshop Exercises","title":"SciML Workshop Exercises","text":"With this model, use the event handling documentation page to define a DiscreteCallback which fires at t ∈ [24,48,72] and adds a dose of 100 into [Depot]. (Hint: you'll want to set tstops=[24,48,72] to force the ODE solver to step at these times).","category":"page"},{"location":"exercises/01-workshop_exercises/#Part-2:-Adding-Delays","page":"SciML Workshop Exercises","title":"Part 2: Adding Delays","text":"","category":"section"},{"location":"exercises/01-workshop_exercises/","page":"SciML Workshop Exercises","title":"SciML Workshop Exercises","text":"Now let's assume that instead of there being one compartment, there are many transit compartment that the drug must move through in order to reach the central compartment. This effectively delays the effect of the transition from [Depot] to [Central]. To model this effect, we will use the delay differential equation which utilizes a fixed time delay tau:","category":"page"},{"location":"exercises/01-workshop_exercises/","page":"SciML Workshop Exercises","title":"SciML Workshop Exercises","text":"beginalign\nfracdDepotdt = -K_a Depot(t)\nfracdCentraldt = K_a Depot(t-tau) - K_e Centralendalign","category":"page"},{"location":"exercises/01-workshop_exercises/","page":"SciML Workshop Exercises","title":"SciML Workshop Exercises","text":"where the parameter τ = 60. Use the DDE tutorial to define and solve this delayed version of the hybrid model.","category":"page"},{"location":"exercises/01-workshop_exercises/#Part-3:-Automatic-Differentiation-(AD)-for-Optimization-(I)","page":"SciML Workshop Exercises","title":"Part 3: Automatic Differentiation (AD) for Optimization (I)","text":"","category":"section"},{"location":"exercises/01-workshop_exercises/","page":"SciML Workshop Exercises","title":"SciML Workshop Exercises","text":"In order to fit parameters (K_aK_etau) we will want to be able to calculate the gradient of the solution with respect to the initial conditions. One way to do this is via Automatic Differentition (AD). For small numbers of parameters (<100), it is fastest to use Forward-Mode Automatic Differentition (even faster than using adjoint sensitivity analysis!). Thus for this problem we will make use of ForwardDiff.jl to use Dual number arithmetic to retrive both the solution and its derivative w.r.t. parameters in a single solve.","category":"page"},{"location":"exercises/01-workshop_exercises/","page":"SciML Workshop Exercises","title":"SciML Workshop Exercises","text":"Use the information from the page on local sensitvity analysis to define the input dual numbers, solve the equation, and plot both the solution over time and the derivative of the solution w.r.t. the parameters.","category":"page"},{"location":"exercises/01-workshop_exercises/#Part-4:-Fitting-Known-Quantities-with-DiffEqParamEstim.jl-Optim.jl","page":"SciML Workshop Exercises","title":"Part 4: Fitting Known Quantities with DiffEqParamEstim.jl + Optim.jl","text":"","category":"section"},{"location":"exercises/01-workshop_exercises/","page":"SciML Workshop Exercises","title":"SciML Workshop Exercises","text":"Now let's fit the delayed model to a dataset. For the data, use the array","category":"page"},{"location":"exercises/01-workshop_exercises/","page":"SciML Workshop Exercises","title":"SciML Workshop Exercises","text":"\nt = 0.0:12.0:90.0\ndata = [100.0 0.246196 0.000597933 0.24547 0.000596251 0.245275 0.000595453 0.245511\n        0.0 53.7939 16.8784 58.7789 18.3777 59.1879 18.5003 59.2611]","category":"page"},{"location":"exercises/01-workshop_exercises/","page":"SciML Workshop Exercises","title":"SciML Workshop Exercises","text":"Use the parameter estimation page to define a loss function with build_loss_objective and optimize the parameters against the data. What parameters were used to generate the data?","category":"page"},{"location":"exercises/01-workshop_exercises/#Part-5:-Implementing-Control-Based-Logic-with-ContinuousCallbacks-(I)","page":"SciML Workshop Exercises","title":"Part 5: Implementing Control-Based Logic with ContinuousCallbacks (I)","text":"","category":"section"},{"location":"exercises/01-workshop_exercises/","page":"SciML Workshop Exercises","title":"SciML Workshop Exercises","text":"Now that we have fit our delay differential equation model to the dataset, we want to start testing out automated treatment strategies. Let's assume that instead of giving doses at fixed time points, we invent a wearable which monitors the patient and administers a dose whenever the internal drug concentration falls below 25. To model this effect, we will need to use ContinuousCallbacks to define a callback that triggers when [Central] falls below the threshold value.","category":"page"},{"location":"exercises/01-workshop_exercises/","page":"SciML Workshop Exercises","title":"SciML Workshop Exercises","text":"Use the documentation on the event handling page to define such a callback, and plot the solution over time. How many times does the auto-doser administer a dose? How much does this change as you change the delay time tau?","category":"page"},{"location":"exercises/01-workshop_exercises/#Part-6:-Global-Sensitivity-Analysis-with-the-Morris-and-Sobol-Methods","page":"SciML Workshop Exercises","title":"Part 6: Global Sensitivity Analysis with the Morris and Sobol Methods","text":"","category":"section"},{"location":"exercises/01-workshop_exercises/","page":"SciML Workshop Exercises","title":"SciML Workshop Exercises","text":"To understand how the parameters effect the solution in a global sense, one wants to use Global Sensitivity Analysis. Use the GSA documentation page perform global sensitivity analysis and quantify the effect of the various parameters on the solution.","category":"page"},{"location":"exercises/01-workshop_exercises/#Problem-3:-Differential-Algebraic-Equation-Modeling-of-a-Double-Pendulum-(B)","page":"SciML Workshop Exercises","title":"Problem 3: Differential-Algebraic Equation Modeling of a Double Pendulum (B)","text":"","category":"section"},{"location":"exercises/01-workshop_exercises/","page":"SciML Workshop Exercises","title":"SciML Workshop Exercises","text":"Differential-Algebraic Equaton (DAE) systems are like ODEs but allow for adding constraints into the models. This problem will look at solving the double penulum problem with enforcement of the rigid body constraints, requiring that the total distance L is constant throughout the simulation. While these equations can be rewritten in an ODE form, in many cases it can be simpler to solve the equation directly with the constraints. This tutorial will cover both the idea of index, how to manually perform index reduction, and how to make use of mass matrix and implicit ODE solvers to handle these problems.","category":"page"},{"location":"exercises/01-workshop_exercises/#Part-1:-Simple-Introduction-to-DAEs:-Mass-Matrix-Robertson-Equations","page":"SciML Workshop Exercises","title":"Part 1: Simple Introduction to DAEs: Mass-Matrix Robertson Equations","text":"","category":"section"},{"location":"exercises/01-workshop_exercises/","page":"SciML Workshop Exercises","title":"SciML Workshop Exercises","text":"A mass-matrix ordinary differential equation (ODE) is an ODE where the left-hand side, the derivative side, is multiplied by a matrix known as the mass matrix. This is described as:","category":"page"},{"location":"exercises/01-workshop_exercises/","page":"SciML Workshop Exercises","title":"SciML Workshop Exercises","text":"Mu = f(upt)","category":"page"},{"location":"exercises/01-workshop_exercises/","page":"SciML Workshop Exercises","title":"SciML Workshop Exercises","text":"where M is the mass matrix. When M is invertible, there is an ODE which is equivalent to this formulation. When M is not invertible, this can have a distinctly different behavior and is as Differential-Algebraic Equation (DAE).","category":"page"},{"location":"exercises/01-workshop_exercises/","page":"SciML Workshop Exercises","title":"SciML Workshop Exercises","text":"Solve the Robertson DAE:","category":"page"},{"location":"exercises/01-workshop_exercises/","page":"SciML Workshop Exercises","title":"SciML Workshop Exercises","text":"beginalign\nfracdy_1dt = -004y_1 + 10^4 y_2y_3\nfracdy_2dt =  004y_1 - 10^4 y_2y_3 - 3times 10^7 y_2^2\n1 = y_1 + y_2 + y_3endalign","category":"page"},{"location":"exercises/01-workshop_exercises/","page":"SciML Workshop Exercises","title":"SciML Workshop Exercises","text":"with y(0) = 100 and dy(0) = -00400400 using the mass-matrix formulation and Rodas5(). Use the ODEProblem page to find out how to declare a mass matrix.","category":"page"},{"location":"exercises/01-workshop_exercises/","page":"SciML Workshop Exercises","title":"SciML Workshop Exercises","text":"(Hint: what if the last row has all zeros?)","category":"page"},{"location":"exercises/01-workshop_exercises/#Part-2:-Solving-the-Implicit-Robertson-Equations-with-IDA","page":"SciML Workshop Exercises","title":"Part 2: Solving the Implicit Robertson Equations with IDA","text":"","category":"section"},{"location":"exercises/01-workshop_exercises/","page":"SciML Workshop Exercises","title":"SciML Workshop Exercises","text":"Use the DAE Tutorial to define a DAE in its implicit form and solve the Robertson equation with IDA. Why is differential_vars = [true,true,false]?","category":"page"},{"location":"exercises/01-workshop_exercises/#Part-3:-Manual-Index-Reduction-of-the-Single-Pendulum","page":"SciML Workshop Exercises","title":"Part 3: Manual Index Reduction of the Single Pendulum","text":"","category":"section"},{"location":"exercises/01-workshop_exercises/","page":"SciML Workshop Exercises","title":"SciML Workshop Exercises","text":"The index of a DAE is a notion used to measure distance from its related ODE. There are many different definitions of index, but we're going to stick to the idea of differential index: the number of differentiations required to convert a system of DAEs into explicit ODE form. DAEs of high index are usually transformed via a procedure called index reduction. The following example will demonstrate this.","category":"page"},{"location":"exercises/01-workshop_exercises/","page":"SciML Workshop Exercises","title":"SciML Workshop Exercises","text":"Consider the index 3 DAE system of the cartesian pendulum. After writing down the force equations in both directions, we arrive at the following DAE:","category":"page"},{"location":"exercises/01-workshop_exercises/","page":"SciML Workshop Exercises","title":"SciML Workshop Exercises","text":"\nbeginalign\nmddotx = fracxLT \nmddoty = fracyLT - mg \nx^2 + y^2 = L\nendalign\n\n\nNotice that we dont have an equation describing the\nbehaviour of T Let us now perform index reduction to\nextract an equation for T\n\nDifferentiate this third equation twice with respect to time\nto reduce it from index 3 to index 1\n\n Part 4 Single Pendulum Solution with IDA\nWrite these equations in implicit form and solve the system using\nIDA\n\n Part 5 Solving the Double Penulum DAE System\n\nThe following equations describe a double\npendulum system\n\nbeginalign\nm_2ddotx_2 = fracx_2L_2T_2 \nm_2ddoty_2 = fracy_2L_2T_2 - m_2g \nx_2^2 + y_2^2 = L_2 \nm_1ddotx_1 = fracx_1L_1T_1 - fracx_2L_2T_2 \nm_2ddoty_1 = fracy_1L_1T_2 - m_1g - fracy_2L_2T_2 \nx_1^2 + y_1^2 = L_1 \nendalign\n\n\nPerform index reduction and solve it like in the previous example\n\n Problem 4 Performance Optimizing and Parallelizing Semilinear PDE Solvers (I)\n\nThis problem will focus on implementing and optimizing the solution of the\n2-dimensional Brusselator equations The BRUSS equations are a well-known\nhighly stiff oscillatory system of partial differential equations which are\nused in stiff ODE solver benchmarks In this tutorial we will walk first\nthrough a simple implementation then do allocation-free implementations and\nlooking deep into solver options and benchmarking\n\n Part 1 Implementing the BRUSS PDE System as ODEs\n\nThe Brusselator PDE is defined as follows\n\nbeginalign\nfracpartial upartial t = 1 + u^2v - 44u + alpha(fracpartial^2 upartial x^2 + fracpartial^2 upartial y^2) + f(x y t)\nfracpartial vpartial t = 34u - u^2v + alpha(fracpartial^2 upartial x^2 + fracpartial^2 upartial y^2)endalign","category":"page"},{"location":"exercises/01-workshop_exercises/","page":"SciML Workshop Exercises","title":"SciML Workshop Exercises","text":"where","category":"page"},{"location":"exercises/01-workshop_exercises/","page":"SciML Workshop Exercises","title":"SciML Workshop Exercises","text":"f(x y t) = begincases\n5  quad textif  (x-03)^2+(y-06)^2  01^2 text and  t  11 \n0  quad textelseendcases","category":"page"},{"location":"exercises/01-workshop_exercises/","page":"SciML Workshop Exercises","title":"SciML Workshop Exercises","text":"and the initial conditions are","category":"page"},{"location":"exercises/01-workshop_exercises/","page":"SciML Workshop Exercises","title":"SciML Workshop Exercises","text":"beginalign\nu(x y 0) = 22cdot y(1-y)^32 \nv(x y 0) = 27cdot x(1-x)^32endalign","category":"page"},{"location":"exercises/01-workshop_exercises/","page":"SciML Workshop Exercises","title":"SciML Workshop Exercises","text":"with the periodic boundary condition","category":"page"},{"location":"exercises/01-workshop_exercises/","page":"SciML Workshop Exercises","title":"SciML Workshop Exercises","text":"beginalign\nu(x+1yt) = u(xyt) \nu(xy+1t) = u(xyt)endalign","category":"page"},{"location":"exercises/01-workshop_exercises/","page":"SciML Workshop Exercises","title":"SciML Workshop Exercises","text":"on a timespan of t in 022.","category":"page"},{"location":"exercises/01-workshop_exercises/","page":"SciML Workshop Exercises","title":"SciML Workshop Exercises","text":"To solve this PDE, we will discretize it into a system of ODEs with the finite difference method. We discretize u and v into arrays of the values at each time point: u[i,j] = u(i*dx,j*dy) for some choice of dx/dy, and same for v. Then our ODE is defined with U[i,j,k] = [u v]. The second derivative operator, the Laplacian, discretizes to become a tridiagonal matrix with [1 -2 1] and a 1 in the top right and bottom left corners. The nonlinear functions are then applied at each point in space (they are broadcast). Use dx=dy=1/32.","category":"page"},{"location":"exercises/01-workshop_exercises/","page":"SciML Workshop Exercises","title":"SciML Workshop Exercises","text":"You will know when you have the correct solution when you plot the solution at x=y=0 and see a periodic orbit, e.g., ts=0:0.05:22; plot(ts, sol1.(ts, idxs=1)).","category":"page"},{"location":"exercises/01-workshop_exercises/","page":"SciML Workshop Exercises","title":"SciML Workshop Exercises","text":"If you are not familiar with this process, see the Gierer-Meinhardt example from the SciMLTutorials.","category":"page"},{"location":"exercises/01-workshop_exercises/","page":"SciML Workshop Exercises","title":"SciML Workshop Exercises","text":"Note: Start by doing the simplest implementation!","category":"page"},{"location":"exercises/01-workshop_exercises/#Part-2:-Optimizing-the-BRUSS-Code","page":"SciML Workshop Exercises","title":"Part 2: Optimizing the BRUSS Code","text":"","category":"section"},{"location":"exercises/01-workshop_exercises/","page":"SciML Workshop Exercises","title":"SciML Workshop Exercises","text":"PDEs are expensive to solve, and so we will go nowhere without some code optimizing! Follow the steps described in the the Gierer-Meinhardt example from the SciMLTutorials to optimize your Brusselator code. Try other formulations and see what ends up the fastest! Find a trade-off between performance and simplicity that suits your needs.","category":"page"},{"location":"exercises/01-workshop_exercises/#Part-3:-Exploiting-Jacobian-Sparsity-with-Color-Differentiation","page":"SciML Workshop Exercises","title":"Part 3: Exploiting Jacobian Sparsity with Color Differentiation","text":"","category":"section"},{"location":"exercises/01-workshop_exercises/","page":"SciML Workshop Exercises","title":"SciML Workshop Exercises","text":"Use the sparsity! function from SparseDiffTools to generate the sparsity pattern for the Jacobian of this problem. Follow the documentations on the DiffEqFunction page to specify the sparsity pattern of the Jacobian. Generate an add the color vector to speed up the computation of the Jacobian.","category":"page"},{"location":"exercises/01-workshop_exercises/#(Optional)-Part-4:-Structured-Jacobians","page":"SciML Workshop Exercises","title":"(Optional) Part 4: Structured Jacobians","text":"","category":"section"},{"location":"exercises/01-workshop_exercises/","page":"SciML Workshop Exercises","title":"SciML Workshop Exercises","text":"Specify the sparsity pattern using a BlockBandedMatrix from BlockBandedMatrices.jl to accelerate the previous sparsity handling tricks.","category":"page"},{"location":"exercises/01-workshop_exercises/#(Optional)-Part-5:-Automatic-Symbolicification-and-Analytical-Jacobian","page":"SciML Workshop Exercises","title":"(Optional) Part 5: Automatic Symbolicification and Analytical Jacobian","text":"","category":"section"},{"location":"exercises/01-workshop_exercises/","page":"SciML Workshop Exercises","title":"SciML Workshop Exercises","text":"Use the modelingtoolkitize function from ModelingToolkit.jl to convert your numerical ODE function into a symbolic ODE function and use that to compute and solve with an analytical sparse Jacobian.","category":"page"},{"location":"exercises/01-workshop_exercises/#Part-6:-Utilizing-Preconditioned-GMRES-Linear-Solvers","page":"SciML Workshop Exercises","title":"Part 6: Utilizing Preconditioned-GMRES Linear Solvers","text":"","category":"section"},{"location":"exercises/01-workshop_exercises/","page":"SciML Workshop Exercises","title":"SciML Workshop Exercises","text":"Use the linear solver specification page to solve the equation with TRBDF2 with GMRES. Use the Sundials documentation to solve the equation with CVODE_BDF with Sundials' special internal GMRES. To both of these, use the AlgebraicMultigrid.jl to add a preconditioner to the GMRES solver.","category":"page"},{"location":"exercises/01-workshop_exercises/#Part-7:-Exploring-IMEX-and-Exponential-Integrator-Techniques-(E)","page":"SciML Workshop Exercises","title":"Part 7: Exploring IMEX and Exponential Integrator Techniques (E)","text":"","category":"section"},{"location":"exercises/01-workshop_exercises/","page":"SciML Workshop Exercises","title":"SciML Workshop Exercises","text":"Instead of using the standard ODEProblem, define a SplitODEProblem to move some of the equation to the \"non-stiff part\". Try different splits and solve with KenCarp4 to see if the solution can be accelerated.","category":"page"},{"location":"exercises/01-workshop_exercises/","page":"SciML Workshop Exercises","title":"SciML Workshop Exercises","text":"Next, use MatrixFreeOperator and DiffEqArrayOperator to define part of the equation as linear, and use the ETDRK4 exponential integrator to solve the equation. Note that this technique is not appropriate for this equation since it relies on the nonlinear term being non-stiff for best results.","category":"page"},{"location":"exercises/01-workshop_exercises/#Part-8:-Work-Precision-Diagrams-for-Benchmarking-Solver-Choices","page":"SciML Workshop Exercises","title":"Part 8: Work-Precision Diagrams for Benchmarking Solver Choices","text":"","category":"section"},{"location":"exercises/01-workshop_exercises/","page":"SciML Workshop Exercises","title":"SciML Workshop Exercises","text":"Use the WorkPrecisionSet method from DiffEqDevTools.jl to benchmark multiple different solver methods and find out what combination is most efficient. Take a look at DiffEqBenchmarks.jl for usage examples.","category":"page"},{"location":"exercises/01-workshop_exercises/#Part-9:-GPU-Parallelism-for-PDEs-(E)","page":"SciML Workshop Exercises","title":"Part 9: GPU-Parallelism for PDEs (E)","text":"","category":"section"},{"location":"exercises/01-workshop_exercises/","page":"SciML Workshop Exercises","title":"SciML Workshop Exercises","text":"Fully vectorize your implementation of the ODE and use a CuArray from CuArrays.jl as the initial condition to cause the whole solution to be GPU accelerated.","category":"page"},{"location":"exercises/01-workshop_exercises/#Part-10:-Adjoint-Sensitivity-Analysis-for-Gradients-of-PDEs","page":"SciML Workshop Exercises","title":"Part 10: Adjoint Sensitivity Analysis for Gradients of PDEs","text":"","category":"section"},{"location":"exercises/01-workshop_exercises/","page":"SciML Workshop Exercises","title":"SciML Workshop Exercises","text":"In order to optimize the parameters of a PDE, you need to be able to compute the gradient of the solution with respect to the parameters. This is done through sensitivity analysis. For PDEs, generally the system is at a scale where forward sensitivity analysis (forward-mode automatic differentiation) is no longer suitable, and for these cases one uses adjoint sensitivity analysis.","category":"page"},{"location":"exercises/01-workshop_exercises/","page":"SciML Workshop Exercises","title":"SciML Workshop Exercises","text":"Rewrite the PDE so the constant terms are parameters, and use the adjoint sensitivity analysis documentation to solve for the solution gradient with a cost function being the L2 distance of the solution from the value 1. Solve with interpolated and checkpointed adjoints. Play with using reverse-mode automatic differentiation vs direct computation of vector-Jacobian products using the autojacvec option of the SensitivityAlg. Find the set of options most suitable for this PDE.","category":"page"},{"location":"exercises/01-workshop_exercises/","page":"SciML Workshop Exercises","title":"SciML Workshop Exercises","text":"If you have compute time, use this adjoint to optimize the parameters of the PDE with respect to this cost function.","category":"page"},{"location":"exercises/01-workshop_exercises/#Problem-5:-Global-Parameter-Sensitivity-and-Optimality-with-GPU-and-Distributed-Ensembles-(B)","page":"SciML Workshop Exercises","title":"Problem 5: Global Parameter Sensitivity and Optimality with GPU and Distributed Ensembles (B)","text":"","category":"section"},{"location":"exercises/01-workshop_exercises/","page":"SciML Workshop Exercises","title":"SciML Workshop Exercises","text":"In this example we will investigate how the parameters \"generally\" effect the solution in the chaotic Henon-Heiles system. By \"generally\" we will use global sensitivity analysis methods to get an average global characterization of the parameters on the solution. In addition to a global sensitivity approach, we will generate large ensembles of solutions with different parameters using a GPU-based parallelism approach.","category":"page"},{"location":"exercises/01-workshop_exercises/#Part-1:-Implementing-the-Henon-Heiles-System-(B)","page":"SciML Workshop Exercises","title":"Part 1: Implementing the Henon-Heiles System (B)","text":"","category":"section"},{"location":"exercises/01-workshop_exercises/","page":"SciML Workshop Exercises","title":"SciML Workshop Exercises","text":"The Henon-Heiles Hamiltonian system is described by the ODEs:","category":"page"},{"location":"exercises/01-workshop_exercises/","page":"SciML Workshop Exercises","title":"SciML Workshop Exercises","text":"beginalign\nfracdp_1dt = -q_1 (1 + 2q_2)\nfracdp_2dt = -q_2 - (q_1^2 - q_2^2)\nfracdq_1dt = p_1\nfracdq_2dt = p_2endalign","category":"page"},{"location":"exercises/01-workshop_exercises/","page":"SciML Workshop Exercises","title":"SciML Workshop Exercises","text":"with initial conditions u_0 = 01000005. Solve this system over the timespan tin01000","category":"page"},{"location":"exercises/01-workshop_exercises/#(Optional)-Part-2:-Alternative-Dynamical-Implmentations-of-Henon-Heiles-(B)","page":"SciML Workshop Exercises","title":"(Optional) Part 2: Alternative Dynamical Implmentations of Henon-Heiles (B)","text":"","category":"section"},{"location":"exercises/01-workshop_exercises/","page":"SciML Workshop Exercises","title":"SciML Workshop Exercises","text":"The Henon-Heiles defines a Hamiltonian system with certain structures which can be utilized for a more efficient solution. Use the Dynamical problems page to define a SecondOrderODEProblem corresponding to the acceleration terms:","category":"page"},{"location":"exercises/01-workshop_exercises/","page":"SciML Workshop Exercises","title":"SciML Workshop Exercises","text":"beginalign\nfracd^2q_1dt^2 = -q_1 (1 + 2q_2)\nfracd^2q_2dt^2 = -q_2 - (q_1^2 - q_2^2)endalign","category":"page"},{"location":"exercises/01-workshop_exercises/","page":"SciML Workshop Exercises","title":"SciML Workshop Exercises","text":"Solve this with a method that is specific to dynamical problems, like DPRKN6.","category":"page"},{"location":"exercises/01-workshop_exercises/","page":"SciML Workshop Exercises","title":"SciML Workshop Exercises","text":"The Hamiltonian can also be directly described:","category":"page"},{"location":"exercises/01-workshop_exercises/","page":"SciML Workshop Exercises","title":"SciML Workshop Exercises","text":"H(pq) = frac12(p_1^2 + p_2^2) + frac12(q_1^2+q_2^2+2q_1^2 q_2 - frac23q_2^3)","category":"page"},{"location":"exercises/01-workshop_exercises/","page":"SciML Workshop Exercises","title":"SciML Workshop Exercises","text":"Solve this problem using the HamiltonianProblem constructor from DiffEqPhysics.jl.","category":"page"},{"location":"exercises/01-workshop_exercises/#Part-3:-Parallelized-Ensemble-Solving","page":"SciML Workshop Exercises","title":"Part 3: Parallelized Ensemble Solving","text":"","category":"section"},{"location":"exercises/01-workshop_exercises/","page":"SciML Workshop Exercises","title":"SciML Workshop Exercises","text":"To understand the orbits of the Henon-Heiles system, it can be useful to solve the system with many different initial conditions. Use the ensemble interface to solve with randomized initial conditions in parallel using threads with EnsembleThreads(). Then, use addprocs() to add more cores and solve using EnsembleDistributed(). The former will solve using all of the cores on a single computer, while the latter will use all of the cores on which there are processors, which can include thousands across a supercomputer! See Julia's parallel computing setup page for more details on the setup.","category":"page"},{"location":"exercises/01-workshop_exercises/#Part-4:-Parallelized-GPU-Ensemble-Solving","page":"SciML Workshop Exercises","title":"Part 4: Parallelized GPU Ensemble Solving","text":"","category":"section"},{"location":"exercises/01-workshop_exercises/","page":"SciML Workshop Exercises","title":"SciML Workshop Exercises","text":"Setup the CUDAnative.jl library and use the EnsembleGPUArray() method to parallelize the solution across the thousands of cores of a GPU. Note that this will efficiency solve for hundreds of thousands of trajectores.","category":"page"},{"location":"exercises/01-workshop_exercises/#Problem-6:-Training-Neural-Stochastic-Differential-Equations-with-GPU-acceleration-(I)","page":"SciML Workshop Exercises","title":"Problem 6: Training Neural Stochastic Differential Equations with GPU acceleration (I)","text":"","category":"section"},{"location":"exercises/01-workshop_exercises/","page":"SciML Workshop Exercises","title":"SciML Workshop Exercises","text":"In the previous models we had to define a model. Now let's shift the burden of model-proofing onto data by utilizing neural differential equations. A neural differential equation is a differential equation where the model equations are replaced, either in full or in part, by a neural network. For example, a neural ordinary differential equation is an equation u^prime = f(upt) where f is a neural network. We can learn this neural network from data using various methods, the easiest of which is known as the single shooting method, where one chooses neural network parameters, solves the equation, and checks the ODE's solution against data as a loss.","category":"page"},{"location":"exercises/01-workshop_exercises/","page":"SciML Workshop Exercises","title":"SciML Workshop Exercises","text":"In this example we will define and train various forms of neural differential equations. Note that all of the differential equation types are compatible with neural differential equations, so this is only going to scratch the surface of the possibilites!","category":"page"},{"location":"exercises/01-workshop_exercises/#Part-1:-Constructing-and-Training-a-Basic-Neural-ODE","page":"SciML Workshop Exercises","title":"Part 1: Constructing and Training a Basic Neural ODE","text":"","category":"section"},{"location":"exercises/01-workshop_exercises/","page":"SciML Workshop Exercises","title":"SciML Workshop Exercises","text":"Use the DiffEqFlux.jl README to construct a neural ODE to train against the training data:","category":"page"},{"location":"exercises/01-workshop_exercises/","page":"SciML Workshop Exercises","title":"SciML Workshop Exercises","text":"\nu0 = Float32[2.; 0.]\ndatasize = 30\ntspan = (0.0f0,1.5f0)\n\nfunction trueODEfunc(du,u,p,t)\n    true_A = [-0.1 2.0; -2.0 -0.1]\n    du .= ((u.^3)'true_A)'\nend\nt = range(tspan[1],tspan[2],length=datasize)\nprob = ODEProblem(trueODEfunc,u0,tspan)\node_data = Array(solve(prob,Tsit5(),saveat=t))","category":"page"},{"location":"exercises/01-workshop_exercises/#Part-2:-GPU-accelerating-the-Neural-ODE-Process","page":"SciML Workshop Exercises","title":"Part 2: GPU-accelerating the Neural ODE Process","text":"","category":"section"},{"location":"exercises/01-workshop_exercises/","page":"SciML Workshop Exercises","title":"SciML Workshop Exercises","text":"Use the gpu function from Flux.jl to transform all of the calculations onto the GPU and train the neural ODE using GPU-accelerated Tsit5 with adjoints.","category":"page"},{"location":"exercises/01-workshop_exercises/#Part-3:-Defining-and-Training-a-Mixed-Neural-ODE","page":"SciML Workshop Exercises","title":"Part 3: Defining and Training a Mixed Neural ODE","text":"","category":"section"},{"location":"exercises/01-workshop_exercises/","page":"SciML Workshop Exercises","title":"SciML Workshop Exercises","text":"Gather data from the Lotka-Volterra equation:","category":"page"},{"location":"exercises/01-workshop_exercises/","page":"SciML Workshop Exercises","title":"SciML Workshop Exercises","text":"\nfunction lotka_volterra(du,u,p,t)\n  x, y = u\n  α, β, δ, γ = p\n  du[1] = dx = α*x - β*x*y\n  du[2] = dy = -δ*y + γ*x*y\nend\nu0 = [1.0,1.0]\ntspan = (0.0,10.0)\np = [1.5,1.0,3.0,1.0]\nprob = ODEProblem(lotka_volterra,u0,tspan,p)\nsol = Array(solve(prob,Tsit5())(0.0:1.0:10.0))","category":"page"},{"location":"exercises/01-workshop_exercises/","page":"SciML Workshop Exercises","title":"SciML Workshop Exercises","text":"Now use the mixed neural section of the documentation to define the mixed neural ODE where the functional form of fracdxdt is known, and try to derive a neural formulation for fracdydt directly from the data.","category":"page"},{"location":"exercises/01-workshop_exercises/#Part-4:-Constructing-a-Basic-Neural-SDE","page":"SciML Workshop Exercises","title":"Part 4: Constructing a Basic Neural SDE","text":"","category":"section"},{"location":"exercises/01-workshop_exercises/","page":"SciML Workshop Exercises","title":"SciML Workshop Exercises","text":"Generate data from the Lotka-Volterra equation with multiplicative noise","category":"page"},{"location":"exercises/01-workshop_exercises/","page":"SciML Workshop Exercises","title":"SciML Workshop Exercises","text":"\nfunction lotka_volterra(du,u,p,t)\n  x, y = u\n  α, β, δ, γ = p\n  du[1] = dx = α*x - β*x*y\n  du[2] = dy = -δ*y + γ*x*y\nend\nfunction lv_noise(du,u,p,t)\n  du[1] = p[5]*u[1]\n  du[2] = p[6]*u[2]\nend\nu0 = [1.0,1.0]\ntspan = (0.0,10.0)\np = [1.5,1.0,3.0,1.0,0.1,0.1]\nprob = SDEProblem(lotka_volterra,lv_noise,u0,tspan,p)\nsol = [Array(solve(prob,SOSRI())(0.0:1.0:10.0)) for i in 1:20] # 20 solution samples","category":"page"},{"location":"exercises/01-workshop_exercises/","page":"SciML Workshop Exercises","title":"SciML Workshop Exercises","text":"Train a neural stochastic differential equation dX = f(X)dt + g(X)dW_t where both the drift (f) and the diffusion (g) functions are neural networks. See if constraining g can make the problem easier to fit.","category":"page"},{"location":"exercises/01-workshop_exercises/#Part-5:-Optimizing-the-training-behavior-with-minibatching-(E)","page":"SciML Workshop Exercises","title":"Part 5: Optimizing the training behavior with minibatching (E)","text":"","category":"section"},{"location":"exercises/01-workshop_exercises/","page":"SciML Workshop Exercises","title":"SciML Workshop Exercises","text":"Use minibatching on the data to improve the training procedure. An example can be found at this PR.","category":"page"},{"location":"advanced/01-beeler_reuter/#An-Implicit/Explicit-CUDA-Accelerated-Solver-for-the-2D-Beeler-Reuter-Model","page":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","title":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","text":"","category":"section"},{"location":"advanced/01-beeler_reuter/#Background","page":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","title":"Background","text":"","category":"section"},{"location":"advanced/01-beeler_reuter/","page":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","title":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","text":"SciML is a suite of optimized Julia libraries to solve ordinary differential equations (ODE). SciML provides a large number of explicit and implicit solvers suited for different types of ODE problems. It is possible to reduce a system of partial differential equations into an ODE problem by employing the method of lines (MOL). The essence of MOL is to discretize the spatial derivatives (by finite difference, finite volume or finite element methods) into algebraic equations and to keep the time derivatives as is. The resulting differential equations are left with only one independent variable (time) and can be solved with an ODE solver. Solving Systems of Stochastic PDEs and using GPUs in Julia is a brief introduction to MOL and using GPUs to accelerate PDE solving in JuliaDiffEq. Here we expand on this introduction by developing an implicit/explicit (IMEX) solver for a 2D cardiac electrophysiology model and show how to use CUDA libraries to run the explicit part of the model on a GPU.","category":"page"},{"location":"advanced/01-beeler_reuter/","page":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","title":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","text":"Note that this tutorial does not use the higher order IMEX methods built into DifferentialEquations.jl but instead shows how to hand-split an equation when the explicit portion has an analytical solution (or approxiate), which is common in many scenarios.","category":"page"},{"location":"advanced/01-beeler_reuter/","page":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","title":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","text":"There are hundreds of ionic models that describe cardiac electrical activity in various degrees of detail. Most are based on the classic Hodgkin-Huxley model and define the time-evolution of different state variables in the form of nonlinear first-order ODEs. The state vector for these models includes the transmembrane potential, gating variables, and ionic concentrations. The coupling between cells is through the transmembrame potential only and is described as a reaction-diffusion equation, which is a parabolic PDE,","category":"page"},{"location":"advanced/01-beeler_reuter/","page":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","title":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","text":"partial V  partial t = nabla (D  nabla V) - frac I_textion C_m","category":"page"},{"location":"advanced/01-beeler_reuter/","page":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","title":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","text":"where V is the transmembrane potential, D is a diffusion tensor, I_textion is the sum of the transmembrane currents and is calculated from the ODEs, and C_m is the membrane capacitance and is usually assumed to be constant. Here we model a uniform and isotropic medium. Therefore, the model can be simplified to,","category":"page"},{"location":"advanced/01-beeler_reuter/","page":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","title":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","text":"partial V  partial t = D DeltaV - frac I_textion C_m","category":"page"},{"location":"advanced/01-beeler_reuter/","page":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","title":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","text":"where D is now a scalar. By nature, these models have to deal with different time scales and are therefore classified as stiff. Commonly, they are solved using the explicit Euler method, usually with a closed form for the integration of the gating variables (the Rush-Larsen method, see below). We can also solve these problems using implicit or semi-implicit PDE solvers (e.g., the Crank-Nicholson method combined with an iterative solver). Higher order explicit methods such as Runge-Kutta and linear multi-step methods cannot overcome the stiffness and are not particularly helpful.","category":"page"},{"location":"advanced/01-beeler_reuter/","page":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","title":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","text":"In this tutorial, we first develop a CPU-only IMEX solver and then show how to move the explicit part to a GPU.","category":"page"},{"location":"advanced/01-beeler_reuter/#The-Beeler-Reuter-Model","page":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","title":"The Beeler-Reuter Model","text":"","category":"section"},{"location":"advanced/01-beeler_reuter/","page":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","title":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","text":"We have chosen the Beeler-Reuter ventricular ionic model as our example. It is a classic model first described in 1977 and is used as a base for many other ionic models. It has eight state variables, which makes it complicated enough to be interesting without obscuring the main points of the exercise. The eight state variables are: the transmembrane potential (V), sodium-channel activation and inactivation gates (m and h, similar to the Hodgkin-Huxley model), with an additional slow inactivation gate (j), calcium-channel activation and deactivations gates (d and f), a time-dependent inward-rectifying potassium current gate (x_1), and intracellular calcium concentration (c). There are four currents: a sodium current (i_Na), a calcium current (i_Ca), and two potassium currents, one time-dependent (i_x_1) and one background time-independent (i_K_1).","category":"page"},{"location":"advanced/01-beeler_reuter/#CPU-Only-Beeler-Reuter-Solver","page":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","title":"CPU-Only Beeler-Reuter Solver","text":"","category":"section"},{"location":"advanced/01-beeler_reuter/","page":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","title":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","text":"Let's start by developing a CPU only IMEX solver. The main idea is to use the DifferentialEquations framework to handle the implicit part of the equation and code the analytical approximation for explicit part separately. If no analytical approximation was known for the explicit part, one could use methods from this list.","category":"page"},{"location":"advanced/01-beeler_reuter/","page":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","title":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","text":"First, we define the model constants:","category":"page"},{"location":"advanced/01-beeler_reuter/","page":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","title":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","text":"const v0 = -84.624\nconst v1 = 10.0\nconst C_K1 = 1.0f0\nconst C_x1 = 1.0f0\nconst C_Na = 1.0f0\nconst C_s = 1.0f0\nconst D_Ca = 0.0f0\nconst D_Na = 0.0f0\nconst g_s = 0.09f0\nconst g_Na = 4.0f0\nconst g_NaC = 0.005f0\nconst ENa = 50.0f0 + D_Na\nconst γ = 0.5f0\nconst C_m = 1.0f0","category":"page"},{"location":"advanced/01-beeler_reuter/","page":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","title":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","text":"1.0f0","category":"page"},{"location":"advanced/01-beeler_reuter/","page":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","title":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","text":"Note that the constants are defined as Float32 and not Float64. The reason is that most GPUs have many more single precision cores than double precision ones. To ensure uniformity between CPU and GPU, we also code most states variables as Float32 except for the transmembrane potential, which is solved by an implicit solver provided by the Sundial library and needs to be Float64.","category":"page"},{"location":"advanced/01-beeler_reuter/#The-State-Structure","page":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","title":"The State Structure","text":"","category":"section"},{"location":"advanced/01-beeler_reuter/","page":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","title":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","text":"Next, we define a struct to contain our state. BeelerReuterCpu is a functor and we will define a deriv function as its associated function.","category":"page"},{"location":"advanced/01-beeler_reuter/","page":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","title":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","text":"mutable struct BeelerReuterCpu <: Function\n    t::Float64              # the last timestep time to calculate Δt\n    diff_coef::Float64      # the diffusion-coefficient (coupling strength)\n\n    C::Array{Float32, 2}    # intracellular calcium concentration\n    M::Array{Float32, 2}    # sodium current activation gate (m)\n    H::Array{Float32, 2}    # sodium current inactivation gate (h)\n    J::Array{Float32, 2}    # sodium current slow inactivaiton gate (j)\n    D::Array{Float32, 2}    # calcium current activaiton gate (d)\n    F::Array{Float32, 2}    # calcium current inactivation gate (f)\n    XI::Array{Float32, 2}   # inward-rectifying potassium current (iK1)\n\n    Δu::Array{Float64, 2}   # place-holder for the Laplacian\n\n    function BeelerReuterCpu(u0, diff_coef)\n        self = new()\n\n        ny, nx = size(u0)\n        self.t = 0.0\n        self.diff_coef = diff_coef\n\n        self.C = fill(0.0001f0, (ny,nx))\n        self.M = fill(0.01f0, (ny,nx))\n        self.H = fill(0.988f0, (ny,nx))\n        self.J = fill(0.975f0, (ny,nx))\n        self.D = fill(0.003f0, (ny,nx))\n        self.F = fill(0.994f0, (ny,nx))\n        self.XI = fill(0.0001f0, (ny,nx))\n\n        self.Δu = zeros(ny,nx)\n\n        return self\n    end\nend","category":"page"},{"location":"advanced/01-beeler_reuter/#Laplacian","page":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","title":"Laplacian","text":"","category":"section"},{"location":"advanced/01-beeler_reuter/","page":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","title":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","text":"The finite-difference Laplacian is calculated in-place by a 5-point stencil. The Neumann boundary condition is enforced. Note that we could have also used DiffEqOperators.jl to automate this step.","category":"page"},{"location":"advanced/01-beeler_reuter/","page":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","title":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","text":"# 5-point stencil\nfunction laplacian(Δu, u)\n    n1, n2 = size(u)\n\n    # internal nodes\n    for j = 2:n2-1\n        for i = 2:n1-1\n            @inbounds  Δu[i,j] = u[i+1,j] + u[i-1,j] + u[i,j+1] + u[i,j-1] - 4*u[i,j]\n        end\n    end\n\n    # left/right edges\n    for i = 2:n1-1\n        @inbounds Δu[i,1] = u[i+1,1] + u[i-1,1] + 2*u[i,2] - 4*u[i,1]\n        @inbounds Δu[i,n2] = u[i+1,n2] + u[i-1,n2] + 2*u[i,n2-1] - 4*u[i,n2]\n    end\n\n    # top/bottom edges\n    for j = 2:n2-1\n        @inbounds Δu[1,j] = u[1,j+1] + u[1,j-1] + 2*u[2,j] - 4*u[1,j]\n        @inbounds Δu[n1,j] = u[n1,j+1] + u[n1,j-1] + 2*u[n1-1,j] - 4*u[n1,j]\n    end\n\n    # corners\n    @inbounds Δu[1,1] = 2*(u[2,1] + u[1,2]) - 4*u[1,1]\n    @inbounds Δu[n1,1] = 2*(u[n1-1,1] + u[n1,2]) - 4*u[n1,1]\n    @inbounds Δu[1,n2] = 2*(u[2,n2] + u[1,n2-1]) - 4*u[1,n2]\n    @inbounds Δu[n1,n2] = 2*(u[n1-1,n2] + u[n1,n2-1]) - 4*u[n1,n2]\nend","category":"page"},{"location":"advanced/01-beeler_reuter/","page":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","title":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","text":"laplacian (generic function with 1 method)","category":"page"},{"location":"advanced/01-beeler_reuter/#The-Rush-Larsen-Method","page":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","title":"The Rush-Larsen Method","text":"","category":"section"},{"location":"advanced/01-beeler_reuter/","page":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","title":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","text":"We use an explicit solver for all the state variables except for the transmembrane potential which is solved with the help of an implicit solver. The explicit solver is a domain-specific exponential method, the Rush-Larsen method. This method utilizes an approximation on the model in order to transform the IMEX equation into a form suitable for an implicit ODE solver. This combination of implicit and explicit methods forms a specialized IMEX solver. For general IMEX integration, please see the IMEX solvers documentation. While we could have used the general model to solve the current problem, for this specific model, the transformation approach is more efficient and is of practical interest.","category":"page"},{"location":"advanced/01-beeler_reuter/","page":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","title":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","text":"The Rush-Larsen method replaces the explicit Euler integration for the gating variables with direct integration. The starting point is the general ODE for the gating variables in Hodgkin-Huxley style ODEs,","category":"page"},{"location":"advanced/01-beeler_reuter/","page":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","title":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","text":"fracdgdt = alpha(V) (1 - g) - beta(V) g","category":"page"},{"location":"advanced/01-beeler_reuter/","page":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","title":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","text":"where g is a generic gating variable, ranging from 0 to 1, and alpha and beta are reaction rates. This equation can be written as,","category":"page"},{"location":"advanced/01-beeler_reuter/","page":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","title":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","text":"fracdgdt = (g_infty - g)  tau_g","category":"page"},{"location":"advanced/01-beeler_reuter/","page":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","title":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","text":"where g_infty and tau_g are","category":"page"},{"location":"advanced/01-beeler_reuter/","page":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","title":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","text":"g_infty = fracalpha(alpha + beta)","category":"page"},{"location":"advanced/01-beeler_reuter/","page":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","title":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","text":"and,","category":"page"},{"location":"advanced/01-beeler_reuter/","page":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","title":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","text":"tau_g = frac1(alpha + beta)","category":"page"},{"location":"advanced/01-beeler_reuter/","page":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","title":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","text":"Assuing that g_infty and tau_g are constant for the duration of a single time step (Deltat), which is a reasonable assumption for most cardiac models, we can integrate directly to have,","category":"page"},{"location":"advanced/01-beeler_reuter/","page":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","title":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","text":"g(t + Deltat) = g_infty - left(g_infty - g(Deltat)right)e^-Deltattau_g","category":"page"},{"location":"advanced/01-beeler_reuter/","page":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","title":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","text":"This is the Rush-Larsen technique. Note that as Deltat rightarrow 0, this equations morphs into the explicit Euler formula,","category":"page"},{"location":"advanced/01-beeler_reuter/","page":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","title":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","text":"g(t + Deltat) = g(t) + Deltatfracdgdt","category":"page"},{"location":"advanced/01-beeler_reuter/","page":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","title":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","text":"rush_larsen is a helper function that use the Rush-Larsen method to integrate the gating variables.","category":"page"},{"location":"advanced/01-beeler_reuter/","page":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","title":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","text":"@inline function rush_larsen(g, α, β, Δt)\n    inf = α/(α+β)\n    τ = 1f0 / (α+β)\n    return clamp(g + (g - inf) * expm1(-Δt/τ), 0f0, 1f0)\nend","category":"page"},{"location":"advanced/01-beeler_reuter/","page":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","title":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","text":"rush_larsen (generic function with 1 method)","category":"page"},{"location":"advanced/01-beeler_reuter/","page":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","title":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","text":"The gating variables are updated as below. The details of how to calculate alpha and beta are based on the Beeler-Reuter model and not of direct interest to this tutorial.","category":"page"},{"location":"advanced/01-beeler_reuter/","page":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","title":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","text":"function update_M_cpu(g, v, Δt)\n    # the condition is needed here to prevent NaN when v == 47.0\n    α = isapprox(v, 47.0f0) ? 10.0f0 : -(v+47.0f0) / (exp(-0.1f0*(v+47.0f0)) - 1.0f0)\n    β = (40.0f0 * exp(-0.056f0*(v+72.0f0)))\n    return rush_larsen(g, α, β, Δt)\nend\n\nfunction update_H_cpu(g, v, Δt)\n    α = 0.126f0 * exp(-0.25f0*(v+77.0f0))\n    β = 1.7f0 / (exp(-0.082f0*(v+22.5f0)) + 1.0f0)\n   return rush_larsen(g, α, β, Δt)\nend\n\nfunction update_J_cpu(g, v, Δt)\n    α = (0.55f0 * exp(-0.25f0*(v+78.0f0))) / (exp(-0.2f0*(v+78.0f0)) + 1.0f0)\n    β = 0.3f0 / (exp(-0.1f0*(v+32.0f0)) + 1.0f0)\n    return rush_larsen(g, α, β, Δt)\nend\n\nfunction update_D_cpu(g, v, Δt)\n    α = γ * (0.095f0 * exp(-0.01f0*(v-5.0f0))) / (exp(-0.072f0*(v-5.0f0)) + 1.0f0)\n    β = γ * (0.07f0 * exp(-0.017f0*(v+44.0f0))) / (exp(0.05f0*(v+44.0f0)) + 1.0f0)\n    return rush_larsen(g, α, β, Δt)\nend\n\nfunction update_F_cpu(g, v, Δt)\n    α = γ * (0.012f0 * exp(-0.008f0*(v+28.0f0))) / (exp(0.15f0*(v+28.0f0)) + 1.0f0)\n    β = γ * (0.0065f0 * exp(-0.02f0*(v+30.0f0))) / (exp(-0.2f0*(v+30.0f0)) + 1.0f0)\n    return rush_larsen(g, α, β, Δt)\nend\n\nfunction update_XI_cpu(g, v, Δt)\n    α = (0.0005f0 * exp(0.083f0*(v+50.0f0))) / (exp(0.057f0*(v+50.0f0)) + 1.0f0)\n    β = (0.0013f0 * exp(-0.06f0*(v+20.0f0))) / (exp(-0.04f0*(v+20.0f0)) + 1.0f0)\n    return rush_larsen(g, α, β, Δt)\nend","category":"page"},{"location":"advanced/01-beeler_reuter/","page":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","title":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","text":"update_XI_cpu (generic function with 1 method)","category":"page"},{"location":"advanced/01-beeler_reuter/","page":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","title":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","text":"The intracelleular calcium is not technically a gating variable, but we can use a similar explicit exponential integrator for it.","category":"page"},{"location":"advanced/01-beeler_reuter/","page":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","title":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","text":"function update_C_cpu(g, d, f, v, Δt)\n    ECa = D_Ca - 82.3f0 - 13.0278f0 * log(g)\n    kCa = C_s * g_s * d * f\n    iCa = kCa * (v - ECa)\n    inf = 1.0f-7 * (0.07f0 - g)\n    τ = 1f0 / 0.07f0\n    return g + (g - inf) * expm1(-Δt/τ)\nend","category":"page"},{"location":"advanced/01-beeler_reuter/","page":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","title":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","text":"update_C_cpu (generic function with 1 method)","category":"page"},{"location":"advanced/01-beeler_reuter/#Implicit-Solver","page":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","title":"Implicit Solver","text":"","category":"section"},{"location":"advanced/01-beeler_reuter/","page":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","title":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","text":"Now, it is time to define the derivative function as an associated function of BeelerReuterCpu. We plan to use the CVODE_BDF solver as our implicit portion. Similar to other iterative methods, it calls the deriv function with the same t multiple times. For example, these are consecutive ts from a representative run:","category":"page"},{"location":"advanced/01-beeler_reuter/","page":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","title":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","text":"0.86830 0.86830 0.85485 0.85485 0.85485 0.86359 0.86359 0.86359 0.87233 0.87233 0.87233 0.88598 ...","category":"page"},{"location":"advanced/01-beeler_reuter/","page":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","title":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","text":"Here, every time step is called three times. We distinguish between two types of calls to the deriv function. When t changes, the gating variables are updated by calling update_gates_cpu:","category":"page"},{"location":"advanced/01-beeler_reuter/","page":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","title":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","text":"function update_gates_cpu(u, XI, M, H, J, D, F, C, Δt)\n    let Δt = Float32(Δt)\n        n1, n2 = size(u)\n        for j = 1:n2\n            for i = 1:n1\n                v = Float32(u[i,j])\n\n                XI[i,j] = update_XI_cpu(XI[i,j], v, Δt)\n                M[i,j] = update_M_cpu(M[i,j], v, Δt)\n                H[i,j] = update_H_cpu(H[i,j], v, Δt)\n                J[i,j] = update_J_cpu(J[i,j], v, Δt)\n                D[i,j] = update_D_cpu(D[i,j], v, Δt)\n                F[i,j] = update_F_cpu(F[i,j], v, Δt)\n\n                C[i,j] = update_C_cpu(C[i,j], D[i,j], F[i,j], v, Δt)\n            end\n        end\n    end\nend","category":"page"},{"location":"advanced/01-beeler_reuter/","page":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","title":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","text":"update_gates_cpu (generic function with 1 method)","category":"page"},{"location":"advanced/01-beeler_reuter/","page":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","title":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","text":"On the other hand, du is updated at each time step, since it is independent of Deltat.","category":"page"},{"location":"advanced/01-beeler_reuter/","page":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","title":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","text":"# iK1 is the inward-rectifying potassium current\nfunction calc_iK1(v)\n    ea = exp(0.04f0*(v+85f0))\n    eb = exp(0.08f0*(v+53f0))\n    ec = exp(0.04f0*(v+53f0))\n    ed = exp(-0.04f0*(v+23f0))\n    return 0.35f0 * (4f0*(ea-1f0)/(eb + ec)\n            + 0.2f0 * (isapprox(v, -23f0) ? 25f0 : (v+23f0) / (1f0-ed)))\nend\n\n# ix1 is the time-independent background potassium current\nfunction calc_ix1(v, xi)\n    ea = exp(0.04f0*(v+77f0))\n    eb = exp(0.04f0*(v+35f0))\n    return xi * 0.8f0 * (ea-1f0) / eb\nend\n\n# iNa is the sodium current (similar to the classic Hodgkin-Huxley model)\nfunction calc_iNa(v, m, h, j)\n    return C_Na * (g_Na * m^3 * h * j + g_NaC) * (v - ENa)\nend\n\n# iCa is the calcium current\nfunction calc_iCa(v, d, f, c)\n    ECa = D_Ca - 82.3f0 - 13.0278f0 * log(c)    # ECa is the calcium reversal potential\n    return C_s * g_s * d * f * (v - ECa)\nend\n\nfunction update_du_cpu(du, u, XI, M, H, J, D, F, C)\n    n1, n2 = size(u)\n\n    for j = 1:n2\n        for i = 1:n1\n            v = Float32(u[i,j])\n\n            # calculating individual currents\n            iK1 = calc_iK1(v)\n            ix1 = calc_ix1(v, XI[i,j])\n            iNa = calc_iNa(v, M[i,j], H[i,j], J[i,j])\n            iCa = calc_iCa(v, D[i,j], F[i,j], C[i,j])\n\n            # total current\n            I_sum = iK1 + ix1 + iNa + iCa\n\n            # the reaction part of the reaction-diffusion equation\n            du[i,j] = -I_sum / C_m\n        end\n    end\nend","category":"page"},{"location":"advanced/01-beeler_reuter/","page":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","title":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","text":"update_du_cpu (generic function with 1 method)","category":"page"},{"location":"advanced/01-beeler_reuter/","page":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","title":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","text":"Finally, we put everything together is our deriv function, which is a call on BeelerReuterCpu.","category":"page"},{"location":"advanced/01-beeler_reuter/","page":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","title":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","text":"function (f::BeelerReuterCpu)(du, u, p, t)\n    Δt = t - f.t\n\n    if Δt != 0 || t == 0\n        update_gates_cpu(u, f.XI, f.M, f.H, f.J, f.D, f.F, f.C, Δt)\n        f.t = t\n    end\n\n    laplacian(f.Δu, u)\n\n    # calculate the reaction portion\n    update_du_cpu(du, u, f.XI, f.M, f.H, f.J, f.D, f.F, f.C)\n\n    # ...add the diffusion portion\n    du .+= f.diff_coef .* f.Δu\nend","category":"page"},{"location":"advanced/01-beeler_reuter/#Results","page":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","title":"Results","text":"","category":"section"},{"location":"advanced/01-beeler_reuter/","page":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","title":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","text":"Time to test! We need to define the starting transmembrane potential with the help of global constants v0 and v1, which represent the resting and activated potentials.","category":"page"},{"location":"advanced/01-beeler_reuter/","page":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","title":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","text":"const N = 192;\nu0 = fill(v0, (N, N));\nu0[90:102,90:102] .= v1;   # a small square in the middle of the domain","category":"page"},{"location":"advanced/01-beeler_reuter/","page":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","title":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","text":"The initial condition is a small square in the middle of the domain.","category":"page"},{"location":"advanced/01-beeler_reuter/","page":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","title":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","text":"using Plots\nheatmap(u0)","category":"page"},{"location":"advanced/01-beeler_reuter/","page":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","title":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","text":"(Image: )","category":"page"},{"location":"advanced/01-beeler_reuter/","page":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","title":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","text":"Next, the problem is defined:","category":"page"},{"location":"advanced/01-beeler_reuter/","page":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","title":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","text":"using DifferentialEquations, Sundials\n\nderiv_cpu = BeelerReuterCpu(u0, 1.0);\nprob = ODEProblem(deriv_cpu, u0, (0.0, 50.0));","category":"page"},{"location":"advanced/01-beeler_reuter/","page":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","title":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","text":"For stiff reaction-diffusion equations, CVODE_BDF from Sundial library is an excellent solver.","category":"page"},{"location":"advanced/01-beeler_reuter/","page":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","title":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","text":"@time sol = solve(prob, CVODE_BDF(linear_solver=:GMRES), saveat=100.0);","category":"page"},{"location":"advanced/01-beeler_reuter/","page":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","title":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","text":"30.348145 seconds (1.98 M allocations: 122.833 MiB, 0.10% gc time, 3.29% c\nompilation time)","category":"page"},{"location":"advanced/01-beeler_reuter/","page":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","title":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","text":"heatmap(sol.u[end])","category":"page"},{"location":"advanced/01-beeler_reuter/","page":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","title":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","text":"(Image: )","category":"page"},{"location":"advanced/01-beeler_reuter/#CPU/GPU-Beeler-Reuter-Solver","page":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","title":"CPU/GPU Beeler-Reuter Solver","text":"","category":"section"},{"location":"advanced/01-beeler_reuter/","page":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","title":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","text":"GPUs are great for embarrassingly parallel problems but not so much for highly coupled models. We plan to keep the implicit part on CPU and run the decoupled explicit code on a GPU with the help of the CUDAnative library.","category":"page"},{"location":"advanced/01-beeler_reuter/#GPUs-and-CUDA","page":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","title":"GPUs and CUDA","text":"","category":"section"},{"location":"advanced/01-beeler_reuter/","page":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","title":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","text":"It this section, we present a brief summary of how GPUs (specifically NVIDIA GPUs) work and how to program them using the Julia CUDA interface. The readers who are familiar with these basic concepts may skip this section.","category":"page"},{"location":"advanced/01-beeler_reuter/","page":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","title":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","text":"Let's start by looking at the hardware of a typical high-end GPU, GTX 1080. It has four Graphics Processing Clusters (equivalent to a discrete CPU), each harboring five Streaming Multiprocessor (similar to a CPU core). Each SM has 128 single-precision CUDA cores. Therefore, GTX 1080 has a total of 4 x 5 x 128 = 2560 CUDA cores. The maximum  theoretical throughput for a GTX 1080 is reported as 8.87 TFLOPS. This figure is calculated for a boost clock frequency of 1.733 MHz as 2 x 2560 x 1.733 MHz = 8.87 TFLOPS. The factor 2 is included because two single floating point operations, a multiplication and an addition, can be done in a clock cycle as part of a fused-multiply-addition FMA operation. GTX 1080 also has 8192 MB of global memory accessible to all the cores (in addition to local and shared memory on each SM).","category":"page"},{"location":"advanced/01-beeler_reuter/","page":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","title":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","text":"A typical CUDA application has the following flow:","category":"page"},{"location":"advanced/01-beeler_reuter/","page":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","title":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","text":"Define and initialize the problem domain tensors (multi-dimensional arrays) in CPU memory.\nAllocate corresponding tensors in the GPU global memory.\nTransfer the input tensors from CPU to the corresponding GPU tensors.\nInvoke CUDA kernels (i.e., the GPU functions callable from CPU) that operate on the GPU tensors.\nTransfer the result tensors from GPU back to CPU.\nProcess tensors on CPU.\nRepeat steps 3-6 as needed.","category":"page"},{"location":"advanced/01-beeler_reuter/","page":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","title":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","text":"Some libraries, such as ArrayFire, hide the complexicities of steps 2-5 behind a higher level of abstraction. However, here we take a lower level route. By using CUDA, we achieve a finer-grained control and higher performance. In return, we need to implement each step manually.","category":"page"},{"location":"advanced/01-beeler_reuter/","page":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","title":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","text":"CuArray is a thin abstraction layer over the CUDA API and allows us to define GPU-side tensors and copy data to and from them but does not provide for operations on tensors. CUDAnative is a compiler that translates Julia functions designated as CUDA kernels into ptx (a high-level CUDA assembly language).","category":"page"},{"location":"advanced/01-beeler_reuter/#The-CUDA-Code","page":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","title":"The CUDA Code","text":"","category":"section"},{"location":"advanced/01-beeler_reuter/","page":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","title":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","text":"The key to fast CUDA programs is to minimize CPU/GPU memory transfers and global memory accesses. The implicit solver is currently CPU only, but it only needs access to the transmembrane potential. The rest of state variables reside on the GPU memory.","category":"page"},{"location":"advanced/01-beeler_reuter/","page":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","title":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","text":"We modify BeelerReuterCpu into BeelerReuterGpu by defining the state variables as CuArrays instead of standard Julia Arrays. The name of each variable defined on GPU is prefixed by d_ for clarity. Note that Deltav is a temporary storage for the Laplacian and stays on the CPU side.","category":"page"},{"location":"advanced/01-beeler_reuter/","page":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","title":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","text":"using CUDA\n\nmutable struct BeelerReuterGpu <: Function\n    t::Float64                  # the last timestep time to calculate Δt\n    diff_coef::Float64          # the diffusion-coefficient (coupling strength)\n\n    d_C::CuArray{Float32, 2}    # intracellular calcium concentration\n    d_M::CuArray{Float32, 2}    # sodium current activation gate (m)\n    d_H::CuArray{Float32, 2}    # sodium current inactivation gate (h)\n    d_J::CuArray{Float32, 2}    # sodium current slow inactivaiton gate (j)\n    d_D::CuArray{Float32, 2}    # calcium current activaiton gate (d)\n    d_F::CuArray{Float32, 2}    # calcium current inactivation gate (f)\n    d_XI::CuArray{Float32, 2}   # inward-rectifying potassium current (iK1)\n\n    d_u::CuArray{Float64, 2}    # place-holder for u in the device memory\n    d_du::CuArray{Float64, 2}   # place-holder for d_u in the device memory\n\n    Δv::Array{Float64, 2}       # place-holder for voltage gradient\n\n    function BeelerReuterGpu(u0, diff_coef)\n        self = new()\n\n        ny, nx = size(u0)\n        @assert (nx % 16 == 0) && (ny % 16 == 0)\n        self.t = 0.0\n        self.diff_coef = diff_coef\n\n        self.d_C = CuArray(fill(0.0001f0, (ny,nx)))\n        self.d_M = CuArray(fill(0.01f0, (ny,nx)))\n        self.d_H = CuArray(fill(0.988f0, (ny,nx)))\n        self.d_J = CuArray(fill(0.975f0, (ny,nx)))\n        self.d_D = CuArray(fill(0.003f0, (ny,nx)))\n        self.d_F = CuArray(fill(0.994f0, (ny,nx)))\n        self.d_XI = CuArray(fill(0.0001f0, (ny,nx)))\n\n        self.d_u = CuArray(u0)\n        self.d_du = CuArray(zeros(ny,nx))\n\n        self.Δv = zeros(ny,nx)\n\n        return self\n    end\nend","category":"page"},{"location":"advanced/01-beeler_reuter/","page":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","title":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","text":"The Laplacian function remains unchanged. The main change to the explicit gating solvers is that exp and expm1 functions are prefixed by CUDAnative.. This is a technical nuisance that will hopefully be resolved in future.","category":"page"},{"location":"advanced/01-beeler_reuter/","page":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","title":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","text":"function rush_larsen_gpu(g, α, β, Δt)\n    inf = α/(α+β)\n    τ = 1.0/(α+β)\n    return clamp(g + (g - inf) * CUDAnative.expm1(-Δt/τ), 0f0, 1f0)\nend\n\nfunction update_M_gpu(g, v, Δt)\n    # the condition is needed here to prevent NaN when v == 47.0\n    α = isapprox(v, 47.0f0) ? 10.0f0 : -(v+47.0f0) / (CUDAnative.exp(-0.1f0*(v+47.0f0)) - 1.0f0)\n    β = (40.0f0 * CUDAnative.exp(-0.056f0*(v+72.0f0)))\n    return rush_larsen_gpu(g, α, β, Δt)\nend\n\nfunction update_H_gpu(g, v, Δt)\n    α = 0.126f0 * CUDAnative.exp(-0.25f0*(v+77.0f0))\n    β = 1.7f0 / (CUDAnative.exp(-0.082f0*(v+22.5f0)) + 1.0f0)\n    return rush_larsen_gpu(g, α, β, Δt)\nend\n\nfunction update_J_gpu(g, v, Δt)\n    α = (0.55f0 * CUDAnative.exp(-0.25f0*(v+78.0f0))) / (CUDAnative.exp(-0.2f0*(v+78.0f0)) + 1.0f0)\n    β = 0.3f0 / (CUDAnative.exp(-0.1f0*(v+32.0f0)) + 1.0f0)\n    return rush_larsen_gpu(g, α, β, Δt)\nend\n\nfunction update_D_gpu(g, v, Δt)\n    α = γ * (0.095f0 * CUDAnative.exp(-0.01f0*(v-5.0f0))) / (CUDAnative.exp(-0.072f0*(v-5.0f0)) + 1.0f0)\n    β = γ * (0.07f0 * CUDAnative.exp(-0.017f0*(v+44.0f0))) / (CUDAnative.exp(0.05f0*(v+44.0f0)) + 1.0f0)\n    return rush_larsen_gpu(g, α, β, Δt)\nend\n\nfunction update_F_gpu(g, v, Δt)\n    α = γ * (0.012f0 * CUDAnative.exp(-0.008f0*(v+28.0f0))) / (CUDAnative.exp(0.15f0*(v+28.0f0)) + 1.0f0)\n    β = γ * (0.0065f0 * CUDAnative.exp(-0.02f0*(v+30.0f0))) / (CUDAnative.exp(-0.2f0*(v+30.0f0)) + 1.0f0)\n    return rush_larsen_gpu(g, α, β, Δt)\nend\n\nfunction update_XI_gpu(g, v, Δt)\n    α = (0.0005f0 * CUDAnative.exp(0.083f0*(v+50.0f0))) / (CUDAnative.exp(0.057f0*(v+50.0f0)) + 1.0f0)\n    β = (0.0013f0 * CUDAnative.exp(-0.06f0*(v+20.0f0))) / (CUDAnative.exp(-0.04f0*(v+20.0f0)) + 1.0f0)\n    return rush_larsen_gpu(g, α, β, Δt)\nend\n\nfunction update_C_gpu(c, d, f, v, Δt)\n    ECa = D_Ca - 82.3f0 - 13.0278f0 * CUDAnative.log(c)\n    kCa = C_s * g_s * d * f\n    iCa = kCa * (v - ECa)\n    inf = 1.0f-7 * (0.07f0 - c)\n    τ = 1f0 / 0.07f0\n    return c + (c - inf) * CUDAnative.expm1(-Δt/τ)\nend","category":"page"},{"location":"advanced/01-beeler_reuter/","page":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","title":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","text":"update_C_gpu (generic function with 1 method)","category":"page"},{"location":"advanced/01-beeler_reuter/","page":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","title":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","text":"Similarly, we modify the functions to calculate the individual currents by adding CUDAnative prefix.","category":"page"},{"location":"advanced/01-beeler_reuter/","page":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","title":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","text":"# iK1 is the inward-rectifying potassium current\nfunction calc_iK1(v)\n    ea = CUDAnative.exp(0.04f0*(v+85f0))\n    eb = CUDAnative.exp(0.08f0*(v+53f0))\n    ec = CUDAnative.exp(0.04f0*(v+53f0))\n    ed = CUDAnative.exp(-0.04f0*(v+23f0))\n    return 0.35f0 * (4f0*(ea-1f0)/(eb + ec)\n            + 0.2f0 * (isapprox(v, -23f0) ? 25f0 : (v+23f0) / (1f0-ed)))\nend\n\n# ix1 is the time-independent background potassium current\nfunction calc_ix1(v, xi)\n    ea = CUDAnative.exp(0.04f0*(v+77f0))\n    eb = CUDAnative.exp(0.04f0*(v+35f0))\n    return xi * 0.8f0 * (ea-1f0) / eb\nend\n\n# iNa is the sodium current (similar to the classic Hodgkin-Huxley model)\nfunction calc_iNa(v, m, h, j)\n    return C_Na * (g_Na * m^3 * h * j + g_NaC) * (v - ENa)\nend\n\n# iCa is the calcium current\nfunction calc_iCa(v, d, f, c)\n    ECa = D_Ca - 82.3f0 - 13.0278f0 * CUDAnative.log(c)    # ECa is the calcium reversal potential\n    return C_s * g_s * d * f * (v - ECa)\nend","category":"page"},{"location":"advanced/01-beeler_reuter/","page":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","title":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","text":"calc_iCa (generic function with 1 method)","category":"page"},{"location":"advanced/01-beeler_reuter/#CUDA-Kernels","page":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","title":"CUDA Kernels","text":"","category":"section"},{"location":"advanced/01-beeler_reuter/","page":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","title":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","text":"A CUDA program does not directly deal with GPCs and SMs. The logical view of a CUDA program is in the term of blocks and threads. We have to specify the number of block and threads when running a CUDA kernel. Each thread runs on a single CUDA core. Threads are logically bundled into blocks, which are in turn specified on a grid. The grid stands for the entirety of the domain of interest.","category":"page"},{"location":"advanced/01-beeler_reuter/","page":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","title":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","text":"Each thread can find its logical coordinate by using few pre-defined indexing variables (threadIdx, blockIdx, blockDim and gridDim) in C/C++ and the corresponding functions (e.g., threadIdx()) in Julia. There variables and functions are defined automatically for each thread and may return a different value depending on the calling thread. The return value of these functions is a 1, 2, or 3 dimensional structure whose elements can be accessed as .x, .y, and .z (for a 1-dimensional case, .x reports the actual index and .y and .z simply return 1). For example, if we deploy a kernel in 128 blocks and with 256 threads per block, each thread will see","category":"page"},{"location":"advanced/01-beeler_reuter/","page":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","title":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","text":"    gridDim.x = 128;\n    blockDim=256;","category":"page"},{"location":"advanced/01-beeler_reuter/","page":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","title":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","text":"while blockIdx.x ranges from 0 to 127 in C/C++ and 1 to 128 in Julia. Similarly, threadIdx.x will be between 0 to 255 in C/C++ (of course, in Julia the range will be 1 to 256).","category":"page"},{"location":"advanced/01-beeler_reuter/","page":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","title":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","text":"A C/C++ thread can calculate its index as","category":"page"},{"location":"advanced/01-beeler_reuter/","page":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","title":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","text":"    int idx = blockDim.x * blockIdx.x + threadIdx.x;","category":"page"},{"location":"advanced/01-beeler_reuter/","page":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","title":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","text":"In Julia, we have to take into account base 1. Therefore, we use the following formula","category":"page"},{"location":"advanced/01-beeler_reuter/","page":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","title":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","text":"    idx = (blockIdx().x-UInt32(1)) * blockDim().x + threadIdx().x","category":"page"},{"location":"advanced/01-beeler_reuter/","page":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","title":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","text":"A CUDA programmer is free to interpret the calculated index however it fits the application, but in practice, it is usually interpreted as an index into input tensors.","category":"page"},{"location":"advanced/01-beeler_reuter/","page":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","title":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","text":"In the GPU version of the solver, each thread works on a single element of the medium, indexed by a (x,y) pair. update_gates_gpu and update_du_gpu are very similar to their CPU counterparts but are in fact CUDA kernels where the for loops are replaced with CUDA specific indexing. Note that CUDA kernels cannot return a valve; hence, nothing at the end.","category":"page"},{"location":"advanced/01-beeler_reuter/","page":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","title":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","text":"function update_gates_gpu(u, XI, M, H, J, D, F, C, Δt)\n    i = (blockIdx().x-UInt32(1)) * blockDim().x + threadIdx().x\n    j = (blockIdx().y-UInt32(1)) * blockDim().y + threadIdx().y\n\n    v = Float32(u[i,j])\n\n    let Δt = Float32(Δt)\n        XI[i,j] = update_XI_gpu(XI[i,j], v, Δt)\n        M[i,j] = update_M_gpu(M[i,j], v, Δt)\n        H[i,j] = update_H_gpu(H[i,j], v, Δt)\n        J[i,j] = update_J_gpu(J[i,j], v, Δt)\n        D[i,j] = update_D_gpu(D[i,j], v, Δt)\n        F[i,j] = update_F_gpu(F[i,j], v, Δt)\n\n        C[i,j] = update_C_gpu(C[i,j], D[i,j], F[i,j], v, Δt)\n    end\n    nothing\nend\n\nfunction update_du_gpu(du, u, XI, M, H, J, D, F, C)\n    i = (blockIdx().x-UInt32(1)) * blockDim().x + threadIdx().x\n    j = (blockIdx().y-UInt32(1)) * blockDim().y + threadIdx().y\n\n    v = Float32(u[i,j])\n\n    # calculating individual currents\n    iK1 = calc_iK1(v)\n    ix1 = calc_ix1(v, XI[i,j])\n    iNa = calc_iNa(v, M[i,j], H[i,j], J[i,j])\n    iCa = calc_iCa(v, D[i,j], F[i,j], C[i,j])\n\n    # total current\n    I_sum = iK1 + ix1 + iNa + iCa\n\n    # the reaction part of the reaction-diffusion equation\n    du[i,j] = -I_sum / C_m\n    nothing\nend","category":"page"},{"location":"advanced/01-beeler_reuter/","page":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","title":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","text":"update_du_gpu (generic function with 1 method)","category":"page"},{"location":"advanced/01-beeler_reuter/#Implicit-Solver-2","page":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","title":"Implicit Solver","text":"","category":"section"},{"location":"advanced/01-beeler_reuter/","page":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","title":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","text":"Finally, the deriv function is modified to copy u to GPU and copy du back and to invoke CUDA kernels.","category":"page"},{"location":"advanced/01-beeler_reuter/","page":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","title":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","text":"function (f::BeelerReuterGpu)(du, u, p, t)\n    L = 16   # block size\n    Δt = t - f.t\n    copyto!(f.d_u, u)\n    ny, nx = size(u)\n\n    if Δt != 0 || t == 0\n        @cuda blocks=(ny÷L,nx÷L) threads=(L,L) update_gates_gpu(\n            f.d_u, f.d_XI, f.d_M, f.d_H, f.d_J, f.d_D, f.d_F, f.d_C, Δt)\n        f.t = t\n    end\n\n    laplacian(f.Δv, u)\n\n    # calculate the reaction portion\n    @cuda blocks=(ny÷L,nx÷L) threads=(L,L) update_du_gpu(\n        f.d_du, f.d_u, f.d_XI, f.d_M, f.d_H, f.d_J, f.d_D, f.d_F, f.d_C)\n\n    copyto!(du, f.d_du)\n\n    # ...add the diffusion portion\n    du .+= f.diff_coef .* f.Δv\nend","category":"page"},{"location":"advanced/01-beeler_reuter/","page":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","title":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","text":"Ready to test!","category":"page"},{"location":"advanced/01-beeler_reuter/","page":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","title":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","text":"using DifferentialEquations, Sundials\n\nderiv_gpu = BeelerReuterGpu(u0, 1.0);\nprob = ODEProblem(deriv_gpu, u0, (0.0, 50.0));\n@time sol = solve(prob, CVODE_BDF(linear_solver=:GMRES), saveat=100.0);","category":"page"},{"location":"advanced/01-beeler_reuter/","page":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","title":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","text":"Error: CUDA.jl did not successfully initialize, and is not usable.\nIf you did not see any other error message, try again in a new session\nwith the JULIA_DEBUG environment variable set to 'CUDA'.","category":"page"},{"location":"advanced/01-beeler_reuter/","page":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","title":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","text":"heatmap(sol.u[end])","category":"page"},{"location":"advanced/01-beeler_reuter/","page":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","title":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","text":"(Image: )","category":"page"},{"location":"advanced/01-beeler_reuter/#Summary","page":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","title":"Summary","text":"","category":"section"},{"location":"advanced/01-beeler_reuter/","page":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","title":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","text":"We achieve around a 6x speedup with running the explicit portion of our IMEX solver on a GPU. The major bottleneck of this technique is the communication between CPU and GPU. In its current form, not all of the internals of the method utilize GPU acceleration. In particular, the implicit equations solved by GMRES are performed on the CPU. This partial CPU nature also increases the amount of data transfer that is required between the GPU and CPU (performed every f call). Compiling the full ODE solver to the GPU would solve both of these issues and potentially give a much larger speedup. JuliaDiffEq developers are currently working on solutions to alleviate these issues, but these will only be compatible with native Julia solvers (and not Sundials).","category":"page"},{"location":"advanced/01-beeler_reuter/#Appendix","page":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","title":"Appendix","text":"","category":"section"},{"location":"advanced/01-beeler_reuter/","page":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","title":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","text":"These tutorials are a part of the SciMLTutorials.jl repository, found at: https://github.com/SciML/SciMLTutorials.jl. For more information on high-performance scientific machine learning, check out the SciML Open Source Software Organization https://sciml.ai.","category":"page"},{"location":"advanced/01-beeler_reuter/","page":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","title":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","text":"To locally run this tutorial, do the following commands:","category":"page"},{"location":"advanced/01-beeler_reuter/","page":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","title":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","text":"using SciMLTutorials\nSciMLTutorials.weave_file(\"tutorials/advanced\",\"01-beeler_reuter.jmd\")","category":"page"},{"location":"advanced/01-beeler_reuter/","page":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","title":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","text":"Computer Information:","category":"page"},{"location":"advanced/01-beeler_reuter/","page":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","title":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","text":"Julia Version 1.6.2\nCommit 1b93d53fc4 (2021-07-14 15:36 UTC)\nPlatform Info:\n  OS: Linux (x86_64-pc-linux-gnu)\n  CPU: AMD EPYC 7502 32-Core Processor\n  WORD_SIZE: 64\n  LIBM: libopenlibm\n  LLVM: libLLVM-11.0.1 (ORCJIT, znver2)\nEnvironment:\n  JULIA_DEPOT_PATH = /root/.cache/julia-buildkite-plugin/depots/a6029d3a-f78b-41ea-bc97-28aa57c6c6ea\n  JULIA_NUM_THREADS = 16\n","category":"page"},{"location":"advanced/01-beeler_reuter/","page":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","title":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","text":"Package Information:","category":"page"},{"location":"advanced/01-beeler_reuter/","page":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","title":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","text":"      Status `/var/lib/buildkite-agent/builds/8-amdci4-julia-csail-mit-edu/julialang/scimltutorials-dot-jl/tutorials/advanced/Project.toml`\n  [2169fc97] AlgebraicMultigrid v0.4.0\n  [6e4b80f9] BenchmarkTools v1.0.0\n  [052768ef] CUDA v2.6.3\n  [2b5f629d] DiffEqBase v6.62.2\n  [9fdde737] DiffEqOperators v4.26.0\n  [0c46a032] DifferentialEquations v6.17.1\n  [587475ba] Flux v0.12.1\n  [961ee093] ModelingToolkit v5.17.3\n  [2774e3e8] NLsolve v4.5.1\n  [315f7962] NeuralPDE v3.10.1\n  [1dea7af3] OrdinaryDiffEq v5.56.0\n  [91a5bcdd] Plots v1.15.2\n  [0bca4576] SciMLBase v1.13.4\n  [30cb0354] SciMLTutorials v0.9.0\n  [47a9eef4] SparseDiffTools v1.13.2\n  [684fba80] SparsityDetection v0.3.4\n  [789caeaf] StochasticDiffEq v6.34.1\n  [c3572dad] Sundials v4.4.3\n  [37e2e46d] LinearAlgebra\n  [2f01184e] SparseArrays","category":"page"},{"location":"advanced/01-beeler_reuter/","page":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","title":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","text":"And the full manifest:","category":"page"},{"location":"advanced/01-beeler_reuter/","page":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","title":"An Implicit/Explicit CUDA-Accelerated Solver for the 2D Beeler-Reuter Model","text":"      Status `/var/lib/buildkite-agent/builds/8-amdci4-julia-csail-mit-edu/julialang/scimltutorials-dot-jl/tutorials/advanced/Manifest.toml`\n  [c3fe647b] AbstractAlgebra v0.16.0\n  [621f4979] AbstractFFTs v1.0.1\n  [1520ce14] AbstractTrees v0.3.4\n  [79e6a3ab] Adapt v3.3.0\n  [2169fc97] AlgebraicMultigrid v0.4.0\n  [ec485272] ArnoldiMethod v0.1.0\n  [4fba245c] ArrayInterface v3.1.15\n  [4c555306] ArrayLayouts v0.7.0\n  [13072b0f] AxisAlgorithms v1.0.0\n  [ab4f0b2a] BFloat16s v0.1.0\n  [aae01518] BandedMatrices v0.16.9\n  [6e4b80f9] BenchmarkTools v1.0.0\n  [8e7c35d0] BlockArrays v0.15.3\n  [ffab5731] BlockBandedMatrices v0.10.6\n  [764a87c0] BoundaryValueDiffEq v2.7.1\n  [fa961155] CEnum v0.4.1\n  [00ebfdb7] CSTParser v2.5.0\n  [052768ef] CUDA v2.6.3\n  [7057c7e9] Cassette v0.3.6\n  [082447d4] ChainRules v0.7.65\n  [d360d2e6] ChainRulesCore v0.9.44\n  [b630d9fa] CheapThreads v0.2.5\n  [944b1d66] CodecZlib v0.7.0\n  [35d6a980] ColorSchemes v3.12.1\n  [3da002f7] ColorTypes v0.11.0\n  [5ae59095] Colors v0.12.8\n  [861a8166] Combinatorics v1.0.2\n  [a80b9123] CommonMark v0.8.1\n  [38540f10] CommonSolve v0.2.0\n  [bbf7d656] CommonSubexpressions v0.3.0\n  [34da2185] Compat v3.30.0\n  [aa819f21] CompatHelper v1.18.6\n  [8f4d0f93] Conda v1.5.2\n  [88cd18e8] ConsoleProgressMonitor v0.1.2\n  [187b0558] ConstructionBase v1.2.1\n  [d38c429a] Contour v0.5.7\n  [a8cc5b0e] Crayons v4.0.4\n  [8a292aeb] Cuba v2.2.0\n  [667455a9] Cubature v1.5.1\n  [9a962f9c] DataAPI v1.6.0\n  [82cc6244] DataInterpolations v3.3.1\n  [864edb3b] DataStructures v0.18.9\n  [e2d170a0] DataValueInterfaces v1.0.0\n  [bcd4f6db] DelayDiffEq v5.31.0\n  [2b5f629d] DiffEqBase v6.62.2\n  [459566f4] DiffEqCallbacks v2.16.1\n  [5a0ffddc] DiffEqFinancial v2.4.0\n  [aae7a2af] DiffEqFlux v1.37.0\n  [c894b116] DiffEqJump v6.14.2\n  [77a26b50] DiffEqNoiseProcess v5.7.3\n  [9fdde737] DiffEqOperators v4.26.0\n  [055956cb] DiffEqPhysics v3.9.0\n  [41bf760c] DiffEqSensitivity v6.45.0\n  [163ba53b] DiffResults v1.0.3\n  [b552c78f] DiffRules v1.0.2\n  [0c46a032] DifferentialEquations v6.17.1\n  [c619ae07] DimensionalPlotRecipes v1.2.0\n  [b4f34e82] Distances v0.10.3\n  [31c24e10] Distributions v0.24.18\n  [ced4e74d] DistributionsAD v0.6.26\n  [ffbed154] DocStringExtensions v0.8.4\n  [e30172f5] Documenter v0.26.3\n  [d4d017d3] ExponentialUtilities v1.8.4\n  [e2ba6199] ExprTools v0.1.3\n  [8f5d6c58] EzXML v1.1.0\n  [c87230d0] FFMPEG v0.4.0\n  [7a1cc6ca] FFTW v1.4.1\n  [7034ab61] FastBroadcast v0.1.8\n  [9aa1b823] FastClosures v0.3.2\n  [1a297f60] FillArrays v0.11.7\n  [6a86dc24] FiniteDiff v2.8.0\n  [53c48c17] FixedPointNumbers v0.8.4\n  [587475ba] Flux v0.12.1\n  [59287772] Formatting v0.4.2\n  [f6369f11] ForwardDiff v0.10.18\n  [069b7b12] FunctionWrappers v1.1.2\n  [d9f16b24] Functors v0.2.1\n  [0c68f7d7] GPUArrays v6.4.1\n  [61eb1bfa] GPUCompiler v0.10.0\n  [28b8d3ca] GR v0.57.4\n  [a75be94c] GalacticOptim v1.2.0\n  [5c1252a2] GeometryBasics v0.3.12\n  [bc5e4493] GitHub v5.4.0\n  [af5da776] GlobalSensitivity v1.0.0\n  [42e2da0e] Grisu v1.0.2\n  [19dc6840] HCubature v1.5.0\n  [cd3eb016] HTTP v0.9.9\n  [eafb193a] Highlights v0.4.5\n  [0e44f5e4] Hwloc v2.0.0\n  [7073ff75] IJulia v1.23.2\n  [b5f81e59] IOCapture v0.1.1\n  [7869d1d1] IRTools v0.4.2\n  [615f187c] IfElse v0.1.0\n  [d25df0c9] Inflate v0.1.2\n  [83e8ac13] IniFile v0.5.0\n  [a98d9a8b] Interpolations v0.13.2\n  [c8e1da08] IterTools v1.3.0\n  [42fd0dbc] IterativeSolvers v0.9.1\n  [82899510] IteratorInterfaceExtensions v1.0.0\n  [692b3bcd] JLLWrappers v1.3.0\n  [682c06a0] JSON v0.21.1\n  [98e50ef6] JuliaFormatter v0.13.7\n  [e5e0dc1b] Juno v0.8.4\n  [5ab0869b] KernelDensity v0.6.3\n  [929cbde3] LLVM v3.7.1\n  [b964fa9f] LaTeXStrings v1.2.1\n  [2ee39098] LabelledArrays v1.6.1\n  [23fbe1c1] Latexify v0.15.5\n  [a5e1c1ea] LatinHypercubeSampling v1.8.0\n  [73f95e8e] LatticeRules v0.0.1\n  [5078a376] LazyArrays v0.21.4\n  [d7e5e226] LazyBandedMatrices v0.5.7\n  [1d6d02ad] LeftChildRightSiblingTrees v0.1.2\n  [093fc24a] LightGraphs v1.3.5\n  [d3d80556] LineSearches v7.1.1\n  [2ab3a3ac] LogExpFunctions v0.2.4\n  [e6f89c97] LoggingExtras v0.4.6\n  [bdcacae8] LoopVectorization v0.12.23\n  [1914dd2f] MacroTools v0.5.6\n  [a3b82374] MatrixFactorizations v0.8.3\n  [739be429] MbedTLS v1.0.3\n  [442fdcdd] Measures v0.3.1\n  [e89f7d12] Media v0.5.0\n  [c03570c3] Memoize v0.4.4\n  [e1d29d7a] Missings v1.0.0\n  [78c3b35d] Mocking v0.7.1\n  [961ee093] ModelingToolkit v5.17.3\n  [4886b29c] MonteCarloIntegration v0.0.2\n  [46d2c3a1] MuladdMacro v0.2.2\n  [f9640e96] MultiScaleArrays v1.8.1\n  [ffc61752] Mustache v1.0.10\n  [d41bc354] NLSolversBase v7.8.0\n  [2774e3e8] NLsolve v4.5.1\n  [872c559c] NNlib v0.7.19\n  [77ba4419] NaNMath v0.3.5\n  [315f7962] NeuralPDE v3.10.1\n  [8913a72c] NonlinearSolve v0.3.8\n  [6fe1bfb0] OffsetArrays v1.9.0\n  [429524aa] Optim v1.3.0\n  [bac558e1] OrderedCollections v1.4.1\n  [1dea7af3] OrdinaryDiffEq v5.56.0\n  [90014a1f] PDMats v0.11.0\n  [65888b18] ParameterizedFunctions v5.10.0\n  [d96e819e] Parameters v0.12.2\n  [69de0a69] Parsers v1.1.0\n  [ccf2f8ad] PlotThemes v2.0.1\n  [995b91a9] PlotUtils v1.0.10\n  [91a5bcdd] Plots v1.15.2\n  [e409e4f3] PoissonRandom v0.4.0\n  [f517fe37] Polyester v0.3.1\n  [85a6dd25] PositiveFactorizations v0.2.4\n  [21216c6a] Preferences v1.2.2\n  [33c8b6b6] ProgressLogging v0.1.4\n  [92933f4c] ProgressMeter v1.6.2\n  [1fd47b50] QuadGK v2.4.1\n  [67601950] Quadrature v1.8.1\n  [8a4e6c94] QuasiMonteCarlo v0.2.2\n  [74087812] Random123 v1.3.1\n  [fb686558] RandomExtensions v0.4.3\n  [e6cf234a] RandomNumbers v1.4.0\n  [c84ed2f1] Ratios v0.4.0\n  [3cdcf5f2] RecipesBase v1.1.1\n  [01d81517] RecipesPipeline v0.3.2\n  [731186ca] RecursiveArrayTools v2.11.4\n  [f2c3362d] RecursiveFactorization v0.1.12\n  [189a3867] Reexport v1.0.0\n  [ae029012] Requires v1.1.3\n  [ae5879a3] ResettableStacks v1.1.0\n  [37e2e3b7] ReverseDiff v1.9.0\n  [79098fc4] Rmath v0.7.0\n  [7e49a35a] RuntimeGeneratedFunctions v0.5.2\n  [476501e8] SLEEFPirates v0.6.20\n  [1bc83da4] SafeTestsets v0.0.1\n  [0bca4576] SciMLBase v1.13.4\n  [30cb0354] SciMLTutorials v0.9.0\n  [6c6a2e73] Scratch v1.0.3\n  [efcf1570] Setfield v0.7.0\n  [992d4aef] Showoff v1.0.3\n  [699a6c99] SimpleTraits v0.9.3\n  [ed01d8cd] Sobol v1.5.0\n  [2133526b] SodiumSeal v0.1.1\n  [b85f4697] SoftGlobalScope v1.1.0\n  [a2af1166] SortingAlgorithms v1.0.0\n  [47a9eef4] SparseDiffTools v1.13.2\n  [684fba80] SparsityDetection v0.3.4\n  [276daf66] SpecialFunctions v1.4.1\n  [860ef19b] StableRNGs v1.0.0\n  [aedffcd0] Static v0.2.4\n  [90137ffa] StaticArrays v1.2.0\n  [82ae8749] StatsAPI v1.0.0\n  [2913bbd2] StatsBase v0.33.8\n  [4c63d2b9] StatsFuns v0.9.8\n  [9672c7b4] SteadyStateDiffEq v1.6.2\n  [789caeaf] StochasticDiffEq v6.34.1\n  [7792a7ef] StrideArraysCore v0.1.11\n  [09ab397b] StructArrays v0.5.1\n  [c3572dad] Sundials v4.4.3\n  [d1185830] SymbolicUtils v0.11.2\n  [0c5d862f] Symbolics v0.1.25\n  [3783bdb8] TableTraits v1.0.1\n  [bd369af6] Tables v1.4.2\n  [5d786b92] TerminalLoggers v0.1.3\n  [8290d209] ThreadingUtilities v0.4.4\n  [f269a46b] TimeZones v1.5.5\n  [a759f4b9] TimerOutputs v0.5.9\n  [0796e94c] Tokenize v0.5.16\n  [9f7883ad] Tracker v0.2.16\n  [3bb67fe8] TranscodingStreams v0.9.5\n  [592b5752] Trapz v2.0.2\n  [a2a6695c] TreeViews v0.3.0\n  [5c2747f8] URIs v1.3.0\n  [3a884ed6] UnPack v1.0.2\n  [1986cc42] Unitful v1.7.0\n  [3d5dd08c] VectorizationBase v0.20.11\n  [81def892] VersionParsing v1.2.0\n  [19fa3120] VertexSafeGraphs v0.1.2\n  [44d3d7a6] Weave v0.10.8\n  [efce3f68] WoodburyMatrices v0.5.3\n  [ddb6d928] YAML v0.4.6\n  [c2297ded] ZMQ v1.2.1\n  [a5390f91] ZipFile v0.9.3\n  [e88e6eb3] Zygote v0.6.11\n  [700de1a5] ZygoteRules v0.2.1\n  [6e34b625] Bzip2_jll v1.0.6+5\n  [83423d85] Cairo_jll v1.16.0+6\n  [3bed1096] Cuba_jll v4.2.1+0\n  [7bc98958] Cubature_jll v1.0.4+0\n  [5ae413db] EarCut_jll v2.1.5+1\n  [2e619515] Expat_jll v2.2.10+0\n  [b22a6f82] FFMPEG_jll v4.3.1+4\n  [f5851436] FFTW_jll v3.3.9+7\n  [a3f928ae] Fontconfig_jll v2.13.1+14\n  [d7e528f0] FreeType2_jll v2.10.1+5\n  [559328eb] FriBidi_jll v1.0.5+6\n  [0656b61e] GLFW_jll v3.3.4+0\n  [d2c73de3] GR_jll v0.57.2+0\n  [78b55507] Gettext_jll v0.21.0+0\n  [7746bdde] Glib_jll v2.68.1+0\n  [e33a78d0] Hwloc_jll v2.4.1+0\n  [1d5cc7b8] IntelOpenMP_jll v2018.0.3+2\n  [aacddb02] JpegTurbo_jll v2.0.1+3\n  [c1c5ebd0] LAME_jll v3.100.0+3\n  [dd4b983a] LZO_jll v2.10.1+0\n  [dd192d2f] LibVPX_jll v1.9.0+1\n  [e9f186c6] Libffi_jll v3.2.2+0\n  [d4300ac3] Libgcrypt_jll v1.8.7+0\n  [7e76a0d4] Libglvnd_jll v1.3.0+3\n  [7add5ba3] Libgpg_error_jll v1.42.0+0\n  [94ce4f54] Libiconv_jll v1.16.1+0\n  [4b2f31a3] Libmount_jll v2.35.0+0\n  [89763e89] Libtiff_jll v4.1.0+2\n  [38a345b3] Libuuid_jll v2.36.0+0\n  [856f044c] MKL_jll v2021.1.1+1\n  [e7412a2a] Ogg_jll v1.3.4+2\n  [458c3c95] OpenSSL_jll v1.1.1+6\n  [efe28fd5] OpenSpecFun_jll v0.5.4+0\n  [91d4177d] Opus_jll v1.3.1+3\n  [2f80f16e] PCRE_jll v8.44.0+0\n  [30392449] Pixman_jll v0.40.1+0\n  [ea2cea3b] Qt5Base_jll v5.15.2+0\n  [f50d1b31] Rmath_jll v0.3.0+0\n  [fb77eaff] Sundials_jll v5.2.0+1\n  [a2964d1f] Wayland_jll v1.17.0+4\n  [2381bf8a] Wayland_protocols_jll v1.18.0+4\n  [02c8fc9c] XML2_jll v2.9.12+0\n  [aed1982a] XSLT_jll v1.1.34+0\n  [4f6342f7] Xorg_libX11_jll v1.6.9+4\n  [0c0b7dd1] Xorg_libXau_jll v1.0.9+4\n  [935fb764] Xorg_libXcursor_jll v1.2.0+4\n  [a3789734] Xorg_libXdmcp_jll v1.1.3+4\n  [1082639a] Xorg_libXext_jll v1.3.4+4\n  [d091e8ba] Xorg_libXfixes_jll v5.0.3+4\n  [a51aa0fd] Xorg_libXi_jll v1.7.10+4\n  [d1454406] Xorg_libXinerama_jll v1.1.4+4\n  [ec84b674] Xorg_libXrandr_jll v1.5.2+4\n  [ea2f1a96] Xorg_libXrender_jll v0.9.10+4\n  [14d82f49] Xorg_libpthread_stubs_jll v0.1.0+3\n  [c7cfdc94] Xorg_libxcb_jll v1.13.0+3\n  [cc61e674] Xorg_libxkbfile_jll v1.1.0+4\n  [12413925] Xorg_xcb_util_image_jll v0.4.0+1\n  [2def613f] Xorg_xcb_util_jll v0.4.0+1\n  [975044d2] Xorg_xcb_util_keysyms_jll v0.4.0+1\n  [0d47668e] Xorg_xcb_util_renderutil_jll v0.3.9+1\n  [c22f9ab0] Xorg_xcb_util_wm_jll v0.4.1+1\n  [35661453] Xorg_xkbcomp_jll v1.4.2+4\n  [33bec58e] Xorg_xkeyboard_config_jll v2.27.0+4\n  [c5fb5394] Xorg_xtrans_jll v1.4.0+3\n  [8f1865be] ZeroMQ_jll v4.3.2+6\n  [3161d3a3] Zstd_jll v1.5.0+0\n  [0ac62f75] libass_jll v0.14.0+4\n  [f638f0a6] libfdk_aac_jll v0.1.6+4\n  [b53b4c65] libpng_jll v1.6.38+0\n  [a9144af2] libsodium_jll v1.0.20+0\n  [f27f6e37] libvorbis_jll v1.3.6+6\n  [1270edf5] x264_jll v2020.7.14+2\n  [dfaa095f] x265_jll v3.0.0+3\n  [d8fb68d0] xkbcommon_jll v0.9.1+5\n  [0dad84c5] ArgTools\n  [56f22d72] Artifacts\n  [2a0f44e3] Base64\n  [ade2ca70] Dates\n  [8bb1440f] DelimitedFiles\n  [8ba89e20] Distributed\n  [f43a241f] Downloads\n  [7b1f6079] FileWatching\n  [9fa8497b] Future\n  [b77e0a4c] InteractiveUtils\n  [4af54fe1] LazyArtifacts\n  [b27032c2] LibCURL\n  [76f85450] LibGit2\n  [8f399da3] Libdl\n  [37e2e46d] LinearAlgebra\n  [56ddb016] Logging\n  [d6f4376e] Markdown\n  [a63ad114] Mmap\n  [ca575930] NetworkOptions\n  [44cfe95a] Pkg\n  [de0858da] Printf\n  [9abbd945] Profile\n  [3fa0cd96] REPL\n  [9a3f8284] Random\n  [ea8e919c] SHA\n  [9e88b42a] Serialization\n  [1a1011a3] SharedArrays\n  [6462fe0b] Sockets\n  [2f01184e] SparseArrays\n  [10745b16] Statistics\n  [4607b0f0] SuiteSparse\n  [fa267f1f] TOML\n  [a4e569a6] Tar\n  [8dfed614] Test\n  [cf7118a7] UUIDs\n  [4ec0a83e] Unicode\n  [e66e0078] CompilerSupportLibraries_jll\n  [deac9b47] LibCURL_jll\n  [29816b5a] LibSSH2_jll\n  [c8ffd9c3] MbedTLS_jll\n  [14a3606d] MozillaCACerts_jll\n  [4536629a] OpenBLAS_jll\n  [bea87d4a] SuiteSparse_jll\n  [83775a58] Zlib_jll\n  [8e850ede] nghttp2_jll\n  [3f19e933] p7zip_jll","category":"page"},{"location":"jumps/spatial/#Tutorial-on-using-spatial-SSAs-in-DiffEqJump","page":"Tutorial on using spatial SSAs in DiffEqJump","title":"Tutorial on using spatial SSAs in DiffEqJump","text":"","category":"section"},{"location":"jumps/spatial/","page":"Tutorial on using spatial SSAs in DiffEqJump","title":"Tutorial on using spatial SSAs in DiffEqJump","text":"This tutorial shows how to use spatial solvers added to DiffEqJump in summer 2021. See the documentation for a tutorial on getting started with DiffEqJump.","category":"page"},{"location":"jumps/spatial/#Installing-DiffEqJump","page":"Tutorial on using spatial SSAs in DiffEqJump","title":"Installing DiffEqJump","text":"","category":"section"},{"location":"jumps/spatial/","page":"Tutorial on using spatial SSAs in DiffEqJump","title":"Tutorial on using spatial SSAs in DiffEqJump","text":"Once in REPL, do ] add DiffEqJump. After the installation finishes, you will be able to use all the functionality described below.","category":"page"},{"location":"jumps/spatial/#Reversible-binding-model-on-a-grid","page":"Tutorial on using spatial SSAs in DiffEqJump","title":"Reversible binding model on a grid","text":"","category":"section"},{"location":"jumps/spatial/","page":"Tutorial on using spatial SSAs in DiffEqJump","title":"Tutorial on using spatial SSAs in DiffEqJump","text":"A 5 by 5 Cartesian grid:","category":"page"},{"location":"jumps/spatial/","page":"Tutorial on using spatial SSAs in DiffEqJump","title":"Tutorial on using spatial SSAs in DiffEqJump","text":"<!– –> <!– –> <!– –> <!– –> <!– –>\n. . . . B\n. . . . .\n. . . . .\n. . . . .\nA . . . .","category":"page"},{"location":"jumps/spatial/","page":"Tutorial on using spatial SSAs in DiffEqJump","title":"Tutorial on using spatial SSAs in DiffEqJump","text":"Suppose we have a reversible binding system described by A+B to C at rate k_1 and C to A+B at rate k_2. Further suppose that all A molecules start in the lower left corner, while all B molecules start in the upper right corner of a 5 by 5 grid. There are no C molecules at the start.","category":"page"},{"location":"jumps/spatial/","page":"Tutorial on using spatial SSAs in DiffEqJump","title":"Tutorial on using spatial SSAs in DiffEqJump","text":"We first create the grid:","category":"page"},{"location":"jumps/spatial/","page":"Tutorial on using spatial SSAs in DiffEqJump","title":"Tutorial on using spatial SSAs in DiffEqJump","text":"using DiffEqJump\ndims = (5,5)\nnum_nodes = prod(dims) # number of sites\ngrid = CartesianGrid(dims) # or use LightGraphs.grid(dims)","category":"page"},{"location":"jumps/spatial/","page":"Tutorial on using spatial SSAs in DiffEqJump","title":"Tutorial on using spatial SSAs in DiffEqJump","text":"A Cartesian grid with dimensions (5, 5)","category":"page"},{"location":"jumps/spatial/","page":"Tutorial on using spatial SSAs in DiffEqJump","title":"Tutorial on using spatial SSAs in DiffEqJump","text":"Now we set the initial state of the simulation. It has to be a matrix with entry (si) being the number of species s at site i (with the standard column-major ordering of the grid).","category":"page"},{"location":"jumps/spatial/","page":"Tutorial on using spatial SSAs in DiffEqJump","title":"Tutorial on using spatial SSAs in DiffEqJump","text":"num_species = 3\nstarting_state = zeros(Int, num_species, num_nodes)\nstarting_state[1,1] = 25\nstarting_state[2,end] = 25\nstarting_state","category":"page"},{"location":"jumps/spatial/","page":"Tutorial on using spatial SSAs in DiffEqJump","title":"Tutorial on using spatial SSAs in DiffEqJump","text":"3×25 Matrix{Int64}:\n 25  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0\n0\n  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  2\n5\n  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0\n0","category":"page"},{"location":"jumps/spatial/","page":"Tutorial on using spatial SSAs in DiffEqJump","title":"Tutorial on using spatial SSAs in DiffEqJump","text":"We now set the time-span of the simulation and the reaction rates. These can be chosen arbitrarily.","category":"page"},{"location":"jumps/spatial/","page":"Tutorial on using spatial SSAs in DiffEqJump","title":"Tutorial on using spatial SSAs in DiffEqJump","text":"tspan = (0.0, 3.0)\nrates = [6.0, 0.05] # k_1 = rates[1], k_2 = rates[2]","category":"page"},{"location":"jumps/spatial/","page":"Tutorial on using spatial SSAs in DiffEqJump","title":"Tutorial on using spatial SSAs in DiffEqJump","text":"2-element Vector{Float64}:\n 6.0\n 0.05","category":"page"},{"location":"jumps/spatial/","page":"Tutorial on using spatial SSAs in DiffEqJump","title":"Tutorial on using spatial SSAs in DiffEqJump","text":"Now we can create the DiscreteProblem:","category":"page"},{"location":"jumps/spatial/","page":"Tutorial on using spatial SSAs in DiffEqJump","title":"Tutorial on using spatial SSAs in DiffEqJump","text":"prob = DiscreteProblem(starting_state, tspan, rates)","category":"page"},{"location":"jumps/spatial/","page":"Tutorial on using spatial SSAs in DiffEqJump","title":"Tutorial on using spatial SSAs in DiffEqJump","text":"DiscreteProblem with uType Matrix{Int64} and tType Float64. In-place: true\ntimespan: (0.0, 3.0)\nu0: 3×25 Matrix{Int64}:\n 25  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0\n0\n  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  2\n5\n  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0\n0","category":"page"},{"location":"jumps/spatial/","page":"Tutorial on using spatial SSAs in DiffEqJump","title":"Tutorial on using spatial SSAs in DiffEqJump","text":"Since both reactions are massaction reactions, we put them together in a MassActionJump. In order to do that we create two stoichiometry vectors. The net stoichiometry vector describes which molecules change in number and how much after each reaction; for example, [1 => -1] is the first molecule disappearing. The reaction stoichiometry vector describes what the reactants of each reaction are; for example, [1 => 1, 2 => 1] would mean that the reactants are one molecule of type 1 and one molecule of type 2.","category":"page"},{"location":"jumps/spatial/","page":"Tutorial on using spatial SSAs in DiffEqJump","title":"Tutorial on using spatial SSAs in DiffEqJump","text":"netstoch = [[1 => -1, 2 => -1, 3 => 1],[1 => 1, 2 => 1, 3 => -1]]\nreactstoch = [[1 => 1, 2 => 1],[3 => 1]]\nmajumps = MassActionJump(rates, reactstoch, netstoch)","category":"page"},{"location":"jumps/spatial/","page":"Tutorial on using spatial SSAs in DiffEqJump","title":"Tutorial on using spatial SSAs in DiffEqJump","text":"DiffEqJump.MassActionJump{Vector{Float64}, Vector{Vector{Pair{Int64, Int64}\n}}, Vector{Vector{Pair{Int64, Int64}}}, Nothing}([6.0, 0.05], [[1 => 1, 2 =\n> 1], [3 => 1]], [[1 => -1, 2 => -1, 3 => 1], [1 => 1, 2 => 1, 3 => -1]], n\nothing)","category":"page"},{"location":"jumps/spatial/","page":"Tutorial on using spatial SSAs in DiffEqJump","title":"Tutorial on using spatial SSAs in DiffEqJump","text":"The last thing to set up is the hopping constants – the probability per time of an individual molecule of each species hopping from one site to another site. In practice this parameter, as well as reaction rates, are obtained empirically. Suppose that molecule C cannot diffuse, while molecules A and B diffuse at probability per time 1 (i.e. the time of the diffusive hop is exponentially distributed with mean 1). Entry (si) of hopping_constants is the hopping rate of species s at site i to any of its neighboring sites (diagonal hops are not allowed).","category":"page"},{"location":"jumps/spatial/","page":"Tutorial on using spatial SSAs in DiffEqJump","title":"Tutorial on using spatial SSAs in DiffEqJump","text":"hopping_constants = ones(num_species, num_nodes)\nhopping_constants[3, :] .= 0.0\nhopping_constants","category":"page"},{"location":"jumps/spatial/","page":"Tutorial on using spatial SSAs in DiffEqJump","title":"Tutorial on using spatial SSAs in DiffEqJump","text":"3×25 Matrix{Float64}:\n 1.0  1.0  1.0  1.0  1.0  1.0  1.0  1.0  …  1.0  1.0  1.0  1.0  1.0  1.0  1\n.0\n 1.0  1.0  1.0  1.0  1.0  1.0  1.0  1.0     1.0  1.0  1.0  1.0  1.0  1.0  1\n.0\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0  0\n.0","category":"page"},{"location":"jumps/spatial/","page":"Tutorial on using spatial SSAs in DiffEqJump","title":"Tutorial on using spatial SSAs in DiffEqJump","text":"We are now ready to set up the JumpProblem with the Next Subvolume Method.","category":"page"},{"location":"jumps/spatial/","page":"Tutorial on using spatial SSAs in DiffEqJump","title":"Tutorial on using spatial SSAs in DiffEqJump","text":"alg = NSM()\njump_prob = JumpProblem(prob, alg, majumps, hopping_constants=hopping_constants, spatial_system = grid, save_positions=(true, false))","category":"page"},{"location":"jumps/spatial/","page":"Tutorial on using spatial SSAs in DiffEqJump","title":"Tutorial on using spatial SSAs in DiffEqJump","text":"Number of constant rate jumps: 0\nNumber of variable rate jumps: 0\nHave a mass action jump","category":"page"},{"location":"jumps/spatial/","page":"Tutorial on using spatial SSAs in DiffEqJump","title":"Tutorial on using spatial SSAs in DiffEqJump","text":"The save_positions keyword tells the solver to save the positions just before the jumps. To solve the jump problem do","category":"page"},{"location":"jumps/spatial/","page":"Tutorial on using spatial SSAs in DiffEqJump","title":"Tutorial on using spatial SSAs in DiffEqJump","text":"solution = solve(jump_prob, SSAStepper())","category":"page"},{"location":"jumps/spatial/","page":"Tutorial on using spatial SSAs in DiffEqJump","title":"Tutorial on using spatial SSAs in DiffEqJump","text":"retcode: Default\nInterpolation: Piecewise constant interpolation\nt: 401-element Vector{Float64}:\n 0.0\n 0.01805156477589096\n 0.021927208873289517\n 0.025769109693334135\n 0.03515984244149274\n 0.041941982193058974\n 0.052156972679011\n 0.07268000778197724\n 0.08516521051878839\n 0.09139750379283877\n ⋮\n 2.959136931928465\n 2.9646237117842693\n 2.9651086896415113\n 2.9728489281258383\n 2.9739124562005443\n 2.9757635813669086\n 2.9813576277964904\n 2.994984074931063\n 3.0\nu: 401-element Vector{Matrix{Int64}}:\n [25 0 … 0 0; 0 0 … 0 25; 0 0 … 0 0]\n [24 1 … 0 0; 0 0 … 0 25; 0 0 … 0 0]\n [24 0 … 0 0; 0 0 … 0 25; 0 0 … 0 0]\n [24 0 … 0 0; 0 0 … 0 24; 0 0 … 0 0]\n [24 0 … 0 0; 0 0 … 0 23; 0 0 … 0 0]\n [24 0 … 0 0; 0 0 … 0 22; 0 0 … 0 0]\n [23 1 … 0 0; 0 0 … 0 22; 0 0 … 0 0]\n [22 2 … 0 0; 0 0 … 0 22; 0 0 … 0 0]\n [22 2 … 0 0; 0 0 … 0 23; 0 0 … 0 0]\n [21 2 … 0 0; 0 0 … 0 23; 0 0 … 0 0]\n ⋮\n [1 4 … 0 0; 0 0 … 1 0; 0 0 … 0 0]\n [1 4 … 0 0; 0 0 … 1 0; 0 0 … 0 0]\n [2 3 … 0 0; 0 0 … 1 0; 0 0 … 0 0]\n [2 3 … 0 0; 0 0 … 2 0; 0 0 … 0 0]\n [2 3 … 0 0; 0 0 … 2 0; 0 0 … 0 0]\n [2 3 … 0 0; 0 0 … 2 0; 0 0 … 0 0]\n [2 3 … 0 0; 0 0 … 2 1; 0 0 … 0 0]\n [2 2 … 0 0; 0 0 … 2 1; 0 0 … 0 0]\n [2 2 … 0 0; 0 0 … 2 1; 0 0 … 0 0]","category":"page"},{"location":"jumps/spatial/#Animation","page":"Tutorial on using spatial SSAs in DiffEqJump","title":"Animation","text":"","category":"section"},{"location":"jumps/spatial/","page":"Tutorial on using spatial SSAs in DiffEqJump","title":"Tutorial on using spatial SSAs in DiffEqJump","text":"Visualizing solutions of spatial jump problems is best done with animations.","category":"page"},{"location":"jumps/spatial/","page":"Tutorial on using spatial SSAs in DiffEqJump","title":"Tutorial on using spatial SSAs in DiffEqJump","text":"using Plots\nis_static(spec) = (spec == 3) # true if spec does not hop\n\"get frame k\"\nfunction get_frame(k, sol, linear_size, labels, title)\n    num_species = length(labels)\n    h = 1/linear_size\n    t = sol.t[k]\n    state = sol.u[k]\n    xlim=(0,1+3h/2); ylim=(0,1+3h/2);\n    plt = plot(xlim=xlim, ylim=ylim, title = \"$title, $(round(t, sigdigits=3)) seconds\")\n\n    species_seriess_x = [[] for i in 1:num_species]\n    species_seriess_y = [[] for i in 1:num_species]\n    CI = CartesianIndices((linear_size, linear_size))\n    for ci in CartesianIndices(state)\n        species, site = Tuple(ci)\n        x,y = Tuple(CI[site])\n        num_molecules = state[ci]\n        sizehint!(species_seriess_x[species], num_molecules)\n        sizehint!(species_seriess_y[species], num_molecules)\n        if !is_static(species)\n            randsx = rand(num_molecules)\n            randsy = rand(num_molecules)\n        else\n            randsx = zeros(num_molecules)\n            randsy = zeros(num_molecules)\n        end\n        for k in 1:num_molecules\n            push!(species_seriess_x[species], x*h - h/4 + 0.5h*randsx[k])\n            push!(species_seriess_y[species], y*h - h/4 + 0.5h*randsy[k])\n        end\n    end\n    for species in 1:num_species\n        scatter!(plt, species_seriess_x[species], species_seriess_y[species], label = labels[species], marker = 6)\n    end\n    xticks!(plt, range(xlim...,length = linear_size+1))\n    yticks!(plt, range(ylim...,length = linear_size+1))\n    xgrid!(plt, 1, 0.7)\n    ygrid!(plt, 1, 0.7)\n    return plt\nend\n\n\"make an animation of solution sol in 2 dimensions\"\nfunction animate_2d(sol, linear_size; species_labels, title, verbose = true)\n    num_frames = length(sol.t)\n    anim = @animate for k=1:num_frames\n        verbose && println(\"Making frame $k\")\n        get_frame(k, sol, linear_size, species_labels, title)\n    end\n    anim\nend\n# animate\nanim=animate_2d(solution, 5, species_labels = [\"A\", \"B\", \"C\"], title = \"A + B <--> C\", verbose = false)\nfps = 5\ngif(anim, fps = fps)","category":"page"},{"location":"jumps/spatial/","page":"Tutorial on using spatial SSAs in DiffEqJump","title":"Tutorial on using spatial SSAs in DiffEqJump","text":"Plots.AnimatedGif(\"/var/lib/buildkite-agent/builds/7-amdci4-julia-csail-mit\n-edu/julialang/scimltutorials-dot-jl/markdown/jumps/tmp.gif\")","category":"page"},{"location":"jumps/spatial/#Making-changes-to-the-model","page":"Tutorial on using spatial SSAs in DiffEqJump","title":"Making changes to the model","text":"","category":"section"},{"location":"jumps/spatial/","page":"Tutorial on using spatial SSAs in DiffEqJump","title":"Tutorial on using spatial SSAs in DiffEqJump","text":"Now suppose we want to make some changes to the reversible binding model above. There are three \"dimensions\" that can be changed: the topology of the system, the structure of hopping rates and the solver. The supported topologies are CartesianGrid – used above, and any AbstractGraph from LightGraphs. The supported forms of hopping rates are D_si D_sij D_s * L_ij, and D_si * L_ij, where s denotes the species, i – the source site, and j – the destination. The supported solvers are NSM, DirectCRDirect and any of the standard non-spatial solvers.","category":"page"},{"location":"jumps/spatial/#Topology","page":"Tutorial on using spatial SSAs in DiffEqJump","title":"Topology","text":"","category":"section"},{"location":"jumps/spatial/","page":"Tutorial on using spatial SSAs in DiffEqJump","title":"Tutorial on using spatial SSAs in DiffEqJump","text":"If our mesh is a grid (1D, 2D and 3D are supported), we can create the mesh as follows.","category":"page"},{"location":"jumps/spatial/","page":"Tutorial on using spatial SSAs in DiffEqJump","title":"Tutorial on using spatial SSAs in DiffEqJump","text":"dims = (2,3,4) # can pass in a 1-Tuple, a 2-Tuple or a 3-Tuple\nnum_nodes = prod(dims)\ngrid = CartesianGrid(dims)","category":"page"},{"location":"jumps/spatial/","page":"Tutorial on using spatial SSAs in DiffEqJump","title":"Tutorial on using spatial SSAs in DiffEqJump","text":"A Cartesian grid with dimensions (2, 3, 4)","category":"page"},{"location":"jumps/spatial/","page":"Tutorial on using spatial SSAs in DiffEqJump","title":"Tutorial on using spatial SSAs in DiffEqJump","text":"The interface is the same as for LightGraphs.grid. If we want to use an unstructured mesh, we can simply use any AbstractGraph from LightGraphs as follows:","category":"page"},{"location":"jumps/spatial/","page":"Tutorial on using spatial SSAs in DiffEqJump","title":"Tutorial on using spatial SSAs in DiffEqJump","text":"using LightGraphs\ngraph = cycle_digraph(5) # directed cyclic graph on 5 nodes","category":"page"},{"location":"jumps/spatial/","page":"Tutorial on using spatial SSAs in DiffEqJump","title":"Tutorial on using spatial SSAs in DiffEqJump","text":"{5, 5} directed simple Int64 graph","category":"page"},{"location":"jumps/spatial/","page":"Tutorial on using spatial SSAs in DiffEqJump","title":"Tutorial on using spatial SSAs in DiffEqJump","text":"Now either graph or grid can be used as spatial_system in creation of the JumpProblem.","category":"page"},{"location":"jumps/spatial/#Hopping-rates","page":"Tutorial on using spatial SSAs in DiffEqJump","title":"Hopping rates","text":"","category":"section"},{"location":"jumps/spatial/","page":"Tutorial on using spatial SSAs in DiffEqJump","title":"Tutorial on using spatial SSAs in DiffEqJump","text":"The most general form of hopping rates that is supported is D_sij – each (species, source, destination) triple gets its own independent hopping rate. To use this, hopping_constants must be of type Matrix{Vector{F}} where F <: Number (usually F is Float64) with hopping_constants[s,i][j] being the hopping rate of species s at site i to neighbor at index j. Note that neighbors are in ascending order, like in LightGraphs. Here is an example where only hopping up and left is allowed.","category":"page"},{"location":"jumps/spatial/","page":"Tutorial on using spatial SSAs in DiffEqJump","title":"Tutorial on using spatial SSAs in DiffEqJump","text":"hopping_constants = Matrix{Vector{Float64}}(undef, num_species, num_nodes)\nfor ci in CartesianIndices(hopping_constants)\n    (species, site) = Tuple(ci)\n    hopping_constants[species, site] = zeros(outdegree(grid, site))\n    for (n, nb) in enumerate(neighbors(grid, site))\n        if nb < site\n            hopping_constants[species, site][n] = 1.0\n        end\n    end\nend","category":"page"},{"location":"jumps/spatial/","page":"Tutorial on using spatial SSAs in DiffEqJump","title":"Tutorial on using spatial SSAs in DiffEqJump","text":"To pass in hopping_constants of form D_s * L_ij we need two vectors – one for D_s and one for L_ij. Here is an example.","category":"page"},{"location":"jumps/spatial/","page":"Tutorial on using spatial SSAs in DiffEqJump","title":"Tutorial on using spatial SSAs in DiffEqJump","text":"species_hop_constants = ones(num_species)\nsite_hop_constants = Vector{Vector{Float64}}(undef, num_nodes)\nfor site in 1:num_nodes\n    site_hop_constants[site] = ones(outdegree(grid, site))\nend\nhopping_constants=Pair(species_hop_constants, site_hop_constants)","category":"page"},{"location":"jumps/spatial/","page":"Tutorial on using spatial SSAs in DiffEqJump","title":"Tutorial on using spatial SSAs in DiffEqJump","text":"[1.0, 1.0, 1.0] => [[1.0, 1.0, 1.0], [1.0, 1.0, 1.0], [1.0, 1.0, 1.0, 1.0],\n [1.0, 1.0, 1.0, 1.0], [1.0, 1.0, 1.0], [1.0, 1.0, 1.0], [1.0, 1.0, 1.0, 1.\n0], [1.0, 1.0, 1.0, 1.0], [1.0, 1.0, 1.0, 1.0, 1.0], [1.0, 1.0, 1.0, 1.0, 1\n.0]  …  [1.0, 1.0, 1.0, 1.0, 1.0], [1.0, 1.0, 1.0, 1.0, 1.0], [1.0, 1.0, 1.\n0, 1.0], [1.0, 1.0, 1.0, 1.0], [1.0, 1.0, 1.0], [1.0, 1.0, 1.0], [1.0, 1.0,\n 1.0, 1.0], [1.0, 1.0, 1.0, 1.0], [1.0, 1.0, 1.0], [1.0, 1.0, 1.0]]","category":"page"},{"location":"jumps/spatial/","page":"Tutorial on using spatial SSAs in DiffEqJump","title":"Tutorial on using spatial SSAs in DiffEqJump","text":"We must combine both vectors into a pair as in the last line above.","category":"page"},{"location":"jumps/spatial/","page":"Tutorial on using spatial SSAs in DiffEqJump","title":"Tutorial on using spatial SSAs in DiffEqJump","text":"Finally, to use in hopping_constants of form D_si * L_ij we construct a matrix instead of a vector for D_sj.","category":"page"},{"location":"jumps/spatial/","page":"Tutorial on using spatial SSAs in DiffEqJump","title":"Tutorial on using spatial SSAs in DiffEqJump","text":"species_hop_constants = ones(num_species, num_nodes)\nsite_hop_constants = Vector{Vector{Float64}}(undef, num_nodes)\nfor site in 1:num_nodes\n    site_hop_constants[site] = ones(outdegree(grid, site))\nend\nhopping_constants=Pair(species_hop_constants, site_hop_constants)","category":"page"},{"location":"jumps/spatial/","page":"Tutorial on using spatial SSAs in DiffEqJump","title":"Tutorial on using spatial SSAs in DiffEqJump","text":"[1.0 1.0 … 1.0 1.0; 1.0 1.0 … 1.0 1.0; 1.0 1.0 … 1.0 1.0] => [[1.0, 1.0, 1.\n0], [1.0, 1.0, 1.0], [1.0, 1.0, 1.0, 1.0], [1.0, 1.0, 1.0, 1.0], [1.0, 1.0,\n 1.0], [1.0, 1.0, 1.0], [1.0, 1.0, 1.0, 1.0], [1.0, 1.0, 1.0, 1.0], [1.0, 1\n.0, 1.0, 1.0, 1.0], [1.0, 1.0, 1.0, 1.0, 1.0]  …  [1.0, 1.0, 1.0, 1.0, 1.0]\n, [1.0, 1.0, 1.0, 1.0, 1.0], [1.0, 1.0, 1.0, 1.0], [1.0, 1.0, 1.0, 1.0], [1\n.0, 1.0, 1.0], [1.0, 1.0, 1.0], [1.0, 1.0, 1.0, 1.0], [1.0, 1.0, 1.0, 1.0],\n [1.0, 1.0, 1.0], [1.0, 1.0, 1.0]]","category":"page"},{"location":"jumps/spatial/","page":"Tutorial on using spatial SSAs in DiffEqJump","title":"Tutorial on using spatial SSAs in DiffEqJump","text":"We can use either of the four versions of hopping_constants to construct a JumpProblem with the same syntax as in the original example. The different forms of hopping rates are supported not only for convenience but also for better memory usage and performance. So it is recommended that the most specialized form of hopping rates is used.","category":"page"},{"location":"jumps/spatial/#Solvers","page":"Tutorial on using spatial SSAs in DiffEqJump","title":"Solvers","text":"","category":"section"},{"location":"jumps/spatial/","page":"Tutorial on using spatial SSAs in DiffEqJump","title":"Tutorial on using spatial SSAs in DiffEqJump","text":"There are currently two specialized \"spatial\" solvers: NSM and DirectCRDirect. The former stands for Next Subvolume Method [1]. The latter employs Composition-Rejection to sample the next site to fire, similar to the ordinary DirectCR method. For larger networks DirectCRDirect is expected to be faster. Both methods can be used interchangeably.","category":"page"},{"location":"jumps/spatial/","page":"Tutorial on using spatial SSAs in DiffEqJump","title":"Tutorial on using spatial SSAs in DiffEqJump","text":"Additionally, all standard solvers are supported as well, although they are expected to use more memory and be slower. They \"flatten\" the problem, i.e. turn all hops into reactions, resulting in a much larger system. For example, to use the Next Reaction Method (NRM), simply pass in NRM() instead of NSM() in the construction of the JumpProblem. Importantly, you must pass in hopping_constants in the D_{s,i,j} or D_{s,i} form to use any of the non-specialized solvers.","category":"page"},{"location":"jumps/spatial/#References","page":"Tutorial on using spatial SSAs in DiffEqJump","title":"References","text":"","category":"section"},{"location":"jumps/spatial/","page":"Tutorial on using spatial SSAs in DiffEqJump","title":"Tutorial on using spatial SSAs in DiffEqJump","text":"[1]: Elf, Johan and Ehrenberg, Mäns. “Spontaneous separation of bi-stable biochemical systems into spatial domains of opposite phases”. In: Systems biology 1.2 (2004), pp. 230–236.","category":"page"},{"location":"models/04-spiking_neural_systems/#Spiking-Neural-Systems","page":"Spiking Neural Systems","title":"Spiking Neural Systems","text":"","category":"section"},{"location":"models/04-spiking_neural_systems/","page":"Spiking Neural Systems","title":"Spiking Neural Systems","text":"This is an introduction to spiking neural systems with Julia's DifferentialEquations package. We will cover three different models: leaky integrate-and-fire, Izhikevich, and Hodgkin-Huxley. Finally we will also learn about two mechanisms that simulate synaptic inputs like real neurons receive them. The alpha synapse and the Tsodyks-Markram synapse. Let's get started with the leaky integrate-and-fire (LIF) model.","category":"page"},{"location":"models/04-spiking_neural_systems/#The-Leaky-Integrate-and-Fire-Model","page":"Spiking Neural Systems","title":"The Leaky Integrate-and-Fire Model","text":"","category":"section"},{"location":"models/04-spiking_neural_systems/","page":"Spiking Neural Systems","title":"Spiking Neural Systems","text":"The LIF model is an extension of the integrate-and-fire (IF) model. While the IF model simply integrates input until it fires, the LIF model integrates input but also decays towards an equilibrium potential. This means that inputs that arrive in quick succession have a much higher chance to make the cell spike as opposed to inputs that are further apart in time. The LIF is a more realistic neuron model than the IF, because it is known from real neurons that the timing of inputs is extremely relevant for their spiking.","category":"page"},{"location":"models/04-spiking_neural_systems/","page":"Spiking Neural Systems","title":"Spiking Neural Systems","text":"The LIF model has five parameters, gL, EL, C, Vth, I and we define it in the lif(u, p, t) function.","category":"page"},{"location":"models/04-spiking_neural_systems/","page":"Spiking Neural Systems","title":"Spiking Neural Systems","text":"using DifferentialEquations\nusing Plots\ngr()\n\nfunction lif(u,p,t);\n    gL, EL, C, Vth, I = p\n    (-gL*(u-EL)+I)/C\nend","category":"page"},{"location":"models/04-spiking_neural_systems/","page":"Spiking Neural Systems","title":"Spiking Neural Systems","text":"lif (generic function with 1 method)","category":"page"},{"location":"models/04-spiking_neural_systems/","page":"Spiking Neural Systems","title":"Spiking Neural Systems","text":"Our system is described by one differential equation: (-gL*(u-EL)+I)/C, where u is the voltage, I is the input, gL is the leak conductance, EL is the equilibrium potential of the leak conductance and C is the membrane capacitance. Generally, any change of the voltage is slowed down (filtered) by the membrane capacitance. That's why we divide the whole equation by C. Without any external input, the voltage always converges towards EL. If u is larger than EL, u decreases until it is at EL. If u is smaller than EL, u increases until it is at EL. The only other thing that can change the voltage is the external input I.","category":"page"},{"location":"models/04-spiking_neural_systems/","page":"Spiking Neural Systems","title":"Spiking Neural Systems","text":"Our lif function requires a certain parameter structure because it will need to be compatible with the DifferentialEquations interface. The input signature is lif(u, p, t) where u is the voltage, p is the collection of the parameters that describe the equation and t is time. You might wonder why time does not show up in our equation, although we need to calculate the change in voltage with respect to time. The ODE solver will take care of time for us. One of the advantages of the ODE solver as opposed to calculating the change of u in a for loop is that many ODE solver algorithms can dynamically adjust the time step in a way that is efficient and accurate.","category":"page"},{"location":"models/04-spiking_neural_systems/","page":"Spiking Neural Systems","title":"Spiking Neural Systems","text":"One crucial thing is still missing however. This is supposed to be a model of neural spiking, right? So we need a mechanism that recognizes the spike and hyperpolarizes u in response. For this purpose we will use callbacks. They can make discontinuous changes to the model when certain conditions are met.","category":"page"},{"location":"models/04-spiking_neural_systems/","page":"Spiking Neural Systems","title":"Spiking Neural Systems","text":"function thr(u,t,integrator)\n    integrator.u > integrator.p[4]\nend\n\nfunction reset!(integrator)\n    integrator.u = integrator.p[2]\nend\n\nthreshold = DiscreteCallback(thr,reset!)\ncurrent_step= PresetTimeCallback([2,15],integrator -> integrator.p[5] += 210.0)\ncb = CallbackSet(current_step,threshold)","category":"page"},{"location":"models/04-spiking_neural_systems/","page":"Spiking Neural Systems","title":"Spiking Neural Systems","text":"SciMLBase.CallbackSet{Tuple{}, Tuple{SciMLBase.DiscreteCallback{DiffEqCallb\nacks.var\"#60#63\"{Vector{Int64}}, DiffEqCallbacks.var\"#61#64\"{Main.var\"##Wea\nveSandBox#2411\".var\"#1#2\"}, DiffEqCallbacks.var\"#62#65\"{typeof(SciMLBase.IN\nITIALIZE_DEFAULT), Bool, Vector{Int64}, Main.var\"##WeaveSandBox#2411\".var\"#\n1#2\"}, typeof(SciMLBase.FINALIZE_DEFAULT)}, SciMLBase.DiscreteCallback{type\nof(Main.var\"##WeaveSandBox#2411\".thr), typeof(Main.var\"##WeaveSandBox#2411\"\n.reset!), typeof(SciMLBase.INITIALIZE_DEFAULT), typeof(SciMLBase.FINALIZE_D\nEFAULT)}}}((), (SciMLBase.DiscreteCallback{DiffEqCallbacks.var\"#60#63\"{Vect\nor{Int64}}, DiffEqCallbacks.var\"#61#64\"{Main.var\"##WeaveSandBox#2411\".var\"#\n1#2\"}, DiffEqCallbacks.var\"#62#65\"{typeof(SciMLBase.INITIALIZE_DEFAULT), Bo\nol, Vector{Int64}, Main.var\"##WeaveSandBox#2411\".var\"#1#2\"}, typeof(SciMLBa\nse.FINALIZE_DEFAULT)}(DiffEqCallbacks.var\"#60#63\"{Vector{Int64}}([2, 15]), \nDiffEqCallbacks.var\"#61#64\"{Main.var\"##WeaveSandBox#2411\".var\"#1#2\"}(Main.v\nar\"##WeaveSandBox#2411\".var\"#1#2\"()), DiffEqCallbacks.var\"#62#65\"{typeof(Sc\niMLBase.INITIALIZE_DEFAULT), Bool, Vector{Int64}, Main.var\"##WeaveSandBox#2\n411\".var\"#1#2\"}(SciMLBase.INITIALIZE_DEFAULT, true, [2, 15], Main.var\"##Wea\nveSandBox#2411\".var\"#1#2\"()), SciMLBase.FINALIZE_DEFAULT, Bool[1, 1]), SciM\nLBase.DiscreteCallback{typeof(Main.var\"##WeaveSandBox#2411\".thr), typeof(Ma\nin.var\"##WeaveSandBox#2411\".reset!), typeof(SciMLBase.INITIALIZE_DEFAULT), \ntypeof(SciMLBase.FINALIZE_DEFAULT)}(Main.var\"##WeaveSandBox#2411\".thr, Main\n.var\"##WeaveSandBox#2411\".reset!, SciMLBase.INITIALIZE_DEFAULT, SciMLBase.F\nINALIZE_DEFAULT, Bool[1, 1])))","category":"page"},{"location":"models/04-spiking_neural_systems/","page":"Spiking Neural Systems","title":"Spiking Neural Systems","text":"Our condition is thr(u,t,integrator) and the condition kicks in when integrator.u > integrator.p[4] where p[4] is our threshold parameter Vth. Our effect of the condition is reset!(integrator). It sets u back to the equilibrium potential p[2]. We then wrap both the condition and the effect into a DiscreteCallback called threshold. There is one more callback called PresetTimeCallback that is particularly useful. This one increases the input p[5] at t=2 and t=15 by 210.0. Both callbacks are then combined into a CallbackSet. We are almost done to simulate our system we just need to put numbers on our initial voltage and parameters.","category":"page"},{"location":"models/04-spiking_neural_systems/","page":"Spiking Neural Systems","title":"Spiking Neural Systems","text":"u0 = -75\ntspan = (0.0, 40.0)\n# p = (gL, EL, C, Vth, I)\np = [10.0, -75.0, 5.0, -55.0, 0]\n\nprob = ODEProblem(lif, u0, tspan, p, callback=cb)","category":"page"},{"location":"models/04-spiking_neural_systems/","page":"Spiking Neural Systems","title":"Spiking Neural Systems","text":"ODEProblem with uType Int64 and tType Float64. In-place: false\ntimespan: (0.0, 40.0)\nu0: -75","category":"page"},{"location":"models/04-spiking_neural_systems/","page":"Spiking Neural Systems","title":"Spiking Neural Systems","text":"Our initial voltage is u0 = - 75, which will be the same as our equilibrium potential, so we start at a stable point. Then we define the timespan we want to simulate. The time scale of the LIF as it is defined conforms roughly to milliseconds. Then we define our parameters as p = [10.0, -75.0, 5.0, -55.0, 0]. Remember that gL, EL, C, Vth, I = p. Finally we wrap everything into a call to ODEProblem. Can't forget the CallbackSet. With that our model is defined. Now we just need to solve it with a quick call to solve.","category":"page"},{"location":"models/04-spiking_neural_systems/","page":"Spiking Neural Systems","title":"Spiking Neural Systems","text":"sol = solve(prob)","category":"page"},{"location":"models/04-spiking_neural_systems/","page":"Spiking Neural Systems","title":"Spiking Neural Systems","text":"retcode: Success\nInterpolation: specialized 4th order \"free\" interpolation, specialized 2nd \norder \"free\" stiffness-aware interpolation\nt: 153-element Vector{Float64}:\n  0.0\n  9.999999999999999e-5\n  0.0010999999999999998\n  0.011099999999999997\n  0.11109999999999996\n  1.1110999999999995\n  2.0\n  2.0\n  2.6300346520855156\n  2.922604932362957\n  ⋮\n 38.34157807913922\n 38.78215044450299\n 38.78215044450299\n 39.22272279235999\n 39.22272279235999\n 39.663295181066125\n 39.663295181066125\n 40.0\n 40.0\nu: 153-element Vector{Float64}:\n -75.0\n -75.0\n -75.0\n -75.0\n -75.0\n -75.0\n -75.0\n -75.0\n -59.978080290282385\n -57.329991819757744\n   ⋮\n -75.0\n -50.40489536606269\n -75.0\n -50.40489597428093\n -75.0\n -50.40489455510494\n -75.0\n -54.419257979386686\n -75.0","category":"page"},{"location":"models/04-spiking_neural_systems/","page":"Spiking Neural Systems","title":"Spiking Neural Systems","text":"First of all the solve output tells us if solving the system generally worked. In this case we know it worked because the return code (retcode) says Success. Then we get the numbers for the timestep and the solution to u. The raw numbers are not super interesting to let's plot our solution.","category":"page"},{"location":"models/04-spiking_neural_systems/","page":"Spiking Neural Systems","title":"Spiking Neural Systems","text":"plot(sol)","category":"page"},{"location":"models/04-spiking_neural_systems/","page":"Spiking Neural Systems","title":"Spiking Neural Systems","text":"(Image: )","category":"page"},{"location":"models/04-spiking_neural_systems/","page":"Spiking Neural Systems","title":"Spiking Neural Systems","text":"We see that the model is resting at -75 while there is no input. At t=2 the input increases by 210 and the model starts to spike. Spiking does not start immediately because the input first has to charge the membrane capacitance. Notice how once spiking starts it very quickly becomes extremely regular. Increasing the input again at t=15 increases firing as we would expect but it is still extremely regular. This is one of the features of the LIF. The firing frequency is regular for constant input and a linear function of the input strength. There are ways to make LIF models less regular. For example we could use certain noise types at the input. We could also simulate a large number of LIF models and connect them synaptically. Instead of going into those topics, we will move on to the Izhikevich model, which is known for its ability to generate a large variety of spiking dynamics during constant inputs.","category":"page"},{"location":"models/04-spiking_neural_systems/#The-Izhikevich-Model","page":"Spiking Neural Systems","title":"The Izhikevich Model","text":"","category":"section"},{"location":"models/04-spiking_neural_systems/","page":"Spiking Neural Systems","title":"Spiking Neural Systems","text":"The Izhikevich model is a two-dimensional model of neuronal spiking. It was derived from a bifurcation analysis of a cortical neuron. Because it is two-dimensional it can generate much more complex spike dynamics than the LIF model. The kind of dynamics depend on the four parameters and the input a, b, c, d, I = p. All the concepts are the same as above, expect for some minor changes to our function definitions to accomodate for the second dimension.","category":"page"},{"location":"models/04-spiking_neural_systems/","page":"Spiking Neural Systems","title":"Spiking Neural Systems","text":"#Izhikevichch Model\nusing DifferentialEquations\nusing Plots\n\nfunction izh!(du,u,p,t);\n    a, b, c, d, I = p\n\n    du[1] = 0.04*u[1]^2+5*u[1]+140-u[2]+I\n    du[2] = a*(b*u[1]-u[2])\nend","category":"page"},{"location":"models/04-spiking_neural_systems/","page":"Spiking Neural Systems","title":"Spiking Neural Systems","text":"izh! (generic function with 1 method)","category":"page"},{"location":"models/04-spiking_neural_systems/","page":"Spiking Neural Systems","title":"Spiking Neural Systems","text":"This is our Izhikevich model. There are two important changes here. First of all, note the additional input parameter du. This is a sequence of differences. du[1] corresponds to the voltage (the first dimension of the system) and du[2] corresponds to the second dimension. This second dimension is called u in the original Izhikevich work amnd it makes the notation a little annoying. In this tutorial I will generally stick to Julia and DifferentialEquations conventions as opposed to conventions of the specific models and du is commonly used. We will never define du ourselves outside of the function but the ODE solver will use it internally. The other change here is the ! after our function name. This signifies that du will be preallocated before integration and then updated in-place, which saves a lot of allocation time. Now we just need our callbacks to take care of spikes and increase the input.","category":"page"},{"location":"models/04-spiking_neural_systems/","page":"Spiking Neural Systems","title":"Spiking Neural Systems","text":"function thr(u,t,integrator)\n    integrator.u[1] >= 30\nend\n\nfunction reset!(integrator)\n    integrator.u[1] = integrator.p[3]\n    integrator.u[2] += integrator.p[4]\nend\n\nthreshold = DiscreteCallback(thr,reset!)\ncurrent_step= PresetTimeCallback(50,integrator -> integrator.p[5] += 10)\ncb = CallbackSet(current_step,threshold)","category":"page"},{"location":"models/04-spiking_neural_systems/","page":"Spiking Neural Systems","title":"Spiking Neural Systems","text":"SciMLBase.CallbackSet{Tuple{}, Tuple{SciMLBase.DiscreteCallback{DiffEqCallb\nacks.var\"#60#63\"{Int64}, DiffEqCallbacks.var\"#61#64\"{Main.var\"##WeaveSandBo\nx#2411\".var\"#3#4\"}, DiffEqCallbacks.var\"#62#65\"{typeof(SciMLBase.INITIALIZE\n_DEFAULT), Bool, Int64, Main.var\"##WeaveSandBox#2411\".var\"#3#4\"}, typeof(Sc\niMLBase.FINALIZE_DEFAULT)}, SciMLBase.DiscreteCallback{typeof(Main.var\"##We\naveSandBox#2411\".thr), typeof(Main.var\"##WeaveSandBox#2411\".reset!), typeof\n(SciMLBase.INITIALIZE_DEFAULT), typeof(SciMLBase.FINALIZE_DEFAULT)}}}((), (\nSciMLBase.DiscreteCallback{DiffEqCallbacks.var\"#60#63\"{Int64}, DiffEqCallba\ncks.var\"#61#64\"{Main.var\"##WeaveSandBox#2411\".var\"#3#4\"}, DiffEqCallbacks.v\nar\"#62#65\"{typeof(SciMLBase.INITIALIZE_DEFAULT), Bool, Int64, Main.var\"##We\naveSandBox#2411\".var\"#3#4\"}, typeof(SciMLBase.FINALIZE_DEFAULT)}(DiffEqCall\nbacks.var\"#60#63\"{Int64}(50), DiffEqCallbacks.var\"#61#64\"{Main.var\"##WeaveS\nandBox#2411\".var\"#3#4\"}(Main.var\"##WeaveSandBox#2411\".var\"#3#4\"()), DiffEqC\nallbacks.var\"#62#65\"{typeof(SciMLBase.INITIALIZE_DEFAULT), Bool, Int64, Mai\nn.var\"##WeaveSandBox#2411\".var\"#3#4\"}(SciMLBase.INITIALIZE_DEFAULT, true, 5\n0, Main.var\"##WeaveSandBox#2411\".var\"#3#4\"()), SciMLBase.FINALIZE_DEFAULT, \nBool[1, 1]), SciMLBase.DiscreteCallback{typeof(Main.var\"##WeaveSandBox#2411\n\".thr), typeof(Main.var\"##WeaveSandBox#2411\".reset!), typeof(SciMLBase.INIT\nIALIZE_DEFAULT), typeof(SciMLBase.FINALIZE_DEFAULT)}(Main.var\"##WeaveSandBo\nx#2411\".thr, Main.var\"##WeaveSandBox#2411\".reset!, SciMLBase.INITIALIZE_DEF\nAULT, SciMLBase.FINALIZE_DEFAULT, Bool[1, 1])))","category":"page"},{"location":"models/04-spiking_neural_systems/","page":"Spiking Neural Systems","title":"Spiking Neural Systems","text":"One key feature of the Izhikevich model is that each spike increases our second dimension u[2] by a preset amount p[4]. Between spikes u[2] decays to a value that depends on p[1] and p[2] and the equilibrium potential p[3]. Otherwise the code is not too different from the LIF model. We will again need to define our parameters and we are ready to simulate.","category":"page"},{"location":"models/04-spiking_neural_systems/","page":"Spiking Neural Systems","title":"Spiking Neural Systems","text":"p = [0.02, 0.2, -50, 2, 0]\nu0 = [-65, p[2]*-65]\ntspan = (0.0, 300)\n\nprob = ODEProblem(izh!, u0, tspan, p, callback=cb)","category":"page"},{"location":"models/04-spiking_neural_systems/","page":"Spiking Neural Systems","title":"Spiking Neural Systems","text":"ODEProblem with uType Vector{Float64} and tType Float64. In-place: true\ntimespan: (0.0, 300.0)\nu0: 2-element Vector{Float64}:\n -65.0\n -13.0","category":"page"},{"location":"models/04-spiking_neural_systems/","page":"Spiking Neural Systems","title":"Spiking Neural Systems","text":"sol = solve(prob);\nplot(sol, vars=1)","category":"page"},{"location":"models/04-spiking_neural_systems/","page":"Spiking Neural Systems","title":"Spiking Neural Systems","text":"(Image: )","category":"page"},{"location":"models/04-spiking_neural_systems/","page":"Spiking Neural Systems","title":"Spiking Neural Systems","text":"This spiking type is called chattering. It fires with intermittent periods of silence. Note that the input starts at t=50 and remain constant for the duration of the simulation. One of mechanisms that sustains this type of firing is the spike induced hyperpolarization coming from our second dimension, so let's look at this variable.","category":"page"},{"location":"models/04-spiking_neural_systems/","page":"Spiking Neural Systems","title":"Spiking Neural Systems","text":"plot(sol, vars=2)","category":"page"},{"location":"models/04-spiking_neural_systems/","page":"Spiking Neural Systems","title":"Spiking Neural Systems","text":"(Image: )","category":"page"},{"location":"models/04-spiking_neural_systems/","page":"Spiking Neural Systems","title":"Spiking Neural Systems","text":"Our second dimension u[2] increases with every spike. When it becomes too large, the system cannot generate another spike until u[2] has decayed to a value small enough that spiking can resume. This process repeats. In this model, spiking is no longer regular like it was in the LIF. Here we have two frequencies, the frequency during the spiking state and the frequency between spiking states. The LIF model was dominated by one single frequency that was a function of the input strength. Let's see if we can generate another spiking type by changing the parameters.","category":"page"},{"location":"models/04-spiking_neural_systems/","page":"Spiking Neural Systems","title":"Spiking Neural Systems","text":"p = [0.02, 0.2, -65, 8, 0]\nu0 = [-65, p[2]*-65]\ntspan = (0.0, 300)\n\nprob = ODEProblem(izh!, u0, tspan, p, callback=cb)\nsol = solve(prob);\nplot(sol, vars=1)","category":"page"},{"location":"models/04-spiking_neural_systems/","page":"Spiking Neural Systems","title":"Spiking Neural Systems","text":"(Image: )","category":"page"},{"location":"models/04-spiking_neural_systems/","page":"Spiking Neural Systems","title":"Spiking Neural Systems","text":"This type is called regularly spiking and we created it just by lowering p[3] and increasing p[4]. Note that the type is called regularly spiking but it is not instantaneously regular. The instantenous frequency is higher in the beginning. This is called spike frequency adaptation and is a common property of real neurons. There are many more spike types that can be generated. Check out the original Izhikevich work and create your own favorite neuron!","category":"page"},{"location":"models/04-spiking_neural_systems/#Hodgkin-Huxley-Model","page":"Spiking Neural Systems","title":"Hodgkin-Huxley Model","text":"","category":"section"},{"location":"models/04-spiking_neural_systems/","page":"Spiking Neural Systems","title":"Spiking Neural Systems","text":"The Hodgkin-Huxley (HH) model is our first biophysically realistic model. This means that all parameters and mechanisms of the model represent biological mechanisms. Specifically, the HH model simulates the ionic currents that depolarize and hyperpolarize a neuron during an action potential. This makes the HH model four-dimensional. Let's see how it looks.","category":"page"},{"location":"models/04-spiking_neural_systems/","page":"Spiking Neural Systems","title":"Spiking Neural Systems","text":"using DifferentialEquations\nusing Plots\n\n# Potassium ion-channel rate functions\nalpha_n(v) = (0.02 * (v - 25.0)) / (1.0 - exp((-1.0 * (v - 25.0)) / 9.0))\nbeta_n(v) = (-0.002 * (v - 25.0)) / (1.0 - exp((v - 25.0) / 9.0))\n\n# Sodium ion-channel rate functions\nalpha_m(v) = (0.182*(v + 35.0)) / (1.0 - exp((-1.0 * (v + 35.0)) / 9.0))\nbeta_m(v) = (-0.124 * (v + 35.0)) / (1.0 - exp((v + 35.0) / 9.0))\n\nalpha_h(v) = 0.25 * exp((-1.0 * (v + 90.0)) / 12.0)\nbeta_h(v) = (0.25 * exp((v + 62.0) / 6.0)) / exp((v + 90.0) / 12.0)\n\nfunction HH!(du,u,p,t);\n    gK, gNa, gL, EK, ENa, EL, C, I = p\n    v, n, m, h = u\n\n    du[1] = (-(gK * (n^4.0) * (v - EK)) - (gNa * (m ^ 3.0) * h * (v - ENa)) - (gL * (v - EL)) + I) / C\n    du[2] = (alpha_n(v) * (1.0 - n)) - (beta_n(v) * n)\n    du[3] = (alpha_m(v) * (1.0 - m)) - (beta_m(v) * m)\n    du[4] = (alpha_h(v) * (1.0 - h)) - (beta_h(v) * h)\nend","category":"page"},{"location":"models/04-spiking_neural_systems/","page":"Spiking Neural Systems","title":"Spiking Neural Systems","text":"HH! (generic function with 1 method)","category":"page"},{"location":"models/04-spiking_neural_systems/","page":"Spiking Neural Systems","title":"Spiking Neural Systems","text":"We have three different types of ionic conductances. Potassium, sodium and the leak. The potassium and sodium conducance are voltage gated. They increase or decrease depending on the voltage. In ion channel terms, open channels can transition to the closed state and closed channels can transition to the open state. It's probably easiest to start with the potassium current described by gK * (n^4.0) * (EK - v). Here gK is the total possible conductance that we could reach if all potassium channels were open. If all channels were open, n would equal 1 which is usually not the case. The transition from open state to closed state is modeled in alpha_n(v) while the transition from closed to open is in beta_n(v). Because potassium conductance is voltage gated, these transitions depend on v. The numbers in alpha_n; beta_n were calculated by Hodgkin and Huxley based on their extensive experiments on the squid giant axon. They also determined, that n needs to be taken to the power of 4 to correctly model the amount of open channels.","category":"page"},{"location":"models/04-spiking_neural_systems/","page":"Spiking Neural Systems","title":"Spiking Neural Systems","text":"The sodium current is not very different but it has two gating variables, m, h instead of one. The leak conductance gL has no gating variables because it is not voltage gated. Let's move on to the parameters. If you want all the details on the HH model you can find a great description here.","category":"page"},{"location":"models/04-spiking_neural_systems/","page":"Spiking Neural Systems","title":"Spiking Neural Systems","text":"current_step= PresetTimeCallback(100,integrator -> integrator.p[8] += 1)\n\n# n, m & h steady-states\nn_inf(v) = alpha_n(v) / (alpha_n(v) + beta_n(v))\nm_inf(v) = alpha_m(v) / (alpha_m(v) + beta_m(v))\nh_inf(v) = alpha_h(v) / (alpha_h(v) + beta_h(v))\n\np = [35.0, 40.0, 0.3, -77.0, 55.0, -65.0, 1, 0]\nu0 = [-60, n_inf(-60), m_inf(-60), h_inf(-60)]\ntspan = (0.0, 1000)\n\nprob = ODEProblem(HH!, u0, tspan, p, callback=current_step)","category":"page"},{"location":"models/04-spiking_neural_systems/","page":"Spiking Neural Systems","title":"Spiking Neural Systems","text":"ODEProblem with uType Vector{Float64} and tType Float64. In-place: true\ntimespan: (0.0, 1000.0)\nu0: 4-element Vector{Float64}:\n -60.0\n   0.0007906538330645917\n   0.08362733690208038\n   0.41742979353768533","category":"page"},{"location":"models/04-spiking_neural_systems/","page":"Spiking Neural Systems","title":"Spiking Neural Systems","text":"For the HH model we need only one callback. The PresetTimeCallback that starts our input current. We don't need to reset the voltage when it reaches threshold because the HH model has its own repolarization mechanism. That is the potassium current, which activates at large voltages and makes the voltage more negative. The three functions n_inf; m_inf; h_inf help us to find good initial values for the gating variables. Those functions tell us that the steady-state gating values should be for the initial voltage. The parameters were chosen in a way that the properties of the model roughly resemble that of a cortical pyramidal cell instead of the giant axon Hodgkin and Huxley were originally working on.","category":"page"},{"location":"models/04-spiking_neural_systems/","page":"Spiking Neural Systems","title":"Spiking Neural Systems","text":"sol = solve(prob);\nplot(sol, vars=1)","category":"page"},{"location":"models/04-spiking_neural_systems/","page":"Spiking Neural Systems","title":"Spiking Neural Systems","text":"(Image: )","category":"page"},{"location":"models/04-spiking_neural_systems/","page":"Spiking Neural Systems","title":"Spiking Neural Systems","text":"That's some good regular voltage spiking. One of the cool things about a biophysically realistic model is that the gating variables tell us something about the mechanisms behind the action potential. You might have seen something like the following plot in a biology textbook.","category":"page"},{"location":"models/04-spiking_neural_systems/","page":"Spiking Neural Systems","title":"Spiking Neural Systems","text":"plot(sol, vars=[2,3,4], tspan=(105.0,130.0))","category":"page"},{"location":"models/04-spiking_neural_systems/","page":"Spiking Neural Systems","title":"Spiking Neural Systems","text":"(Image: )","category":"page"},{"location":"models/04-spiking_neural_systems/","page":"Spiking Neural Systems","title":"Spiking Neural Systems","text":"So far we have only given our neurons very simple step inputs by simply changing the number I. Actual neurons recieve their inputs mostly from chemical synapses. They produce conductance changes with very complex structures. In the next chapter we will try to incorporate a synapse into our HH model.","category":"page"},{"location":"models/04-spiking_neural_systems/#Alpha-Synapse","page":"Spiking Neural Systems","title":"Alpha Synapse","text":"","category":"section"},{"location":"models/04-spiking_neural_systems/","page":"Spiking Neural Systems","title":"Spiking Neural Systems","text":"One of the most simple synaptic mechanisms used in computational neuroscience is the alpha synapse. When this mechanism is triggered, it causes an instantanouse rise in conductance followed by an exponential decay. Let's incorporate that into our HH model.","category":"page"},{"location":"models/04-spiking_neural_systems/","page":"Spiking Neural Systems","title":"Spiking Neural Systems","text":"function gSyn(max_gsyn, tau, tf, t);\n    if t-tf >= 0\n        return max_gsyn * exp(-(t-tf)/tau)\n    else\n        return 0.0\n    end\nend\nfunction HH!(du,u,p,t);\n    gK, gNa, gL, EK, ENa, EL, C, I, max_gSyn, ESyn, tau, tf = p\n    v, n, m, h = u\n\n    ISyn = gSyn(max_gSyn, tau, tf, t) * (v - ESyn)\n\n    du[1] = (-(gK * (n^4.0) * (v - EK)) - (gNa * (m ^ 3.0) * h * (v - ENa)) - (gL * (v - EL)) + I - ISyn) / C\n    du[2] = (alpha_n(v) * (1.0 - n)) - (beta_n(v) * n)\n    du[3] = (alpha_m(v) * (1.0 - m)) - (beta_m(v) * m)\n    du[4] = (alpha_h(v) * (1.0 - h)) - (beta_h(v) * h)\nend","category":"page"},{"location":"models/04-spiking_neural_systems/","page":"Spiking Neural Systems","title":"Spiking Neural Systems","text":"HH! (generic function with 1 method)","category":"page"},{"location":"models/04-spiking_neural_systems/","page":"Spiking Neural Systems","title":"Spiking Neural Systems","text":"gSyn models the step to the maximum conductance and the following exponential decay with time constant tau. Of course we only want to integrate the conductance at and after time tf, the onset of the synaptic response. Before tf, gSyn returns zero. To convert the conductance to a current, we multiply by the difference between the current voltage and the synapses equilibrium voltage: ISyn = gSyn(max_gSyn, tau, tf, t) * (v - ESyn). Later we will set the parameter ESyn to 0, making this synapse an excitatory synapse. Excitatory synapses have equilibrium potentials far above the resting potential. Let's see what our synapse does to the voltage of the cell.","category":"page"},{"location":"models/04-spiking_neural_systems/","page":"Spiking Neural Systems","title":"Spiking Neural Systems","text":"p = [35.0, 40.0, 0.3, -77.0, 55.0, -65.0, 1, 0, 0.008, 0, 20, 100]\ntspan = (0.0, 200)\nprob = ODEProblem(HH!, u0, tspan, p)\nsol = solve(prob);\nplot(sol, vars=1)","category":"page"},{"location":"models/04-spiking_neural_systems/","page":"Spiking Neural Systems","title":"Spiking Neural Systems","text":"(Image: )","category":"page"},{"location":"models/04-spiking_neural_systems/","page":"Spiking Neural Systems","title":"Spiking Neural Systems","text":"What you see here is called an excitatory postsynaptic potential (EPSP). It is the voltage response to a synaptic current. While our synaptic conductance rises instantly, the voltage response rises at a slower time course that is given by the membrane capacitance C. This particular voltage response is not strong enough to evoke spiking, so we say it is subthreshold. To get a suprathreshold response that evokes spiking we simply increase the parameter max_gSyn to increase the maximum conductance.","category":"page"},{"location":"models/04-spiking_neural_systems/","page":"Spiking Neural Systems","title":"Spiking Neural Systems","text":"p = [35.0, 40.0, 0.3, -77.0, 55.0, -65.0, 1, 0, 0.01, 0, 20, 100]\ntspan = (0.0, 200)\nprob = ODEProblem(HH!, u0, tspan, p)\nsol = solve(prob);\nplot!(sol, vars=1)","category":"page"},{"location":"models/04-spiking_neural_systems/","page":"Spiking Neural Systems","title":"Spiking Neural Systems","text":"(Image: )","category":"page"},{"location":"models/04-spiking_neural_systems/","page":"Spiking Neural Systems","title":"Spiking Neural Systems","text":"This plot shows both the subthreshold EPSP from above as well as the suprathreshold EPSP. Alpha synapses are nice because of their simplicity. Real synapses however, are extremely complex structures. One of the most important features of real synapses is that their maximum conductance is not the same on every event. The number and frequency of synaptic events changes the size of the maximum conductance in a dynamic way. While we usually avoid anatomical and biophysical details of real synapses, there is a widely used phenomenological way to capture those dynamics called the Tsodyks-Markram synapse.","category":"page"},{"location":"models/04-spiking_neural_systems/#Tsodyks-Markram-Synapse","page":"Spiking Neural Systems","title":"Tsodyks-Markram Synapse","text":"","category":"section"},{"location":"models/04-spiking_neural_systems/","page":"Spiking Neural Systems","title":"Spiking Neural Systems","text":"The Tsodyks-Markram synapse (TMS) is a dynamic system that models the changes of maximum conductance that occur between EPSPs at different frequencies. The single response is similar to the alpha synapse in that it rises instantaneously and decays exponentially. The maximum conductance it reaches depends on the event history. To simulate the TMS we need to incorporate three more dimensions, u, R, gsyn into our system. u decays towards 0, R decays towards 1 and gsyn decays towards 0 as it did with the alpha synapse. The crucial part of the TMS is in epsp!, where we handle the discontinuities when a synaptic event occurs. Instead of just setting gsyn to the maximum conductance gmax, we increment gsyn by a fraction of gmax that depends on the other two dynamic parameters. The frequency dependence comes from the size of the time constants tau_u and tau_R. Enough talk, let's simulate it.","category":"page"},{"location":"models/04-spiking_neural_systems/","page":"Spiking Neural Systems","title":"Spiking Neural Systems","text":"function HH!(du,u,p,t);\n    gK, gNa, gL, EK, ENa, EL, C, I, tau, tau_u, tau_R, u0, gmax, Esyn  = p\n    v, n, m, h, u, R, gsyn = u\n\n    du[1] = ((gK * (n^4.0) * (EK - v)) + (gNa * (m ^ 3.0) * h * (ENa - v)) + (gL * (EL - v)) + I + gsyn * (Esyn - v)) / C\n    du[2] = (alpha_n(v) * (1.0 - n)) - (beta_n(v) * n)\n    du[3] = (alpha_m(v) * (1.0 - m)) - (beta_m(v) * m)\n    du[4] = (alpha_h(v) * (1.0 - h)) - (beta_h(v) * h)\n\n    # Synaptic variables\n    du[5] = -(u/tau_u)\n    du[6] = (1-R)/tau_R\n    du[7] = -(gsyn/tau)\nend\n\nfunction epsp!(integrator);\n    integrator.u[5] += integrator.p[12] * (1 - integrator.u[5])\n    integrator.u[7] += integrator.p[13] * integrator.u[5] * integrator.u[6]\n    integrator.u[6] -= integrator.u[5] * integrator.u[6]\n\nend\n\nepsp_ts= PresetTimeCallback(100:100:500, epsp!)\n\np = [35.0, 40.0, 0.3, -77.0, 55.0, -65.0, 1, 0, 30, 1000, 50, 0.5, 0.005, 0]\nu0 = [-60, n_inf(-60), m_inf(-60), h_inf(-60), 0.0, 1.0, 0.0]\ntspan = (0.0, 700)\nprob = ODEProblem(HH!, u0, tspan, p, callback=epsp_ts)\nsol = solve(prob);\nplot(sol, vars=1)","category":"page"},{"location":"models/04-spiking_neural_systems/","page":"Spiking Neural Systems","title":"Spiking Neural Systems","text":"(Image: )","category":"page"},{"location":"models/04-spiking_neural_systems/","page":"Spiking Neural Systems","title":"Spiking Neural Systems","text":"plot(sol, vars=7)","category":"page"},{"location":"models/04-spiking_neural_systems/","page":"Spiking Neural Systems","title":"Spiking Neural Systems","text":"(Image: )","category":"page"},{"location":"models/04-spiking_neural_systems/","page":"Spiking Neural Systems","title":"Spiking Neural Systems","text":"Both the voltage response as well as the conductances show what is called short-term facilitation. An increase in peak conductance over multiple synaptic events. Here the first event has a conductance of around 0.0025 and the last one of 0.004. We can plot the other two varialbes to see what underlies those dynamics","category":"page"},{"location":"models/04-spiking_neural_systems/","page":"Spiking Neural Systems","title":"Spiking Neural Systems","text":"plot(sol, vars=[5,6])","category":"page"},{"location":"models/04-spiking_neural_systems/","page":"Spiking Neural Systems","title":"Spiking Neural Systems","text":"(Image: )","category":"page"},{"location":"models/04-spiking_neural_systems/","page":"Spiking Neural Systems","title":"Spiking Neural Systems","text":"Because of the time courses at play here, this facilitation is frequency dependent. If we increase the period between these events, facilitation does not occur.","category":"page"},{"location":"models/04-spiking_neural_systems/","page":"Spiking Neural Systems","title":"Spiking Neural Systems","text":"epsp_ts= PresetTimeCallback(100:1000:5100, epsp!)\n\np = [35.0, 40.0, 0.3, -77.0, 55.0, -65.0, 1, 0, 30, 500, 50, 0.5, 0.005, 0]\nu0 = [-60, n_inf(-60), m_inf(-60), h_inf(-60), 0.0, 1.0, 0.0]\ntspan = (0.0, 5300)\nprob = ODEProblem(HH!, u0, tspan, p, callback=epsp_ts)\nsol = solve(prob);\nplot(sol, vars=7)","category":"page"},{"location":"models/04-spiking_neural_systems/","page":"Spiking Neural Systems","title":"Spiking Neural Systems","text":"(Image: )","category":"page"},{"location":"models/04-spiking_neural_systems/","page":"Spiking Neural Systems","title":"Spiking Neural Systems","text":"plot(sol, vars=[5,6])","category":"page"},{"location":"models/04-spiking_neural_systems/","page":"Spiking Neural Systems","title":"Spiking Neural Systems","text":"(Image: )","category":"page"},{"location":"models/04-spiking_neural_systems/","page":"Spiking Neural Systems","title":"Spiking Neural Systems","text":"We can also change these time constants such that the dynamics show short-term depression instead of facilitation.","category":"page"},{"location":"models/04-spiking_neural_systems/","page":"Spiking Neural Systems","title":"Spiking Neural Systems","text":"epsp_ts= PresetTimeCallback(100:100:500, epsp!)\n\np = [35.0, 40.0, 0.3, -77.0, 55.0, -65.0, 1, 0, 30, 100, 1000, 0.5, 0.005, 0]\nu0 = [-60, n_inf(-60), m_inf(-60), h_inf(-60), 0.0, 1.0, 0.0]\ntspan = (0.0, 700)\nprob = ODEProblem(HH!, u0, tspan, p, callback=epsp_ts)\nsol = solve(prob);\nplot(sol, vars=7)","category":"page"},{"location":"models/04-spiking_neural_systems/","page":"Spiking Neural Systems","title":"Spiking Neural Systems","text":"(Image: )","category":"page"},{"location":"models/04-spiking_neural_systems/","page":"Spiking Neural Systems","title":"Spiking Neural Systems","text":"plot(sol, vars=[5,6])","category":"page"},{"location":"models/04-spiking_neural_systems/","page":"Spiking Neural Systems","title":"Spiking Neural Systems","text":"(Image: )","category":"page"},{"location":"models/04-spiking_neural_systems/","page":"Spiking Neural Systems","title":"Spiking Neural Systems","text":"Just changing those two time constants has changed the dynamics to short-term depression. This is still frequency dependent. Changing these parameters can generate a variety of different short-term dynamics.","category":"page"},{"location":"models/04-spiking_neural_systems/#Summary","page":"Spiking Neural Systems","title":"Summary","text":"","category":"section"},{"location":"models/04-spiking_neural_systems/","page":"Spiking Neural Systems","title":"Spiking Neural Systems","text":"That's it for now. Thanks for making it this far. If you want to learn more about neuronal dynamics, this is a great resource. If you want to learn more about Julia check out the official website and to learn more about the DifferentialEquations package you are in the right place, because this chapter is part of a larger tutorial series about just that.","category":"page"},{"location":"models/04-spiking_neural_systems/#Appendix","page":"Spiking Neural Systems","title":"Appendix","text":"","category":"section"},{"location":"models/04-spiking_neural_systems/","page":"Spiking Neural Systems","title":"Spiking Neural Systems","text":"These tutorials are a part of the SciMLTutorials.jl repository, found at: https://github.com/SciML/SciMLTutorials.jl. For more information on high-performance scientific machine learning, check out the SciML Open Source Software Organization https://sciml.ai.","category":"page"},{"location":"models/04-spiking_neural_systems/","page":"Spiking Neural Systems","title":"Spiking Neural Systems","text":"To locally run this tutorial, do the following commands:","category":"page"},{"location":"models/04-spiking_neural_systems/","page":"Spiking Neural Systems","title":"Spiking Neural Systems","text":"using SciMLTutorials\nSciMLTutorials.weave_file(\"tutorials/models\",\"04-spiking_neural_systems.jmd\")","category":"page"},{"location":"models/04-spiking_neural_systems/","page":"Spiking Neural Systems","title":"Spiking Neural Systems","text":"Computer Information:","category":"page"},{"location":"models/04-spiking_neural_systems/","page":"Spiking Neural Systems","title":"Spiking Neural Systems","text":"Julia Version 1.8.0\nCommit 5544a0fab76 (2022-08-17 13:38 UTC)\nPlatform Info:\n  OS: Linux (x86_64-linux-gnu)\n  CPU: 128 × AMD EPYC 7502 32-Core Processor\n  WORD_SIZE: 64\n  LIBM: libopenlibm\n  LLVM: libLLVM-13.0.1 (ORCJIT, znver2)\n  Threads: 1 on 128 virtual cores\nEnvironment:\n  JULIA_CPU_THREADS = 128\n  JULIA_DEPOT_PATH = /cache/julia-buildkite-plugin/depots/a6029d3a-f78b-41ea-bc97-28aa57c6c6ea\n","category":"page"},{"location":"models/04-spiking_neural_systems/","page":"Spiking Neural Systems","title":"Spiking Neural Systems","text":"Package Information:","category":"page"},{"location":"models/04-spiking_neural_systems/","page":"Spiking Neural Systems","title":"Spiking Neural Systems","text":"Status `/cache/build/exclusive-amdci1-0/julialang/scimltutorials-dot-jl/tutorials/models/Project.toml`\n  [479239e8] Catalyst v12.2.1\n  [459566f4] DiffEqCallbacks v2.24.1\n  [f3b72e0c] DiffEqDevTools v2.31.2\n  [055956cb] DiffEqPhysics v3.9.0\n  [0c46a032] DifferentialEquations v7.3.0\n  [31c24e10] Distributions v0.25.70\n  [587475ba] Flux v0.13.5\n  [f6369f11] ForwardDiff v0.10.32\n  [23fbe1c1] Latexify v0.15.16\n  [961ee093] ModelingToolkit v8.21.0\n  [2774e3e8] NLsolve v4.5.1\n⌅ [315f7962] NeuralPDE v4.11.0\n  [429524aa] Optim v1.7.2\n  [1dea7af3] OrdinaryDiffEq v6.26.2\n  [91a5bcdd] Plots v1.32.0\n  [731186ca] RecursiveArrayTools v2.32.0\n  [30cb0354] SciMLTutorials v1.0.0\n  [789caeaf] StochasticDiffEq v6.53.0\n  [37e2e46d] LinearAlgebra\n  [2f01184e] SparseArrays\nInfo Packages marked with ⌅ have new versions available but cannot be upgraded. To see why use `status --outdated`","category":"page"},{"location":"models/04-spiking_neural_systems/","page":"Spiking Neural Systems","title":"Spiking Neural Systems","text":"And the full manifest:","category":"page"},{"location":"models/04-spiking_neural_systems/","page":"Spiking Neural Systems","title":"Spiking Neural Systems","text":"Status `/cache/build/exclusive-amdci1-0/julialang/scimltutorials-dot-jl/tutorials/models/Manifest.toml`\n  [c3fe647b] AbstractAlgebra v0.27.4\n  [621f4979] AbstractFFTs v1.2.1\n  [1520ce14] AbstractTrees v0.4.2\n  [7d9f7c33] Accessors v0.1.20\n  [79e6a3ab] Adapt v3.4.0\n  [dce04be8] ArgCheck v2.3.0\n  [ec485272] ArnoldiMethod v0.2.0\n  [4fba245c] ArrayInterface v6.0.23\n  [30b0a656] ArrayInterfaceCore v0.1.20\n  [6ba088a2] ArrayInterfaceGPUArrays v0.2.1\n  [015c0d05] ArrayInterfaceOffsetArrays v0.1.6\n  [b0d46f97] ArrayInterfaceStaticArrays v0.1.4\n  [dd5226c6] ArrayInterfaceStaticArraysCore v0.1.0\n  [a2b0951a] ArrayInterfaceTracker v0.1.1\n  [4c555306] ArrayLayouts v0.8.11\n  [15f4f7f2] AutoHashEquals v0.2.0\n  [ab4f0b2a] BFloat16s v0.2.0\n  [aae01518] BandedMatrices v0.17.6\n  [198e06fe] BangBang v0.3.36\n  [9718e550] Baselet v0.1.1\n  [e2ed5e7c] Bijections v0.1.4\n  [62783981] BitTwiddlingConvenienceFunctions v0.1.4\n  [8e7c35d0] BlockArrays v0.16.20\n  [ffab5731] BlockBandedMatrices v0.11.9\n  [764a87c0] BoundaryValueDiffEq v2.9.0\n  [fa961155] CEnum v0.4.2\n  [2a0fbf3d] CPUSummary v0.1.25\n  [00ebfdb7] CSTParser v3.3.6\n  [052768ef] CUDA v3.12.0\n  [49dc2e85] Calculus v0.5.1\n  [7057c7e9] Cassette v0.3.10\n  [479239e8] Catalyst v12.2.1\n  [082447d4] ChainRules v1.44.6\n  [d360d2e6] ChainRulesCore v1.15.4\n  [9e997f8a] ChangesOfVariables v0.1.4\n  [fb6a15b2] CloseOpenIntervals v0.1.10\n  [944b1d66] CodecZlib v0.7.0\n  [35d6a980] ColorSchemes v3.19.0\n  [3da002f7] ColorTypes v0.11.4\n  [c3611d14] ColorVectorSpace v0.9.9\n  [5ae59095] Colors v0.12.8\n  [861a8166] Combinatorics v1.0.2\n  [a80b9123] CommonMark v0.8.6\n  [38540f10] CommonSolve v0.2.1\n  [bbf7d656] CommonSubexpressions v0.3.0\n⌅ [34da2185] Compat v3.46.0\n  [b0b7db55] ComponentArrays v0.13.2\n  [b152e2b5] CompositeTypes v0.1.2\n  [a33af91c] CompositionsBase v0.1.1\n  [8f4d0f93] Conda v1.7.0\n  [88cd18e8] ConsoleProgressMonitor v0.1.2\n  [187b0558] ConstructionBase v1.4.1\n  [6add18c4] ContextVariablesX v0.1.2\n  [d38c429a] Contour v0.6.2\n  [adafc99b] CpuId v0.3.1\n  [a8cc5b0e] Crayons v4.1.1\n  [8a292aeb] Cuba v2.2.0\n  [667455a9] Cubature v1.5.1\n  [9a962f9c] DataAPI v1.10.0\n  [82cc6244] DataInterpolations v3.10.1\n  [864edb3b] DataStructures v0.18.13\n  [e2d170a0] DataValueInterfaces v1.0.0\n  [244e2a9f] DefineSingletons v0.1.2\n  [bcd4f6db] DelayDiffEq v5.37.1\n  [b429d917] DensityInterface v0.4.0\n  [2b5f629d] DiffEqBase v6.100.0\n  [459566f4] DiffEqCallbacks v2.24.1\n  [f3b72e0c] DiffEqDevTools v2.31.2\n  [aae7a2af] DiffEqFlux v1.52.0\n  [77a26b50] DiffEqNoiseProcess v5.12.3\n  [9fdde737] DiffEqOperators v4.43.1\n  [055956cb] DiffEqPhysics v3.9.0\n  [41bf760c] DiffEqSensitivity v6.79.0\n  [163ba53b] DiffResults v1.0.3\n  [b552c78f] DiffRules v1.11.1\n  [0c46a032] DifferentialEquations v7.3.0\n  [b4f34e82] Distances v0.10.7\n  [31c24e10] Distributions v0.25.70\n  [ced4e74d] DistributionsAD v0.6.42\n⌅ [ffbed154] DocStringExtensions v0.8.6\n  [5b8099bc] DomainSets v0.5.13\n  [fa6b7ba4] DualNumbers v0.6.8\n  [7c1d4256] DynamicPolynomials v0.4.5\n  [da5c29d0] EllipsisNotation v1.6.0\n  [7da242da] Enzyme v0.10.4\n  [d4d017d3] ExponentialUtilities v1.18.0\n  [e2ba6199] ExprTools v0.1.8\n  [411431e0] Extents v0.1.1\n  [c87230d0] FFMPEG v0.4.1\n  [cc61a311] FLoops v0.2.0\n  [b9860ae5] FLoopsBase v0.1.1\n  [7034ab61] FastBroadcast v0.2.1\n  [9aa1b823] FastClosures v0.3.2\n  [29a986be] FastLapackInterface v1.2.6\n  [1a297f60] FillArrays v0.13.4\n⌃ [6a86dc24] FiniteDiff v2.13.1\n  [53c48c17] FixedPointNumbers v0.8.4\n  [587475ba] Flux v0.13.5\n  [9c68100b] FoldsThreads v0.1.1\n  [59287772] Formatting v0.4.2\n  [f6369f11] ForwardDiff v0.10.32\n  [069b7b12] FunctionWrappers v1.1.2\n  [77dc65aa] FunctionWrappersWrappers v0.1.1\n  [d9f16b24] Functors v0.3.0\n  [0c68f7d7] GPUArrays v8.5.0\n  [46192b85] GPUArraysCore v0.1.2\n  [61eb1bfa] GPUCompiler v0.16.3\n  [28b8d3ca] GR v0.66.2\n  [c145ed77] GenericSchur v0.5.3\n  [cf35fbd7] GeoInterface v1.0.1\n  [5c1252a2] GeometryBasics v0.4.3\n  [86223c79] Graphs v1.7.2\n  [42e2da0e] Grisu v1.0.2\n  [0b43b601] Groebner v0.2.10\n  [d5909c97] GroupsCore v0.4.0\n  [19dc6840] HCubature v1.5.0\n  [cd3eb016] HTTP v1.3.3\n⌅ [eafb193a] Highlights v0.4.5\n  [3e5b6fbb] HostCPUFeatures v0.1.8\n  [34004b35] HypergeometricFunctions v0.3.11\n  [7073ff75] IJulia v1.23.3\n  [7869d1d1] IRTools v0.4.6\n  [615f187c] IfElse v0.1.1\n  [d25df0c9] Inflate v0.1.3\n  [83e8ac13] IniFile v0.5.1\n  [22cec73e] InitialValues v0.3.1\n  [18e54dd8] IntegerMathUtils v0.1.0\n  [8197267c] IntervalSets v0.7.2\n  [3587e190] InverseFunctions v0.1.7\n  [92d709cd] IrrationalConstants v0.1.1\n  [c8e1da08] IterTools v1.4.0\n  [42fd0dbc] IterativeSolvers v0.9.2\n  [82899510] IteratorInterfaceExtensions v1.0.0\n  [692b3bcd] JLLWrappers v1.4.1\n  [682c06a0] JSON v0.21.3\n  [98e50ef6] JuliaFormatter v1.0.9\n  [b14d175d] JuliaVariables v0.2.4\n  [ccbc3e58] JumpProcesses v9.2.0\n  [ef3ab10e] KLU v0.3.0\n  [ba0b0d4f] Krylov v0.8.3\n  [0b1a1467] KrylovKit v0.5.4\n  [929cbde3] LLVM v4.14.0\n  [b964fa9f] LaTeXStrings v1.3.0\n  [2ee39098] LabelledArrays v1.12.0\n  [23fbe1c1] Latexify v0.15.16\n  [a5e1c1ea] LatinHypercubeSampling v1.8.0\n  [73f95e8e] LatticeRules v0.0.1\n  [10f19ff3] LayoutPointers v0.1.10\n  [50d2b5c4] Lazy v0.15.1\n  [5078a376] LazyArrays v0.22.11\n⌅ [d7e5e226] LazyBandedMatrices v0.7.17\n  [0fc2ff8b] LeastSquaresOptim v0.8.3\n  [1d6d02ad] LeftChildRightSiblingTrees v0.2.0\n  [2d8b4e74] LevyArea v1.0.0\n  [d3d80556] LineSearches v7.2.0\n  [7ed4a6bd] LinearSolve v1.26.0\n  [2ab3a3ac] LogExpFunctions v0.3.18\n  [e6f89c97] LoggingExtras v0.4.9\n  [bdcacae8] LoopVectorization v0.12.125\n  [b2108857] Lux v0.4.21\n  [d8e11817] MLStyle v0.4.13\n  [f1d291b0] MLUtils v0.2.10\n  [1914dd2f] MacroTools v0.5.9\n  [d125e4d3] ManualMemory v0.1.8\n  [a3b82374] MatrixFactorizations v0.9.2\n  [739be429] MbedTLS v1.1.5\n  [442fdcdd] Measures v0.3.1\n  [c03570c3] Memoize v0.4.4\n  [e9d8d322] Metatheory v1.3.4\n  [128add7d] MicroCollections v0.1.2\n  [e1d29d7a] Missings v1.0.2\n  [961ee093] ModelingToolkit v8.21.0\n⌅ [4886b29c] MonteCarloIntegration v0.0.3\n  [46d2c3a1] MuladdMacro v0.2.2\n  [102ac46a] MultivariatePolynomials v0.4.6\n  [ffc61752] Mustache v1.0.14\n  [d8a4904e] MutableArithmetics v1.0.4\n  [d41bc354] NLSolversBase v7.8.2\n  [2774e3e8] NLsolve v4.5.1\n  [872c559c] NNlib v0.8.9\n  [a00861dc] NNlibCUDA v0.2.4\n  [77ba4419] NaNMath v1.0.1\n  [71a1bf82] NameResolution v0.1.5\n⌅ [315f7962] NeuralPDE v4.11.0\n  [8913a72c] NonlinearSolve v0.3.22\n  [d8793406] ObjectFile v0.3.7\n  [6fe1bfb0] OffsetArrays v1.12.7\n  [429524aa] Optim v1.7.2\n  [3bd65402] Optimisers v0.2.9\n  [7f7a1694] Optimization v3.8.2\n  [253f991c] OptimizationFlux v0.1.0\n  [36348300] OptimizationOptimJL v0.1.2\n  [42dfb2eb] OptimizationOptimisers v0.1.0\n  [500b13db] OptimizationPolyalgorithms v0.1.0\n  [bac558e1] OrderedCollections v1.4.1\n  [1dea7af3] OrdinaryDiffEq v6.26.2\n  [90014a1f] PDMats v0.11.16\n  [d96e819e] Parameters v0.12.3\n  [69de0a69] Parsers v2.4.0\n  [ccf2f8ad] PlotThemes v3.0.0\n  [995b91a9] PlotUtils v1.3.0\n  [91a5bcdd] Plots v1.32.0\n  [e409e4f3] PoissonRandom v0.4.1\n  [f517fe37] Polyester v0.6.15\n  [1d0040c9] PolyesterWeave v0.1.9\n  [85a6dd25] PositiveFactorizations v0.2.4\n  [d236fae5] PreallocationTools v0.4.2\n  [21216c6a] Preferences v1.3.0\n  [8162dcfd] PrettyPrint v0.2.0\n  [27ebfcd6] Primes v0.5.3\n  [33c8b6b6] ProgressLogging v0.1.4\n  [92933f4c] ProgressMeter v1.7.2\n  [1fd47b50] QuadGK v2.5.0\n  [67601950] Quadrature v2.1.0\n  [e0ec9b62] QuadratureCubature v0.1.1\n  [8a4e6c94] QuasiMonteCarlo v0.2.9\n  [74087812] Random123 v1.6.0\n  [fb686558] RandomExtensions v0.4.3\n  [e6cf234a] RandomNumbers v1.5.3\n  [c1ae055f] RealDot v0.1.0\n  [3cdcf5f2] RecipesBase v1.2.1\n  [01d81517] RecipesPipeline v0.6.3\n  [731186ca] RecursiveArrayTools v2.32.0\n  [f2c3362d] RecursiveFactorization v0.2.12\n  [189a3867] Reexport v1.2.2\n  [42d2dcc6] Referenceables v0.1.2\n  [29dad682] RegularizationTools v0.6.0\n⌅ [05181044] RelocatableFolders v0.3.0\n  [ae029012] Requires v1.3.0\n  [ae5879a3] ResettableStacks v1.1.1\n  [37e2e3b7] ReverseDiff v1.14.1\n  [79098fc4] Rmath v0.7.0\n  [47965b36] RootedTrees v2.13.0\n  [7e49a35a] RuntimeGeneratedFunctions v0.5.3\n  [3cdde19b] SIMDDualNumbers v0.1.1\n  [94e857df] SIMDTypes v0.1.0\n  [476501e8] SLEEFPirates v0.6.35\n  [0bca4576] SciMLBase v1.53.2\n  [1ed8b502] SciMLSensitivity v7.7.0\n  [30cb0354] SciMLTutorials v1.0.0\n  [6c6a2e73] Scratch v1.1.1\n⌅ [efcf1570] Setfield v0.8.2\n  [605ecd9f] ShowCases v0.1.0\n  [992d4aef] Showoff v1.0.3\n  [777ac1f9] SimpleBufferStream v1.1.0\n  [699a6c99] SimpleTraits v0.9.4\n  [66db9d55] SnoopPrecompile v1.0.1\n  [ed01d8cd] Sobol v1.5.0\n  [b85f4697] SoftGlobalScope v1.1.0\n  [a2af1166] SortingAlgorithms v1.0.1\n  [47a9eef4] SparseDiffTools v1.26.2\n  [276daf66] SpecialFunctions v2.1.7\n  [171d559e] SplittablesBase v0.1.14\n  [860ef19b] StableRNGs v1.0.0\n  [aedffcd0] Static v0.7.6\n  [90137ffa] StaticArrays v1.5.6\n  [1e83bf80] StaticArraysCore v1.3.0\n  [82ae8749] StatsAPI v1.5.0\n  [2913bbd2] StatsBase v0.33.21\n  [4c63d2b9] StatsFuns v1.0.1\n  [9672c7b4] SteadyStateDiffEq v1.9.0\n  [789caeaf] StochasticDiffEq v6.53.0\n  [7792a7ef] StrideArraysCore v0.3.15\n  [69024149] StringEncodings v0.3.5\n  [09ab397b] StructArrays v0.6.12\n  [53d494c1] StructIO v0.3.0\n  [c3572dad] Sundials v4.10.1\n  [d1185830] SymbolicUtils v0.19.11\n  [0c5d862f] Symbolics v4.10.4\n  [3783bdb8] TableTraits v1.0.1\n  [bd369af6] Tables v1.7.0\n  [62fd8b95] TensorCore v0.1.1\n⌅ [8ea1fca8] TermInterface v0.2.3\n  [5d786b92] TerminalLoggers v0.1.6\n  [8290d209] ThreadingUtilities v0.5.0\n  [ac1d9e8a] ThreadsX v0.1.10\n  [a759f4b9] TimerOutputs v0.5.21\n  [0796e94c] Tokenize v0.5.24\n  [9f7883ad] Tracker v0.2.21\n  [3bb67fe8] TranscodingStreams v0.9.9\n  [28d57a85] Transducers v0.4.73\n  [a2a6695c] TreeViews v0.3.0\n  [d5829a12] TriangularSolve v0.1.13\n  [410a4b4d] Tricks v0.1.6\n  [5c2747f8] URIs v1.4.0\n  [3a884ed6] UnPack v1.0.2\n  [d9a01c3f] Underscores v3.0.0\n  [1cfade01] UnicodeFun v0.4.1\n  [1986cc42] Unitful v1.11.0\n  [41fe7b60] Unzip v0.2.0\n  [3d5dd08c] VectorizationBase v0.21.47\n  [81def892] VersionParsing v1.3.0\n  [19fa3120] VertexSafeGraphs v0.2.0\n⌃ [44d3d7a6] Weave v0.10.9\n  [ddb6d928] YAML v0.4.7\n  [c2297ded] ZMQ v1.2.1\n  [e88e6eb3] Zygote v0.6.47\n  [700de1a5] ZygoteRules v0.2.2\n  [6e34b625] Bzip2_jll v1.0.8+0\n  [83423d85] Cairo_jll v1.16.1+1\n  [3bed1096] Cuba_jll v4.2.2+1\n  [7bc98958] Cubature_jll v1.0.5+0\n  [5ae413db] EarCut_jll v2.2.3+0\n⌅ [7cc45869] Enzyme_jll v0.0.33+0\n  [2e619515] Expat_jll v2.4.8+0\n  [b22a6f82] FFMPEG_jll v4.4.2+0\n  [a3f928ae] Fontconfig_jll v2.13.93+0\n  [d7e528f0] FreeType2_jll v2.10.4+0\n  [559328eb] FriBidi_jll v1.0.10+0\n  [0656b61e] GLFW_jll v3.3.8+0\n  [d2c73de3] GR_jll v0.66.2+0\n  [78b55507] Gettext_jll v0.21.0+0\n  [7746bdde] Glib_jll v2.68.3+2\n  [3b182d85] Graphite2_jll v1.3.14+0\n  [2e76f6c2] HarfBuzz_jll v2.8.1+1\n  [aacddb02] JpegTurbo_jll v2.1.2+0\n  [c1c5ebd0] LAME_jll v3.100.1+0\n  [88015f11] LERC_jll v3.0.0+1\n  [dad2f222] LLVMExtra_jll v0.0.16+0\n  [dd4b983a] LZO_jll v2.10.1+0\n  [e9f186c6] Libffi_jll v3.2.2+1\n  [d4300ac3] Libgcrypt_jll v1.8.7+0\n  [7e76a0d4] Libglvnd_jll v1.3.0+3\n  [7add5ba3] Libgpg_error_jll v1.42.0+0\n  [94ce4f54] Libiconv_jll v1.16.1+1\n  [4b2f31a3] Libmount_jll v2.35.0+0\n  [89763e89] Libtiff_jll v4.4.0+0\n  [38a345b3] Libuuid_jll v2.36.0+0\n  [e7412a2a] Ogg_jll v1.3.5+1\n  [458c3c95] OpenSSL_jll v1.1.17+0\n  [efe28fd5] OpenSpecFun_jll v0.5.5+0\n  [91d4177d] Opus_jll v1.3.2+0\n  [2f80f16e] PCRE_jll v8.44.0+0\n  [30392449] Pixman_jll v0.40.1+0\n  [ea2cea3b] Qt5Base_jll v5.15.3+1\n  [f50d1b31] Rmath_jll v0.3.0+0\n  [fb77eaff] Sundials_jll v5.2.1+0\n  [a2964d1f] Wayland_jll v1.19.0+0\n  [2381bf8a] Wayland_protocols_jll v1.25.0+0\n  [02c8fc9c] XML2_jll v2.9.14+0\n  [aed1982a] XSLT_jll v1.1.34+0\n  [4f6342f7] Xorg_libX11_jll v1.6.9+4\n  [0c0b7dd1] Xorg_libXau_jll v1.0.9+4\n  [935fb764] Xorg_libXcursor_jll v1.2.0+4\n  [a3789734] Xorg_libXdmcp_jll v1.1.3+4\n  [1082639a] Xorg_libXext_jll v1.3.4+4\n  [d091e8ba] Xorg_libXfixes_jll v5.0.3+4\n  [a51aa0fd] Xorg_libXi_jll v1.7.10+4\n  [d1454406] Xorg_libXinerama_jll v1.1.4+4\n  [ec84b674] Xorg_libXrandr_jll v1.5.2+4\n  [ea2f1a96] Xorg_libXrender_jll v0.9.10+4\n  [14d82f49] Xorg_libpthread_stubs_jll v0.1.0+3\n  [c7cfdc94] Xorg_libxcb_jll v1.13.0+3\n  [cc61e674] Xorg_libxkbfile_jll v1.1.0+4\n  [12413925] Xorg_xcb_util_image_jll v0.4.0+1\n  [2def613f] Xorg_xcb_util_jll v0.4.0+1\n  [975044d2] Xorg_xcb_util_keysyms_jll v0.4.0+1\n  [0d47668e] Xorg_xcb_util_renderutil_jll v0.3.9+1\n  [c22f9ab0] Xorg_xcb_util_wm_jll v0.4.1+1\n  [35661453] Xorg_xkbcomp_jll v1.4.2+4\n  [33bec58e] Xorg_xkeyboard_config_jll v2.27.0+4\n  [c5fb5394] Xorg_xtrans_jll v1.4.0+3\n  [8f1865be] ZeroMQ_jll v4.3.4+0\n  [3161d3a3] Zstd_jll v1.5.2+0\n  [a4ae2306] libaom_jll v3.4.0+0\n  [0ac62f75] libass_jll v0.15.1+0\n  [f638f0a6] libfdk_aac_jll v2.0.2+0\n  [b53b4c65] libpng_jll v1.6.38+0\n  [a9144af2] libsodium_jll v1.0.20+0\n  [f27f6e37] libvorbis_jll v1.3.7+1\n  [1270edf5] x264_jll v2021.5.5+0\n  [dfaa095f] x265_jll v3.5.0+0\n  [d8fb68d0] xkbcommon_jll v1.4.1+0\n  [0dad84c5] ArgTools v1.1.1\n  [56f22d72] Artifacts\n  [2a0f44e3] Base64\n  [ade2ca70] Dates\n  [8bb1440f] DelimitedFiles\n  [8ba89e20] Distributed\n  [f43a241f] Downloads v1.6.0\n  [7b1f6079] FileWatching\n  [9fa8497b] Future\n  [b77e0a4c] InteractiveUtils\n  [4af54fe1] LazyArtifacts\n  [b27032c2] LibCURL v0.6.3\n  [76f85450] LibGit2\n  [8f399da3] Libdl\n  [37e2e46d] LinearAlgebra\n  [56ddb016] Logging\n  [d6f4376e] Markdown\n  [a63ad114] Mmap\n  [ca575930] NetworkOptions v1.2.0\n  [44cfe95a] Pkg v1.8.0\n  [de0858da] Printf\n  [3fa0cd96] REPL\n  [9a3f8284] Random\n  [ea8e919c] SHA v0.7.0\n  [9e88b42a] Serialization\n  [1a1011a3] SharedArrays\n  [6462fe0b] Sockets\n  [2f01184e] SparseArrays\n  [10745b16] Statistics\n  [4607b0f0] SuiteSparse\n  [fa267f1f] TOML v1.0.0\n  [a4e569a6] Tar v1.10.0\n  [8dfed614] Test\n  [cf7118a7] UUIDs\n  [4ec0a83e] Unicode\n  [e66e0078] CompilerSupportLibraries_jll v0.5.2+0\n  [deac9b47] LibCURL_jll v7.84.0+0\n  [29816b5a] LibSSH2_jll v1.10.2+0\n  [c8ffd9c3] MbedTLS_jll v2.28.0+0\n  [14a3606d] MozillaCACerts_jll v2022.2.1\n  [4536629a] OpenBLAS_jll v0.3.20+0\n  [05823500] OpenLibm_jll v0.8.1+0\n  [bea87d4a] SuiteSparse_jll v5.10.1+0\n  [83775a58] Zlib_jll v1.2.12+3\n  [8e850b90] libblastrampoline_jll v5.1.1+0\n  [8e850ede] nghttp2_jll v1.48.0+0\n  [3f19e933] p7zip_jll v17.4.0+0\nInfo Packages marked with ⌃ and ⌅ have new versions available, but those with ⌅ cannot be upgraded. To see why use `status --outdated -m`","category":"page"},{"location":"Testing/test/","page":"-","title":"-","text":"","category":"page"},{"location":"Testing/test/","page":"-","title":"-","text":"author: \"Chris Rackauckas\" title: \"Test\" –-","category":"page"},{"location":"Testing/test/","page":"-","title":"-","text":"This is a test of the builder system.  It often gets bumped manually.","category":"page"},{"location":"Testing/test/#Appendix","page":"-","title":"Appendix","text":"","category":"section"},{"location":"Testing/test/","page":"-","title":"-","text":"These tutorials are a part of the SciMLTutorials.jl repository, found at: https://github.com/SciML/SciMLTutorials.jl. For more information on high-performance scientific machine learning, check out the SciML Open Source Software Organization https://sciml.ai.","category":"page"},{"location":"Testing/test/","page":"-","title":"-","text":"To locally run this tutorial, do the following commands:","category":"page"},{"location":"Testing/test/","page":"-","title":"-","text":"using SciMLTutorials\nSciMLTutorials.weave_file(\"Testing\",\"test.jmd\")","category":"page"},{"location":"Testing/test/","page":"-","title":"-","text":"Computer Information:","category":"page"},{"location":"Testing/test/","page":"-","title":"-","text":"Julia Version 1.6.5\nCommit 9058264a69 (2021-12-19 12:30 UTC)\nPlatform Info:\n  OS: Linux (x86_64-pc-linux-gnu)\n  CPU: AMD EPYC 7502 32-Core Processor\n  WORD_SIZE: 64\n  LIBM: libopenlibm\n  LLVM: libLLVM-11.0.1 (ORCJIT, znver2)\nEnvironment:\n  JULIA_CPU_THREADS = 16\n  BUILDKITE_PLUGIN_JULIA_CACHE_DIR = /cache/julia-buildkite-plugin\n  JULIA_DEPOT_PATH = /cache/julia-buildkite-plugin/depots/a6029d3a-f78b-41ea-bc97-28aa57c6c6ea\n","category":"page"},{"location":"Testing/test/","page":"-","title":"-","text":"Package Information:","category":"page"},{"location":"Testing/test/","page":"-","title":"-","text":"      Status `/cache/build/default-amdci4-1/julialang/scimltutorials-dot-jl/tutorials/Testing/Project.toml`\n  [30cb0354] SciMLTutorials v0.9.0","category":"page"},{"location":"Testing/test/","page":"-","title":"-","text":"And the full manifest:","category":"page"},{"location":"Testing/test/","page":"-","title":"-","text":"      Status `/cache/build/default-amdci4-1/julialang/scimltutorials-dot-jl/tutorials/Testing/Manifest.toml`\n  [79e6a3ab] Adapt v3.3.0\n  [35d6a980] ColorSchemes v3.12.1\n  [3da002f7] ColorTypes v0.11.0\n  [5ae59095] Colors v0.12.8\n  [34da2185] Compat v3.30.0\n  [8f4d0f93] Conda v1.5.2\n  [d38c429a] Contour v0.5.7\n  [9a962f9c] DataAPI v1.6.0\n  [864edb3b] DataStructures v0.18.9\n  [e2d170a0] DataValueInterfaces v1.0.0\n  [ffbed154] DocStringExtensions v0.8.4\n  [c87230d0] FFMPEG v0.4.0\n  [53c48c17] FixedPointNumbers v0.8.4\n  [59287772] Formatting v0.4.2\n  [28b8d3ca] GR v0.57.4\n  [5c1252a2] GeometryBasics v0.3.12\n  [42e2da0e] Grisu v1.0.2\n  [cd3eb016] HTTP v0.9.9\n  [eafb193a] Highlights v0.4.5\n  [7073ff75] IJulia v1.23.2\n  [83e8ac13] IniFile v0.5.0\n  [c8e1da08] IterTools v1.3.0\n  [82899510] IteratorInterfaceExtensions v1.0.0\n  [692b3bcd] JLLWrappers v1.3.0\n  [682c06a0] JSON v0.21.1\n  [b964fa9f] LaTeXStrings v1.2.1\n  [23fbe1c1] Latexify v0.15.5\n  [1914dd2f] MacroTools v0.5.6\n  [739be429] MbedTLS v1.0.3\n  [442fdcdd] Measures v0.3.1\n  [e1d29d7a] Missings v1.0.0\n  [ffc61752] Mustache v1.0.10\n  [77ba4419] NaNMath v0.3.5\n  [bac558e1] OrderedCollections v1.4.1\n  [69de0a69] Parsers v1.1.0\n  [ccf2f8ad] PlotThemes v2.0.1\n  [995b91a9] PlotUtils v1.0.10\n  [91a5bcdd] Plots v1.15.2\n  [21216c6a] Preferences v1.2.2\n  [3cdcf5f2] RecipesBase v1.1.1\n  [01d81517] RecipesPipeline v0.3.2\n  [189a3867] Reexport v1.0.0\n  [ae029012] Requires v1.1.3\n  [30cb0354] SciMLTutorials v0.9.0\n  [6c6a2e73] Scratch v1.0.3\n  [992d4aef] Showoff v1.0.3\n  [b85f4697] SoftGlobalScope v1.1.0\n  [a2af1166] SortingAlgorithms v1.0.0\n  [90137ffa] StaticArrays v1.2.0\n  [82ae8749] StatsAPI v1.0.0\n  [2913bbd2] StatsBase v0.33.8\n  [09ab397b] StructArrays v0.5.1\n  [3783bdb8] TableTraits v1.0.1\n  [bd369af6] Tables v1.4.2\n  [5c2747f8] URIs v1.3.0\n  [81def892] VersionParsing v1.2.0\n  [44d3d7a6] Weave v0.10.8\n  [ddb6d928] YAML v0.4.6\n  [c2297ded] ZMQ v1.2.1\n  [6e34b625] Bzip2_jll v1.0.6+5\n  [83423d85] Cairo_jll v1.16.0+6\n  [5ae413db] EarCut_jll v2.1.5+1\n  [2e619515] Expat_jll v2.2.10+0\n  [b22a6f82] FFMPEG_jll v4.3.1+4\n  [a3f928ae] Fontconfig_jll v2.13.1+14\n  [d7e528f0] FreeType2_jll v2.10.1+5\n  [559328eb] FriBidi_jll v1.0.5+6\n  [0656b61e] GLFW_jll v3.3.4+0\n  [d2c73de3] GR_jll v0.57.2+0\n  [78b55507] Gettext_jll v0.21.0+0\n  [7746bdde] Glib_jll v2.68.1+0\n  [aacddb02] JpegTurbo_jll v2.0.1+3\n  [c1c5ebd0] LAME_jll v3.100.0+3\n  [dd4b983a] LZO_jll v2.10.1+0\n  [dd192d2f] LibVPX_jll v1.9.0+1\n  [e9f186c6] Libffi_jll v3.2.2+0\n  [d4300ac3] Libgcrypt_jll v1.8.7+0\n  [7e76a0d4] Libglvnd_jll v1.3.0+3\n  [7add5ba3] Libgpg_error_jll v1.42.0+0\n  [94ce4f54] Libiconv_jll v1.16.1+0\n  [4b2f31a3] Libmount_jll v2.35.0+0\n  [89763e89] Libtiff_jll v4.1.0+2\n  [38a345b3] Libuuid_jll v2.36.0+0\n  [e7412a2a] Ogg_jll v1.3.4+2\n  [458c3c95] OpenSSL_jll v1.1.1+6\n  [91d4177d] Opus_jll v1.3.1+3\n  [2f80f16e] PCRE_jll v8.44.0+0\n  [30392449] Pixman_jll v0.40.1+0\n  [ea2cea3b] Qt5Base_jll v5.15.2+0\n  [a2964d1f] Wayland_jll v1.17.0+4\n  [2381bf8a] Wayland_protocols_jll v1.18.0+4\n  [02c8fc9c] XML2_jll v2.9.12+0\n  [aed1982a] XSLT_jll v1.1.34+0\n  [4f6342f7] Xorg_libX11_jll v1.6.9+4\n  [0c0b7dd1] Xorg_libXau_jll v1.0.9+4\n  [935fb764] Xorg_libXcursor_jll v1.2.0+4\n  [a3789734] Xorg_libXdmcp_jll v1.1.3+4\n  [1082639a] Xorg_libXext_jll v1.3.4+4\n  [d091e8ba] Xorg_libXfixes_jll v5.0.3+4\n  [a51aa0fd] Xorg_libXi_jll v1.7.10+4\n  [d1454406] Xorg_libXinerama_jll v1.1.4+4\n  [ec84b674] Xorg_libXrandr_jll v1.5.2+4\n  [ea2f1a96] Xorg_libXrender_jll v0.9.10+4\n  [14d82f49] Xorg_libpthread_stubs_jll v0.1.0+3\n  [c7cfdc94] Xorg_libxcb_jll v1.13.0+3\n  [cc61e674] Xorg_libxkbfile_jll v1.1.0+4\n  [12413925] Xorg_xcb_util_image_jll v0.4.0+1\n  [2def613f] Xorg_xcb_util_jll v0.4.0+1\n  [975044d2] Xorg_xcb_util_keysyms_jll v0.4.0+1\n  [0d47668e] Xorg_xcb_util_renderutil_jll v0.3.9+1\n  [c22f9ab0] Xorg_xcb_util_wm_jll v0.4.1+1\n  [35661453] Xorg_xkbcomp_jll v1.4.2+4\n  [33bec58e] Xorg_xkeyboard_config_jll v2.27.0+4\n  [c5fb5394] Xorg_xtrans_jll v1.4.0+3\n  [8f1865be] ZeroMQ_jll v4.3.2+6\n  [3161d3a3] Zstd_jll v1.5.0+0\n  [0ac62f75] libass_jll v0.14.0+4\n  [f638f0a6] libfdk_aac_jll v0.1.6+4\n  [b53b4c65] libpng_jll v1.6.38+0\n  [a9144af2] libsodium_jll v1.0.20+0\n  [f27f6e37] libvorbis_jll v1.3.6+6\n  [1270edf5] x264_jll v2020.7.14+2\n  [dfaa095f] x265_jll v3.0.0+3\n  [d8fb68d0] xkbcommon_jll v0.9.1+5\n  [0dad84c5] ArgTools\n  [56f22d72] Artifacts\n  [2a0f44e3] Base64\n  [ade2ca70] Dates\n  [8bb1440f] DelimitedFiles\n  [8ba89e20] Distributed\n  [f43a241f] Downloads\n  [7b1f6079] FileWatching\n  [b77e0a4c] InteractiveUtils\n  [b27032c2] LibCURL\n  [76f85450] LibGit2\n  [8f399da3] Libdl\n  [37e2e46d] LinearAlgebra\n  [56ddb016] Logging\n  [d6f4376e] Markdown\n  [a63ad114] Mmap\n  [ca575930] NetworkOptions\n  [44cfe95a] Pkg\n  [de0858da] Printf\n  [3fa0cd96] REPL\n  [9a3f8284] Random\n  [ea8e919c] SHA\n  [9e88b42a] Serialization\n  [1a1011a3] SharedArrays\n  [6462fe0b] Sockets\n  [2f01184e] SparseArrays\n  [10745b16] Statistics\n  [fa267f1f] TOML\n  [a4e569a6] Tar\n  [8dfed614] Test\n  [cf7118a7] UUIDs\n  [4ec0a83e] Unicode\n  [e66e0078] CompilerSupportLibraries_jll\n  [deac9b47] LibCURL_jll\n  [29816b5a] LibSSH2_jll\n  [c8ffd9c3] MbedTLS_jll\n  [14a3606d] MozillaCACerts_jll\n  [83775a58] Zlib_jll\n  [8e850ede] nghttp2_jll\n  [3f19e933] p7zip_jll","category":"page"},{"location":"exercises/02-workshop_solutions/#SciML-Workshop-Exercise-Solutions","page":"SciML Workshop Exercise Solutions","title":"SciML Workshop Exercise Solutions","text":"","category":"section"},{"location":"exercises/02-workshop_solutions/","page":"SciML Workshop Exercise Solutions","title":"SciML Workshop Exercise Solutions","text":"using DifferentialEquations\nusing Sundials\nusing BenchmarkTools\nusing Plots","category":"page"},{"location":"exercises/02-workshop_solutions/#Problem-1:-Investigating-Sources-of-Randomness-and-Uncertainty-in-a-Biological-System","page":"SciML Workshop Exercise Solutions","title":"Problem 1: Investigating Sources of Randomness and Uncertainty in a Biological System","text":"","category":"section"},{"location":"exercises/02-workshop_solutions/#Part-1:-Simulating-the-Oregonator-ODE-model","page":"SciML Workshop Exercise Solutions","title":"Part 1: Simulating the Oregonator ODE model","text":"","category":"section"},{"location":"exercises/02-workshop_solutions/","page":"SciML Workshop Exercise Solutions","title":"SciML Workshop Exercise Solutions","text":"using DifferentialEquations, Plots\nfunction orego(du,u,p,t)\n  s,q,w = p\n  y1,y2,y3 = u\n  du[1] = s*(y2+y1*(1-q*y1-y2))\n  du[2] = (y3-(1+y1)*y2)/s\n  du[3] = w*(y1-y3)\nend\np = [77.27,8.375e-6,0.161]\nprob = ODEProblem(orego,[1.0,2.0,3.0],(0.0,360.0),p)\nsol = solve(prob)\nplot(sol)","category":"page"},{"location":"exercises/02-workshop_solutions/","page":"SciML Workshop Exercise Solutions","title":"SciML Workshop Exercise Solutions","text":"(Image: )","category":"page"},{"location":"exercises/02-workshop_solutions/","page":"SciML Workshop Exercise Solutions","title":"SciML Workshop Exercise Solutions","text":"plot(sol,vars=(1,2,3))","category":"page"},{"location":"exercises/02-workshop_solutions/","page":"SciML Workshop Exercise Solutions","title":"SciML Workshop Exercise Solutions","text":"(Image: )","category":"page"},{"location":"exercises/02-workshop_solutions/#Part-2:-Investigating-Stiffness","page":"SciML Workshop Exercise Solutions","title":"Part 2: Investigating Stiffness","text":"","category":"section"},{"location":"exercises/02-workshop_solutions/","page":"SciML Workshop Exercise Solutions","title":"SciML Workshop Exercise Solutions","text":"using BenchmarkTools\nprob = ODEProblem(orego,[1.0,2.0,3.0],(0.0,50.0),p)\n@btime sol = solve(prob,Tsit5())","category":"page"},{"location":"exercises/02-workshop_solutions/","page":"SciML Workshop Exercise Solutions","title":"SciML Workshop Exercise Solutions","text":"893.348 ms (8723143 allocations: 920.67 MiB)\nretcode: Success\nInterpolation: specialized 4th order \"free\" interpolation\nt: 872306-element Array{Float64,1}:\n  0.0\n  0.01618926718934831\n  0.02355386004837834\n  0.03818038870154586\n  0.050503515877727514\n  0.06810672932191658\n  0.08676359998206734\n  0.11145368602241688\n  0.14105967462147356\n  0.18104879156165962\n  ⋮\n 49.99977330536325\n 49.99980456142745\n 49.999835817515255\n 49.999867073624586\n 49.999898329755446\n 49.99992958590576\n 49.99996084207554\n 49.999992098266844\n 50.0\nu: 872306-element Array{Array{Float64,1},1}:\n [1.0, 2.0, 3.0]\n [1.7128564042197614, 1.9996098373795999, 2.9959141611121862]\n [1.8376268914687968, 1.9993653073090198, 2.994474646468457]\n [1.9480445809808178, 1.9988333244430836, 2.991907642632475]\n [1.9807789479174538, 1.998364632682339, 2.989876120098015]\n [1.996520358969301, 1.9976843022063284, 2.9870473687154533]\n [2.0012471416469095, 1.9969587120867922, 2.9840850652644586]\n [2.003267094253373, 1.9959962346456372, 2.980190667568818]\n [2.0046071951018165, 1.9948405279663373, 2.9755485736940304]\n [2.0062040975915965, 1.9932773146432707, 2.969322732597494]\n ⋮\n [1.00114451241949, 1453.0173573419604, 414.83224206133156]\n [1.0011445128905938, 1453.0163492345089, 414.8301595725294]\n [1.001144513536549, 1453.0153411262695, 414.82807709263454]\n [1.001144514166616, 1453.014333017309, 414.82599462178484]\n [1.0011445147807905, 1453.013324907627, 414.8239121599803]\n [1.0011445151883325, 1453.0123167972909, 414.82182970735875]\n [1.0011445153892404, 1453.0113086863003, 414.8197472639202]\n [1.001144515574252, 1453.0103005745884, 414.8176648295267]\n [1.0008765717435082, 1453.0100456736175, 414.8171383809634]","category":"page"},{"location":"exercises/02-workshop_solutions/","page":"SciML Workshop Exercise Solutions","title":"SciML Workshop Exercise Solutions","text":"@btime sol = solve(prob,Rodas5())","category":"page"},{"location":"exercises/02-workshop_solutions/","page":"SciML Workshop Exercise Solutions","title":"SciML Workshop Exercise Solutions","text":"534.668 μs (1907 allocations: 130.11 KiB)\nretcode: Success\nInterpolation: 3rd order Hermite\nt: 110-element Array{Float64,1}:\n  0.0\n  0.019615259849088615\n  0.029598314714131158\n  0.04705295553350644\n  0.06489958093933189\n  0.08933251171067431\n  0.12069400166576917\n  0.16655311655246774\n  0.24089140897016648\n  0.39558909491704786\n  ⋮\n 26.756905610888992\n 27.982111658219903\n 29.768997154114096\n 32.21837697976615\n 35.093850201346655\n 38.49798110093118\n 42.33811919585127\n 46.60842194880463\n 50.0\nu: 110-element Array{Array{Float64,1},1}:\n [1.0, 2.0, 3.0]\n [1.7804115041903392, 1.9994992840408727, 2.995224421497252]\n [1.898773632635922, 1.9991507098568697, 2.9933805881501456]\n [1.9745775749460168, 1.9984968888022705, 2.9904382700551317]\n [1.9949959346655894, 1.9978087397951183, 2.9875591897227847]\n [2.0015958931121642, 1.9968586608477479, 2.98367866834122]\n [2.003748190575679, 1.9956356930368464, 2.9787387129953866]\n [2.0056429388535917, 1.9938442509772465, 2.9715736894920433]\n [2.0085949421229565, 1.9909335157971781, 2.960099467726684]\n [2.014815188384092, 1.9848502001186519, 2.936770263171178]\n ⋮\n [1.0009510454262696, 1052.1681949981978, 17454.97704553619]\n [1.000790082105047, 1266.4223517298105, 14330.342720311946]\n [1.0006713873660182, 1490.2781714142227, 10747.93771088393]\n [1.000598803847115, 1670.9447027478102, 7245.705166049239]\n [1.000568993307521, 1758.4723173221284, 4560.988616721742]\n [1.000569273504183, 1757.6100577789323, 2636.982996349979]\n [1.000594225030407, 1683.8471494545056, 1421.4818618119598]\n [1.0006409946157637, 1561.0560213127278, 715.2527024515273]\n [1.0006887475677544, 1452.8969192375328, 414.7220773988324]","category":"page"},{"location":"exercises/02-workshop_solutions/#(Optional)-Part-3:-Specifying-Analytical-Jacobians-(I)","page":"SciML Workshop Exercise Solutions","title":"(Optional) Part 3: Specifying Analytical Jacobians (I)","text":"","category":"section"},{"location":"exercises/02-workshop_solutions/#(Optional)-Part-4:-Automatic-Symbolicification-and-Analytical-Jacobian-Calculations","page":"SciML Workshop Exercise Solutions","title":"(Optional) Part 4: Automatic Symbolicification and Analytical Jacobian Calculations","text":"","category":"section"},{"location":"exercises/02-workshop_solutions/#Part-5:-Adding-stochasticity-with-stochastic-differential-equations","page":"SciML Workshop Exercise Solutions","title":"Part 5: Adding stochasticity with stochastic differential equations","text":"","category":"section"},{"location":"exercises/02-workshop_solutions/","page":"SciML Workshop Exercise Solutions","title":"SciML Workshop Exercise Solutions","text":"function orego(du,u,p,t)\n  s,q,w = p\n  y1,y2,y3 = u\n  du[1] = s*(y2+y1*(1-q*y1-y2))\n  du[2] = (y3-(1+y1)*y2)/s\n  du[3] = w*(y1-y3)\nend\nfunction g(du,u,p,t)\n  du[1] = 0.1u[1]\n  du[2] = 0.1u[2]\n  du[3] = 0.1u[3]\nend\np = [77.27,8.375e-6,0.161]\nprob = SDEProblem(orego,g,[1.0,2.0,3.0],(0.0,30.0),p)\nsol = solve(prob,SOSRI())\nplot(sol)","category":"page"},{"location":"exercises/02-workshop_solutions/","page":"SciML Workshop Exercise Solutions","title":"SciML Workshop Exercise Solutions","text":"(Image: )","category":"page"},{"location":"exercises/02-workshop_solutions/","page":"SciML Workshop Exercise Solutions","title":"SciML Workshop Exercise Solutions","text":"sol = solve(prob,ImplicitRKMil()); plot(sol)","category":"page"},{"location":"exercises/02-workshop_solutions/","page":"SciML Workshop Exercise Solutions","title":"SciML Workshop Exercise Solutions","text":"Error: InexactError: Int64(Inf)","category":"page"},{"location":"exercises/02-workshop_solutions/","page":"SciML Workshop Exercise Solutions","title":"SciML Workshop Exercise Solutions","text":"sol = solve(prob,ImplicitRKMil()); plot(sol)","category":"page"},{"location":"exercises/02-workshop_solutions/","page":"SciML Workshop Exercise Solutions","title":"SciML Workshop Exercise Solutions","text":"Error: InexactError: Int64(Inf)","category":"page"},{"location":"exercises/02-workshop_solutions/#Part-6:-Gillespie-jump-models-of-discrete-stochasticity","page":"SciML Workshop Exercise Solutions","title":"Part 6: Gillespie jump models of discrete stochasticity","text":"","category":"section"},{"location":"exercises/02-workshop_solutions/#Part-7:-Probabilistic-Programming-/-Bayesian-Parameter-Estimation-with-DiffEqBayes.jl-Turing.jl-(I)","page":"SciML Workshop Exercise Solutions","title":"Part 7: Probabilistic Programming / Bayesian Parameter Estimation with DiffEqBayes.jl + Turing.jl (I)","text":"","category":"section"},{"location":"exercises/02-workshop_solutions/","page":"SciML Workshop Exercise Solutions","title":"SciML Workshop Exercise Solutions","text":"The data was generated with:","category":"page"},{"location":"exercises/02-workshop_solutions/","page":"SciML Workshop Exercise Solutions","title":"SciML Workshop Exercise Solutions","text":"function orego(du,u,p,t)\n  s,q,w = p\n  y1,y2,y3 = u\n  du[1] = s*(y2+y1*(1-q*y1-y2))\n  du[2] = (y3-(1+y1)*y2)/s\n  du[3] = w*(y1-y3)\nend\np = [60.0,1e-5,0.2]\nprob = ODEProblem(orego,[1.0,2.0,3.0],(0.0,30.0),p)\nsol = solve(prob,Rodas5(),abstol=1/10^14,reltol=1/10^14)","category":"page"},{"location":"exercises/02-workshop_solutions/","page":"SciML Workshop Exercise Solutions","title":"SciML Workshop Exercise Solutions","text":"retcode: Success\nInterpolation: 3rd order Hermite\nt: 48825-element Array{Float64,1}:\n  0.0\n  0.0001377354452002734\n  0.0002010718419122773\n  0.0003021998626318717\n  0.0004033278833514661\n  0.0005062369821758017\n  0.0006097468311490204\n  0.0007142127440433809\n  0.0008192699078400218\n  0.0009249477742217067\n  ⋮\n 29.8029621721172\n 29.830644478725933\n 29.858326785334665\n 29.886009659186307\n 29.91369253303795\n 29.94137540688959\n 29.96906121150096\n 29.99674701611233\n 30.0\nu: 48825-element Array{Array{Float64,1},1}:\n [1.0, 2.0, 3.0]\n [1.0082299897608653, 1.9999976854327, 2.9999450200919755]\n [1.0119917072902584, 1.999996608412124, 2.999919814481464]\n [1.0179684138472678, 1.9999948722835914, 2.99987966834307]\n [1.0239089650942212, 1.9999931160074038, 2.9998396435319274]\n [1.029917251895588, 1.9999913082422207, 2.999799037595289]\n [1.0359233048539687, 1.999989469133448, 2.9997583198166615]\n [1.0419471308701034, 1.9999875920280812, 2.9997173524755154]\n [1.0479670917315083, 1.9999856831456868, 2.9996762806603012]\n [1.0539844577981918, 1.9999837417184405, 2.99963509426064]\n ⋮\n [1.000649179056226, 1541.3915652677524, 2704.0497424834743]\n [1.0006492543168537, 1541.2130026445143, 2689.1257668560265]\n [1.0006493324193109, 1541.027741407077, 2674.2841889364954]\n [1.0006494133487425, 1540.8358216266624, 2659.5242521879404]\n [1.0006494970871955, 1540.6372908555195, 2644.845809127133]\n [1.0006495836184481, 1540.4321926696598, 2630.248409804933]\n [1.0006496729360377, 1540.220547649861, 2615.7300741273025]\n [1.0006497650150368, 1540.0024202595741, 2601.291906654189]\n [1.00064977601455, 1539.9763674790563, 2599.600715743143]","category":"page"},{"location":"exercises/02-workshop_solutions/#(Optional)-Part-8:-Using-DiffEqBiological's-Reaction-Network-DSL","page":"SciML Workshop Exercise Solutions","title":"(Optional) Part 8: Using DiffEqBiological's Reaction Network DSL","text":"","category":"section"},{"location":"exercises/02-workshop_solutions/#Problem-2:-Fitting-Hybrid-Delay-Pharmacokinetic-Models-with-Automated-Responses-(B)","page":"SciML Workshop Exercise Solutions","title":"Problem 2: Fitting Hybrid Delay Pharmacokinetic Models with Automated Responses (B)","text":"","category":"section"},{"location":"exercises/02-workshop_solutions/#Part-1:-Defining-an-ODE-with-Predetermined-Doses","page":"SciML Workshop Exercise Solutions","title":"Part 1: Defining an ODE with Predetermined Doses","text":"","category":"section"},{"location":"exercises/02-workshop_solutions/","page":"SciML Workshop Exercise Solutions","title":"SciML Workshop Exercise Solutions","text":"function onecompartment(du,u,p,t)\n  Ka,Ke = p\n  du[1] = -Ka*u[1]\n  du[2] =  Ka*u[1] - Ke*u[2]\nend\np = (Ka=2.268,Ke=0.07398)\nprob = ODEProblem(onecompartment,[100.0,0.0],(0.0,90.0),p)\n\ntstops = [24,48,72]\ncondition(u,t,integrator) = t ∈ tstops\naffect!(integrator) = (integrator.u[1] += 100)\ncb = DiscreteCallback(condition,affect!)\nsol = solve(prob,Tsit5(),callback=cb,tstops=tstops)\nplot(sol)","category":"page"},{"location":"exercises/02-workshop_solutions/","page":"SciML Workshop Exercise Solutions","title":"SciML Workshop Exercise Solutions","text":"(Image: )","category":"page"},{"location":"exercises/02-workshop_solutions/#Part-2:-Adding-Delays","page":"SciML Workshop Exercise Solutions","title":"Part 2: Adding Delays","text":"","category":"section"},{"location":"exercises/02-workshop_solutions/","page":"SciML Workshop Exercise Solutions","title":"SciML Workshop Exercise Solutions","text":"function onecompartment_delay(du,u,h,p,t)\n  Ka,Ke,τ = p\n  delayed_depot = h(p,t-τ)[1]\n  du[1] = -Ka*u[1]\n  du[2] =  Ka*delayed_depot - Ke*u[2]\nend\np = (Ka=2.268,Ke=0.07398,τ=6.0)\nh(p,t) = [0.0,0.0]\nprob = DDEProblem(onecompartment_delay,[100.0,0.0],h,(0.0,90.0),p)\n\ntstops = [24,48,72]\ncondition(u,t,integrator) = t ∈ tstops\naffect!(integrator) = (integrator.u[1] += 100)\ncb = DiscreteCallback(condition,affect!)\nsol = solve(prob,MethodOfSteps(Rosenbrock23()),callback=cb,tstops=tstops)\nplot(sol)","category":"page"},{"location":"exercises/02-workshop_solutions/","page":"SciML Workshop Exercise Solutions","title":"SciML Workshop Exercise Solutions","text":"(Image: )","category":"page"},{"location":"exercises/02-workshop_solutions/#Part-3:-Automatic-Differentiation-(AD)-for-Optimization-(I)","page":"SciML Workshop Exercise Solutions","title":"Part 3: Automatic Differentiation (AD) for Optimization (I)","text":"","category":"section"},{"location":"exercises/02-workshop_solutions/#Part-4:-Fitting-Known-Quantities-with-DiffEqParamEstim.jl-Optim.jl","page":"SciML Workshop Exercise Solutions","title":"Part 4: Fitting Known Quantities with DiffEqParamEstim.jl + Optim.jl","text":"","category":"section"},{"location":"exercises/02-workshop_solutions/","page":"SciML Workshop Exercise Solutions","title":"SciML Workshop Exercise Solutions","text":"The data was generated with","category":"page"},{"location":"exercises/02-workshop_solutions/","page":"SciML Workshop Exercise Solutions","title":"SciML Workshop Exercise Solutions","text":"p = (Ka = 0.5, Ke = 0.1, τ = 4.0)","category":"page"},{"location":"exercises/02-workshop_solutions/","page":"SciML Workshop Exercise Solutions","title":"SciML Workshop Exercise Solutions","text":"(Ka = 0.5, Ke = 0.1, τ = 4.0)","category":"page"},{"location":"exercises/02-workshop_solutions/#Part-5:-Implementing-Control-Based-Logic-with-ContinuousCallbacks-(I)","page":"SciML Workshop Exercise Solutions","title":"Part 5: Implementing Control-Based Logic with ContinuousCallbacks (I)","text":"","category":"section"},{"location":"exercises/02-workshop_solutions/#Part-6:-Global-Sensitivity-Analysis-with-the-Morris-and-Sobol-Methods","page":"SciML Workshop Exercise Solutions","title":"Part 6: Global Sensitivity Analysis with the Morris and Sobol Methods","text":"","category":"section"},{"location":"exercises/02-workshop_solutions/#Problem-3:-Differential-Algebraic-Equation-Modeling-of-a-Double-Pendulum-(B)","page":"SciML Workshop Exercise Solutions","title":"Problem 3: Differential-Algebraic Equation Modeling of a Double Pendulum (B)","text":"","category":"section"},{"location":"exercises/02-workshop_solutions/#Part-1:-Simple-Introduction-to-DAEs:-Mass-Matrix-Robertson-Equations","page":"SciML Workshop Exercise Solutions","title":"Part 1: Simple Introduction to DAEs: Mass-Matrix Robertson Equations","text":"","category":"section"},{"location":"exercises/02-workshop_solutions/","page":"SciML Workshop Exercise Solutions","title":"SciML Workshop Exercise Solutions","text":"function f(du, u, p, t)\n    du[1] = -p[1]*u[1] + p[2]*u[2]*u[3]\n    du[2] = p[1]*u[1] - p[2]*u[2]*u[3] - p[3]*u[2]*u[2]\n    du[3] = u[1] + u[2] + u[3] - 1.\nend\nM = [1 0 0; 0 1 0; 0 0 0.]\np = [0.04, 10^4, 3e7]\nu0 = [1.,0.,0.]\ntspan = (0., 1e6)\nprob = ODEProblem(ODEFunction(f, mass_matrix = M), u0, tspan, p)\nsol = solve(prob, Rodas5())\nplot(sol, xscale=:log10, tspan=(1e-6, 1e5), layout=(3,1))","category":"page"},{"location":"exercises/02-workshop_solutions/","page":"SciML Workshop Exercise Solutions","title":"SciML Workshop Exercise Solutions","text":"(Image: )","category":"page"},{"location":"exercises/02-workshop_solutions/#Part-2:-Solving-the-Implicit-Robertson-Equations-with-IDA","page":"SciML Workshop Exercise Solutions","title":"Part 2: Solving the Implicit Robertson Equations with IDA","text":"","category":"section"},{"location":"exercises/02-workshop_solutions/","page":"SciML Workshop Exercise Solutions","title":"SciML Workshop Exercise Solutions","text":"# Robertson Equation DAE Implicit form\nfunction h(out, du, u, p, t)\n    out[1] = -p[1]*u[1] + p[2]*u[2]*u[3] - du[1]\n    out[2] = p[1]*u[1] - p[2]*u[2]*u[3] - p[3]*u[2]*u[2] - du[2]\n    out[3] = u[1] + u[2] + u[3] - 1.\nend\np = [0.04, 10^4, 3e7]\ndu0 = [-0.04, 0.04, 0.0]\nu0 = [1.,0.,0.]\ntspan = (0., 1e6)\ndifferential_vars = [true, true, false]\nprob = DAEProblem(h, du0, u0, tspan, p, differential_vars = differential_vars)\nsol = solve(prob, IDA())\nplot(sol, xscale=:log10, tspan=(1e-6, 1e5), layout=(3,1))","category":"page"},{"location":"exercises/02-workshop_solutions/","page":"SciML Workshop Exercise Solutions","title":"SciML Workshop Exercise Solutions","text":"(Image: )","category":"page"},{"location":"exercises/02-workshop_solutions/#Part-3:-Manual-Index-Reduction-of-the-Single-Pendulum","page":"SciML Workshop Exercise Solutions","title":"Part 3: Manual Index Reduction of the Single Pendulum","text":"","category":"section"},{"location":"exercises/02-workshop_solutions/","page":"SciML Workshop Exercise Solutions","title":"SciML Workshop Exercise Solutions","text":"Consider the equation: $ x^2 + y^2 = L $ Differentiating once with respect to time: $ 2x\\dot{x} + 2y\\dot{y} = 0 $ A second time: $ \\begin{align} {\\dot{x}}^2 + x\\ddot{x} + {\\dot{y}}^2 + y\\ddot{y} &= 0  \\\nu^2 + v^2 + x(\\frac{x}{mL}T) + y(\\frac{y}{mL}T - g) &= 0  \\\nu^2 + v^2 + \\frac{x^2 + y^2}{mL}T - yg &= 0 \\\nu^2 + v^2 + \\frac{T}{m} - yg &= 0 \\end{align} $","category":"page"},{"location":"exercises/02-workshop_solutions/","page":"SciML Workshop Exercise Solutions","title":"SciML Workshop Exercise Solutions","text":"Our final set of equations is hence $ \\begin{align}    \\ddot{x} &= \\frac{x}{mL}T \\\n   \\ddot{y} &= \\frac{y}{mL}T - g \\\n   \\dot{x} &= u \\\n   \\dot{y} &= v \\\n   u^2 + v^2 -yg + \\frac{T}{m} &= 0 \\end{align} $","category":"page"},{"location":"exercises/02-workshop_solutions/","page":"SciML Workshop Exercise Solutions","title":"SciML Workshop Exercise Solutions","text":"We finally obtain T into the third equation. This required two differentiations with respect to time, and so our system of equations went from index 3 to index 1. Now our solver can handle the index 1 system.","category":"page"},{"location":"exercises/02-workshop_solutions/#Part-4:-Single-Pendulum-Solution-with-IDA","page":"SciML Workshop Exercise Solutions","title":"Part 4: Single Pendulum Solution with IDA","text":"","category":"section"},{"location":"exercises/02-workshop_solutions/","page":"SciML Workshop Exercise Solutions","title":"SciML Workshop Exercise Solutions","text":"function f(out, da, a, p, t)\n   (L, m, g) = p\n   u, v, x, y, T = a\n   du, dv, dx, dy, dT = da\n   out[1] = x*T/(m*L) - du\n   out[2] = y*T/(m*L) - g - dv\n   out[3] = u - dx\n   out[4] = v - dy\n   out[5] = u^2 + v^2 - y*g + T/m\n   nothing\nend\n\n# Release pendulum from top right\nu0 = zeros(5)\nu0[3] = 1.0\ndu0 = zeros(5)\ndu0[2] = 9.81\n\np = [1,1,9.8]\ntspan = (0.,100.)\n\ndifferential_vars = [true, true, true, true, false]\nprob = DAEProblem(f, du0, u0, tspan, p, differential_vars = differential_vars)\nsol = solve(prob, IDA())\nplot(sol, vars=(3,4))","category":"page"},{"location":"exercises/02-workshop_solutions/","page":"SciML Workshop Exercise Solutions","title":"SciML Workshop Exercise Solutions","text":"(Image: )","category":"page"},{"location":"exercises/02-workshop_solutions/#Part-5:-Solving-the-Double-Penulum-DAE-System","page":"SciML Workshop Exercise Solutions","title":"Part 5: Solving the Double Penulum DAE System","text":"","category":"section"},{"location":"exercises/02-workshop_solutions/","page":"SciML Workshop Exercise Solutions","title":"SciML Workshop Exercise Solutions","text":"For the double pendulum: The equations for the second ball are the same as the single pendulum case. That is, the equations for the second ball are: $ \\begin{align}    \\ddot{x2} &= \\frac{x2}{m2L2}T2 \\\n   \\ddot{y2} &= \\frac{y2}{m2L2}T2 - g \\\n   \\dot{x2} &= u \\\n   \\dot{y2} &= v \\\n   u2^2 + v2^2 -y2g + \\frac{T2}{m2} &= 0 \\end{align} $ For the first ball, consider x1^2 + y1^2 = L $ $ \\begin{align} x1^2 + x2^2 &= L \\\n2x1\\dot{x1} + 2y1\\dot{y1} &= 0 \\\n\\dot{x1}^2 + \\dot{y1}^2 + x1(\\frac{x1}{m1L1}T1 - \\frac{x2}{m1L2}T2) + y1(\\frac{y1}{m1L1}T1 - g - \\frac{y2}{m1L2}T2) &= 0 \\\nu1^2 + v1^2 + \\frac{T1}{m1} - \\frac{x1x2 + y1y2}{m1L2}T2 &= 0 \\end{align} $","category":"page"},{"location":"exercises/02-workshop_solutions/","page":"SciML Workshop Exercise Solutions","title":"SciML Workshop Exercise Solutions","text":"So the final equations are: $ \\begin{align}    \\dot{u2} &= x2T2/(m2L2)    \\dot{v2} &= y2*T2/(m2*L2) - g    \\dot{x2} &= u2    \\dot{y2} &= v2    u2^2 + v2^2 -y2*g + \\frac{T2}{m_2} &=  0","category":"page"},{"location":"exercises/02-workshop_solutions/","page":"SciML Workshop Exercise Solutions","title":"SciML Workshop Exercise Solutions","text":"\\dot{u1} &= x1T1/(m1L1) - x2T2/(m2L2)    \\dot{v1} &= y1*T1/(m1*L1) - g - y2*T2/(m2*L2)    \\dot{x1} &= u1    \\dot{y1} &= v1    u1^2 + v1^2 + \\frac{T1}{m1} +                 \\frac{-x1*x2 - y1*y2}{m1L2}T2 - y1g &= 0 \\end{align} $","category":"page"},{"location":"exercises/02-workshop_solutions/","page":"SciML Workshop Exercise Solutions","title":"SciML Workshop Exercise Solutions","text":"function f(out, da, a, p, t)\n   L1, m1, L2, m2, g = p\n\n   u1, v1, x1, y1, T1,\n   u2, v2, x2, y2, T2 = a\n\n   du1, dv1, dx1, dy1, dT1,\n   du2, dv2, dx2, dy2, dT2 = da\n\n   out[1]  = x2*T2/(m2*L2) - du2\n   out[2]  = y2*T2/(m2*L2) - g - dv2\n   out[3]  = u2 - dx2\n   out[4]  = v2 - dy2\n   out[5]  = u2^2 + v2^2 -y2*g + T2/m2\n\n   out[6]  = x1*T1/(m1*L1) - x2*T2/(m2*L2) - du1\n   out[7]  = y1*T1/(m1*L1) - g - y2*T2/(m2*L2) - dv1\n   out[8]  = u1 - dx1\n   out[9]  = v1 - dy1\n   out[10] = u1^2 + v1^2 + T1/m1 +\n                (-x1*x2 - y1*y2)/(m1*L2)*T2 - y1*g\n   nothing\nend\n\n# Release pendulum from top right\nu0 = zeros(10)\nu0[3] = 1.0\nu0[8] = 1.0\ndu0 = zeros(10)\ndu0[2] = 9.8\ndu0[7] = 9.8\n\np = [1,1,1,1,9.8]\ntspan = (0.,100.)\n\ndifferential_vars = [true, true, true, true, false,\n                     true, true, true, true, false]\nprob = DAEProblem(f, du0, u0, tspan, p, differential_vars = differential_vars)\nsol = solve(prob, IDA())\n\nplot(sol, vars=(3,4))\nplot(sol, vars=(8,9))","category":"page"},{"location":"exercises/02-workshop_solutions/","page":"SciML Workshop Exercise Solutions","title":"SciML Workshop Exercise Solutions","text":"(Image: )","category":"page"},{"location":"exercises/02-workshop_solutions/#Problem-4:-Performance-Optimizing-and-Parallelizing-Semilinear-PDE-Solvers-(I)","page":"SciML Workshop Exercise Solutions","title":"Problem 4: Performance Optimizing and Parallelizing Semilinear PDE Solvers (I)","text":"","category":"section"},{"location":"exercises/02-workshop_solutions/#Part-1:-Implementing-the-BRUSS-PDE-System-as-ODEs","page":"SciML Workshop Exercise Solutions","title":"Part 1: Implementing the BRUSS PDE System as ODEs","text":"","category":"section"},{"location":"exercises/02-workshop_solutions/","page":"SciML Workshop Exercise Solutions","title":"SciML Workshop Exercise Solutions","text":"using DifferentialEquations, Sundials, Plots\n\n# initial condition\nfunction init_brusselator_2d(xyd)\n    N = length(xyd)\n    u = zeros(N, N, 2)\n    for I in CartesianIndices((N, N))\n        x = xyd[I[1]]\n        y = xyd[I[2]]\n        u[I,1] = 22*(y*(1-y))^(3/2)\n        u[I,2] = 27*(x*(1-x))^(3/2)\n    end\n    u\nend\n\nN = 32\n\nxyd_brusselator = range(0,stop=1,length=N)\n\nu0 = vec(init_brusselator_2d(xyd_brusselator))\n\ntspan = (0, 22.)\n\np = (3.4, 1., 10., xyd_brusselator)\n\nbrusselator_f(x, y, t) = ifelse((((x-0.3)^2 + (y-0.6)^2) <= 0.1^2) &&\n                                (t >= 1.1), 5., 0.)\n\n\nusing LinearAlgebra, SparseArrays\ndu = ones(N-1)\nD2 = spdiagm(-1 => du, 0=>fill(-2.0, N), 1 => du)\nD2[1, N] = D2[N, 1] = 1\nD2 = 1/step(xyd_brusselator)^2*D2\ntmp = Matrix{Float64}(undef, N, N)\nfunction brusselator_2d_op(du, u, (D2, tmp, p), t)\n    A, B, α, xyd = p\n    dx = step(xyd)\n    N = length(xyd)\n    α = α/dx^2\n    du = reshape(du, N, N, 2)\n    u = reshape(u, N, N, 2)\n    @views for i in axes(u, 3)\n        ui = u[:, :, i]\n        dui = du[:, :, i]\n        mul!(tmp, D2, ui)\n        mul!(dui, ui, D2')\n        dui .+= tmp\n    end\n\n    @inbounds begin\n        for I in CartesianIndices((N, N))\n            x = xyd[I[1]]\n            y = xyd[I[2]]\n            i = I[1]\n            j = I[2]\n\n            du[i,j,1] = α*du[i,j,1] + B + u[i,j,1]^2*u[i,j,2] - (A + 1)*u[i,j,1] + brusselator_f(x, y, t)\n            du[i,j,2] = α*du[i,j,2] + A*u[i,j,1] - u[i,j,1]^2*u[i,j,2]\n        end\n    end\n    nothing\nend\n\nprob1 = ODEProblem(brusselator_2d_op, u0, tspan, (D2, tmp, p))\n\nsol1 = @time solve(prob1, TRBDF2(autodiff=false));","category":"page"},{"location":"exercises/02-workshop_solutions/","page":"SciML Workshop Exercise Solutions","title":"SciML Workshop Exercise Solutions","text":"9.267829 seconds (8.02 M allocations: 575.955 MiB, 0.94% gc time)\nretcode: Success\nInterpolation: 3rd order Hermite\nt: 79-element Array{Float64,1}:\n  0.0\n  1.0522804268928948e-10\n  1.1575084695821841e-9\n  1.1680312738511129e-8\n  1.1690835542780058e-7\n  1.169188782320695e-6\n  1.1691993051249639e-5\n  3.96415424995973e-5\n  0.0001251040827040069\n  0.00037992550155953065\n  ⋮\n 18.252302769116575\n 18.556761040654674\n 19.073892463800625\n 19.428284008927427\n 20.09879123998184\n 20.480538570171507\n 20.999444301927937\n 21.403330440737882\n 22.0\nu: 79-element Array{Array{Float64,1},1}:\n [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0  …  2.5250877095783344, \n2.2620667554742258, 1.9735248771761977, 1.665005111992191, 1.34336401668221\n03, 1.0172186542655526, 0.6977464117458191, 0.4003323380813969, 0.148922584\n53196738, 0.0]\n [0.00011790503536898665, 0.00011790503536909906, 0.00011790503536928888, 0\n.00011790503536951345, 0.0001179050353697547, 0.00011790503537000097, 0.000\n11790503537024383, 0.00011790503537047684, 0.00011790503537069474, 0.000117\n90503537089335  …  2.5250585327638797, 2.262041954652914, 1.973505463224665\n6, 1.6649923614746842, 1.3433596406307873, 1.0172251412113864, 0.6977678519\n884, 0.4003770605722655, 0.14902217713448462, 0.000144701505282153]\n [0.0012949971428852717, 0.0012949971428992155, 0.001294997142922781, 0.001\n2949971429507092, 0.0012949971429807212, 0.0012949971430113658, 0.001294997\n1430415896, 0.0012949971430705825, 0.001294997143097699, 0.0012949971431224\n178  …  2.52476680944311, 2.2617940004952306, 1.973311391982252, 1.66486494\n7832933, 1.343316013313132, 1.0172902298879962, 0.6979827036906551, 0.40082\n59597669359, 0.15001758272059923, 0.0015893132679671673]\n [0.012876383252354838, 0.012876383254089876, 0.012876383257051385, 0.01287\n6383260614965, 0.012876383264461243, 0.012876383268395485, 0.01287638327227\n9336, 0.012876383276007026, 0.01287638327949474, 0.012876383282674856  …  2\n.5218540714350746, 2.2593198858887353, 1.971377545998155, 1.663600045556335\n, 1.3428932614037994, 1.0179637350768072, 0.7001796234851249, 0.40546907561\n279366, 0.159920626066569, 0.015802820975871525]\n [0.11431809668801969, 0.11431809701540827, 0.11431809761055266, 0.11431809\n838668756, 0.11431809926467854, 0.1143181001852524, 0.11431810110619822, 0.\n1143181019968641, 0.1143181028341037, 0.11431810359985839  …  2.49319122864\n72744, 2.2351481567086453, 1.9527784378871984, 1.6519892724152478, 1.340282\n573226162, 1.0275217594291501, 0.7274071832384641, 0.4600255371073474, 0.25\n403236055497325, 0.14029945313886596]\n [0.6824546276302552, 0.6824546576303283, 0.6824547160548516, 0.68245479982\n66596, 0.6824549045779489, 0.6824550250157978, 0.6824551553829176, 0.682455\n2898965248, 0.6824554230873283, 0.6824555500182544  …  2.2673901444639477, \n2.0670335967015725, 1.856281803467327, 1.6433610322349588, 1.43773260755362\n28, 1.249622628038894, 1.089014709165961, 0.964086299638045, 0.879715279699\n5076, 0.8375618491417234]\n [1.6813894581935167, 1.6813894979141795, 1.6813895760496735, 1.68138969005\n22025, 1.6813898362183566, 1.6813900097580707, 1.681390204842709, 1.6813904\n14668493, 1.6813906315812168, 1.681390847292351  …  1.8814741145279639, 1.9\n062408314582533, 1.932556304652824, 1.9593615779722884, 1.9854302030584638,\n 2.009456254944375, 2.030184671316311, 2.0465572620802512, 2.05782082872771\n7, 2.0635421902068396]\n [1.5465563234604633, 1.5465563151032578, 1.546556298667805, 1.546556274705\n925, 1.5465562440308058, 1.5465562077004953, 1.5465561669954782, 1.54655612\n33881666, 1.5465560785018047, 1.546556034057256  …  1.9340770272586247, 1.9\n289445685108866, 1.9236144878920916, 1.918294922809417, 1.9132050182112592,\n 1.90856340239867, 1.9045749934046978, 1.9014179583244304, 1.89923295644000\n23, 1.8981161877601427]\n [1.5715361948410418, 1.5715361953311315, 1.57153619629489, 1.5715361976997\n826, 1.5715361994977792, 1.571536201626338, 1.571536204009821, 1.5715362065\n614462, 1.5715362091858556, 1.5715362117823382  …  1.9247785400997206, 1.92\n53926733129951, 1.926022344707277, 1.926643291184795, 1.9272311943883393, 1\n.9277626997857489, 1.9282164458524176, 1.9285740360607109, 1.92882088655398\n73, 1.9289468947014914]\n [1.5684925853534752, 1.5684925853540483, 1.5684925853552447, 1.56849258535\n7125, 1.5684925853597242, 1.5684925853630174, 1.5684925853669094, 1.5684925\n853712433, 1.5684925853758194, 1.5684925853804146  …  1.9259264057842067, 1\n.9258966605641663, 1.9258662870639163, 1.9258364529304535, 1.92580831012103\n66, 1.925782949722734, 1.9257613584940534, 1.9257443790768893, 1.9257326756\n936477, 1.925726706942093]\n ⋮\n [3.519620884001627, 3.5196209320997647, 3.5196209820910895, 3.519621032110\n1122, 3.5196210801507464, 3.5196211241431548, 3.5196211620586335, 3.5196211\n92036574, 3.5196212125280093, 3.5196212224289765  …  0.9122143221397975, 0.\n9122143221401331, 0.9122143221409135, 0.912214322140921, 0.9122143221408562\n, 0.9122143221405419, 0.9122143221403283, 0.9122143221397983, 0.91221432213\n941, 0.9122143221386628]\n [2.6927687450844022, 2.692768793182424, 2.692768843173625, 2.6927688931925\n88, 2.6927689412331732, 2.6927689852255514, 2.692769023140844, 2.6927690531\n18851, 2.692769073610191, 2.692769083511124  …  1.1449286955907596, 1.14492\n86955911178, 1.1449286955915916, 1.1449286955916638, 1.1449286955916267, 1.\n1449286955914064, 1.1449286955911533, 1.144928695590697, 1.1449286955902385\n, 1.1449286955895766]\n [1.6638910873620831, 1.663891135459961, 1.663891185450922, 1.6638912354696\n964, 1.6638912835102115, 1.6638913275024467, 1.6638913654175496, 1.66389139\n53954915, 1.6638914158866707, 1.6638914257875743  …  1.6489243165014276, 1.\n6489243165018714, 1.6489243165020488, 1.648924316502046, 1.6489243165021266\n, 1.6489243165019023, 1.6489243165019143, 1.6489243165013963, 1.64892431650\n0767, 1.6489243165002527]\n [1.1678842944971668, 1.1678843425948444, 1.1678843925856235, 1.16788444260\n42179, 1.1678844906445345, 1.1678845346366145, 1.1678845725515745, 1.167884\n602529421, 1.1678846230205415, 1.1678846329214068  …  2.0516734038388442, 2\n.0516734038391453, 2.0516734038392626, 2.0516734038392577, 2.05167340383931\n45, 2.0516734038391613, 2.0516734038391777, 2.0516734038388256, 2.051673403\n8383984, 2.0516734038380546]\n [0.6069466972096277, 0.6069467453083509, 0.6069467952970033, 0.60694684531\n44846, 0.6069468933526092, 0.6069469373461568, 0.6069469752616932, 0.606947\n00523755, 0.606947025727838, 0.6069470356287272  …  2.7995778606854413, 2.7\n995778606865453, 2.799577860686138, 2.799577860686269, 2.799577860686521, 2\n.7995778606861785, 2.7995778606871626, 2.799577860686091, 2.799577860687871\n, 2.799577860687257]\n [0.47215555277672316, 0.4721556008742116, 0.47215565086411865, 0.472155700\n88207404, 0.4721557489214685, 0.4721557929135511, 0.4721558308283381, 0.472\n15586080552696, 0.4721558812963327, 0.47215589119712137  …  3.1676671971764\n154, 3.16766719717659, 3.167667197176464, 3.1676671971764727, 3.16766719717\n6529, 3.1676671971764807, 3.167667197176733, 3.1676671971765695, 3.16766719\n71770274, 3.1676671971769923]\n [0.4055628704418776, 0.4055629185389692, 0.405562968529316, 0.405563018547\n4488, 0.40556306658728697, 0.4055631105788928, 0.4055631484934412, 0.405563\n1784710878, 0.4055631989620743, 0.40556320886283254  …  3.603368151456505, \n3.603368151456402, 3.6033681514563685, 3.6033681514563423, 3.60336815145633\n8, 3.6033681514563765, 3.6033681514563987, 3.603368151456506, 3.60336815145\n6546, 3.6033681514566753]\n [0.3995929112700888, 0.3995929593673295, 0.39959300935761466, 0.3995930593\n7575146, 0.39959310741552356, 0.39959315140729207, 0.39959318932193655, 0.3\n995932192994949, 0.3995932397904544, 0.39959324969122934  …  3.910174923881\n8027, 3.9101749238817978, 3.9101749238817582, 3.91017492388175, 3.910174923\n881759, 3.910174923881765, 3.9101749238818266, 3.910174923881835, 3.9101749\n238819465, 3.910174923881991]\n [0.42180482514855694, 0.42180487324580856, 0.421804923236389, 0.4218049732\n5473093, 0.42180502129478975, 0.4218050652865224, 0.42180510320119247, 0.42\n18051331789871, 0.4218051536700632, 0.4218051635708545  …  4.32769488090108\n9, 4.327694880901067, 4.327694880901113, 4.3276948809011175, 4.327694880901\n103, 4.327694880901107, 4.327694880901029, 4.327694880901046, 4.32769488090\n09035, 4.327694880900876]","category":"page"},{"location":"exercises/02-workshop_solutions/","page":"SciML Workshop Exercise Solutions","title":"SciML Workshop Exercise Solutions","text":"Visualizing the solution (works best in a terminal):","category":"page"},{"location":"exercises/02-workshop_solutions/","page":"SciML Workshop Exercise Solutions","title":"SciML Workshop Exercise Solutions","text":"\n@gif for t in sol1.t[1]:0.1:sol1.t[end]\n    off = N^2\n    solt = sol1(t)\n    plt1 = surface(reshape(solt[1:off], N, N), zlims=(0, 5), leg=false)\n    surface!(plt1, reshape(solt[off+1:end], N, N), zlims=(0, 5), leg=false)\n    display(plt1)\nend","category":"page"},{"location":"exercises/02-workshop_solutions/#Part-2:-Optimizing-the-BRUSS-Code","page":"SciML Workshop Exercise Solutions","title":"Part 2: Optimizing the BRUSS Code","text":"","category":"section"},{"location":"exercises/02-workshop_solutions/","page":"SciML Workshop Exercise Solutions","title":"SciML Workshop Exercise Solutions","text":"function brusselator_2d_loop(du, u, p, t)\n    A, B, α, xyd = p\n    dx = step(xyd)\n    N = length(xyd)\n    α = α/dx^2\n    limit = a -> let N=N\n        a == N+1 ? 1 :\n        a == 0 ? N :\n        a\n    end\n    II = LinearIndices((N, N, 2))\n\n    @inbounds begin\n        for I in CartesianIndices((N, N))\n            x = xyd[I[1]]\n            y = xyd[I[2]]\n            i = I[1]\n            j = I[2]\n            ip1 = limit(i+1)\n            im1 = limit(i-1)\n            jp1 = limit(j+1)\n            jm1 = limit(j-1)\n\n            ii1 = II[i,j,1]\n            ii2 = II[i,j,2]\n\n            du[II[i,j,1]] = α*(u[II[im1,j,1]] + u[II[ip1,j,1]] + u[II[i,jp1,1]] + u[II[i,jm1,1]] - 4u[ii1]) +\n            B + u[ii1]^2*u[ii2] - (A + 1)*u[ii1] + brusselator_f(x, y, t)\n\n            du[II[i,j,2]] = α*(u[II[im1,j,2]] + u[II[ip1,j,2]] + u[II[i,jp1,2]] + u[II[i,jm1,2]] - 4u[II[i,j,2]]) +\n            A*u[ii1] - u[ii1]^2*u[ii2]\n        end\n    end\n    nothing\nend\n\nprob2 = ODEProblem(brusselator_2d_loop, u0, tspan, p)\n\nsol2 = @time solve(prob2, TRBDF2())","category":"page"},{"location":"exercises/02-workshop_solutions/","page":"SciML Workshop Exercise Solutions","title":"SciML Workshop Exercise Solutions","text":"8.669444 seconds (9.99 M allocations: 678.160 MiB, 0.52% gc time)","category":"page"},{"location":"exercises/02-workshop_solutions/","page":"SciML Workshop Exercise Solutions","title":"SciML Workshop Exercise Solutions","text":"sol2_2 = @time solve(prob2, CVODE_BDF())","category":"page"},{"location":"exercises/02-workshop_solutions/","page":"SciML Workshop Exercise Solutions","title":"SciML Workshop Exercise Solutions","text":"35.178275 seconds (1.79 M allocations: 118.117 MiB)\nretcode: Success\nInterpolation: 3rd order Hermite\nt: 259-element Array{Float64,1}:\n  0.0\n  5.653338356947935e-11\n  5.65390369078363e-7\n  2.572950290187468e-6\n  4.580510211296573e-6\n  7.750405709122968e-6\n  1.4302881311757801e-5\n  4.0134710329210774e-5\n  6.596653934666375e-5\n  9.179836836411672e-5\n  ⋮\n 20.115148615356873\n 20.37146777739318\n 20.627786939429484\n 20.88410610146579\n 21.140425263502095\n 21.3967444255384\n 21.653063587574707\n 21.909382749611012\n 22.0\nu: 259-element Array{Array{Float64,1},1}:\n [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0  …  2.5250877095783344, \n2.2620667554742258, 1.9735248771761977, 1.665005111992191, 1.34336401668221\n03, 1.0172186542655526, 0.6977464117458191, 0.4003323380813969, 0.148922584\n53196738, 0.0]\n [6.598117452446044e-8, 6.598117452452795e-8, 6.59811745246415e-8, 6.598117\n452477602e-8, 6.59811745249205e-8, 6.598117452506815e-8, 6.598117452521404e\n-8, 6.598117452535298e-8, 6.598117452548406e-8, 6.598117452560301e-8  …  2.\n52508769326683, 2.26206674160907, 1.9735248663224956, 1.6650051048635588, 1\n.3433640142351067, 1.0172186578909652, 0.6977464237297119, 0.40033236307490\n11, 0.1489226402117897, 8.090751419307918e-8]\n [0.0006587624140132232, 0.0006587624209141625, 0.0006587624326779875, 0.00\n06587624465990196, 0.000658762461542147, 0.000658762476747418, 0.0006587624\n918359335, 0.000658762506258849, 0.0006587625198234356, 0.00065876253213972\n14  …  2.524924606099231, 2.261928123190901, 1.9734163705350949, 1.66493387\n301444, 1.343339621372235, 1.0172550391384978, 0.697866520902045, 0.4005832\n5044085197, 0.14947914535482773, 0.0008077938023952315]\n [0.0029885797701746284, 0.002988579862875722, 0.002988580024412284, 0.0029\n885802153883506, 0.0029885804198764242, 0.002988580626391515, 0.00298858083\n42275124, 0.0029885810313851017, 0.0029885812191603584, 0.00298858138811432\n6  …  2.5243457007698074, 2.261436153310274, 1.9730314375969087, 1.66468138\n01159555, 1.3432536595673659, 1.0173853107174544, 0.6982952263862713, 0.401\n48198029752397, 0.1514529070863203, 0.003664729223250155]\n [0.005306141508030984, 0.005306142690205768, 0.005306142257972833, 0.00530\n6142797468204, 0.005306143401977575, 0.00530614493691719, 0.005306148087986\n683, 0.0053061452495214295, 0.005306149230355061, 0.005306149723653397  …  \n2.5237671078891086, 2.2609445550730123, 1.972646967738447, 1.66442950038285\n24, 1.3431685811161493, 1.0175170325180882, 0.698726972801953, 0.4023908498\n594301, 0.15342343126294944, 0.0065066953025461555]\n [0.008938531142281401, 0.00893853412998814, 0.008938533324753955, 0.008938\n534851373863, 0.008938536624027108, 0.008938540672423655, 0.008938548169476\n477, 0.00893854209409423, 0.008938551523646868, 0.008938552952542707  …  2.\n5228542226523203, 2.2601691664198333, 1.9720409392385245, 1.664033168895644\n7, 1.3430362416837864, 1.0177283298803772, 0.6994157785454703, 0.4038476392\n5678996, 0.15652765095572066, 0.010961135026978663]\n [0.016344145375892745, 0.016344150679504905, 0.016344153382255998, 0.01634\n4159160398462, 0.01634416578191356, 0.016344175003834897, 0.016344186710899\n49, 0.016344185944460035, 0.01634419915335025, 0.01634420450260158  …  2.52\n09699686322784, 2.2585696653032357, 1.9707923492854083, 1.6632194124484905,\n 1.3427706997876703, 1.0181786440181924, 0.7008691316897557, 0.406937430466\n94203, 0.16291636532495113, 0.020043247383951576]\n [0.04433812091521405, 0.04433815867165508, 0.04433820623536491, 0.04433827\n157330291, 0.044338347135081634, 0.044338431939997466, 0.044338515477739565\n, 0.04433857623295058, 0.044338655086562505, 0.04433871696545116  …  2.5135\n78240692516, 2.252307885072983, 1.9659255801385158, 1.66008673108698, 1.341\n8375910046947, 1.0201544536483305, 0.7070145269795118, 0.4198921130658216, \n0.18773948635125548, 0.054381120820077296]\n [0.07058737985116977, 0.07058664484029947, 0.0705875413280103, 0.070587855\n81917236, 0.0705879729541195, 0.070587289183245, 0.07058596349206522, 0.070\n58829612748044, 0.07058625771406031, 0.0705864535189533  …  2.5062449271565\n765, 2.2461167960972164, 1.961149034074087, 1.6570783972413137, 1.341096371\n9495257, 1.0224707341431893, 0.7138163912529947, 0.4338374639900661, 0.2119\n8260672435237, 0.08658995681881776]\n [0.09534502498283606, 0.09534358538038319, 0.09534532706763858, 0.09534608\n102785042, 0.09534625281411645, 0.09534489421692781, 0.09534277774807996, 0\n.0953468096914476, 0.09534337195439287, 0.09534381035303054  …  2.498970563\n5047277, 2.2399977238708053, 1.9564660515271148, 1.6542026515183286, 1.3405\n654586114462, 1.0251552440356688, 0.7212413308882024, 0.44843068771835926, \n0.23564736424496766, 0.1169787925933724]\n ⋮\n [0.6323810451914815, 0.632427052649651, 0.6324748742136165, 0.632522725663\n7151, 0.632568687588502, 0.6326107791949938, 0.6326470583214443, 0.63267574\n42982498, 0.6326953532738601, 0.632704828378052  …  2.770008193556327, 2.77\n0008208734769, 2.7700082189120816, 2.7700082237279133, 2.7700082230441634, \n2.7700082168913203, 2.7700082054620894, 2.770008189124797, 2.77000816842502\n84, 2.7700081440708226]\n [0.5226275087207661, 0.5226734342910327, 0.5227211719697351, 0.52276894073\n76451, 0.5228148244346382, 0.5228568454418254, 0.5228930645349704, 0.522921\n7036079294, 0.5229412808642269, 0.5229507408309406  …  3.0270587055167733, \n3.0270586753006343, 3.0270586550848355, 3.027058645472268, 3.02705864680864\n9, 3.027058659063031, 3.0270586818168277, 3.0270587143052663, 3.02705875544\n77606, 3.0270588038594153]\n [0.4579604087410305, 0.458006296802263, 0.4580539960946591, 0.458101726935\n9897, 0.45814757462705746, 0.458189563162972, 0.45822575460980086, 0.458254\n3720215345, 0.4582739347433197, 0.458283387662069  …  3.2613243481002447, 3\n.2613242970972784, 3.261324263504071, 3.2613242471006543, 3.261324249141863\n7, 3.261324269879769, 3.261324308306207, 3.2613243629016937, 3.261324432013\n5792, 3.2613245136746594]\n [0.4243249949117141, 0.4243708716334364, 0.4244185592849013, 0.42446627872\n460485, 0.42451211572444175, 0.42455409459691923, 0.42459027785523756, 0.42\n46188889172981, 0.42463844725967403, 0.42464789817336857  …  3.476979389713\n562, 3.4769793324322897, 3.476979294466571, 3.476979276125042, 3.4769792785\n14862, 3.476979301782493, 3.4769793449316233, 3.476979406359194, 3.47697948\n4132899, 3.4769795758778326]\n [0.4100847046913288, 0.4101305921364255, 0.4101782907401593, 0.41022602107\n792533, 0.41027186852471176, 0.4103138568061762, 0.41035004810598086, 0.410\n37866551793173, 0.4103982280350711, 0.4104076810589709  …  3.67907975182885\n67, 3.6790797004957008, 3.679079666185172, 3.679079649844482, 3.67907965210\n2726, 3.679079672926244, 3.679079711585095, 3.6790797667656774, 3.679079836\n642917, 3.679079918887027]\n [0.4073307682105559, 0.4073766856477378, 0.4074244149682815, 0.40747217562\n354593, 0.4075180518070638, 0.40756006601996625, 0.40759627938780474, 0.407\n62491406752893, 0.4076444882216691, 0.407653946842301  …  3.87153703747294,\n 3.8715370027640295, 3.8715369794090573, 3.871536968411483, 3.8715369700022\n073, 3.8715369840696034, 3.8715370102065285, 3.871537047588856, 3.871537094\n929266, 3.871537150541017]\n [0.4116592888096325, 0.41170525037260386, 0.4117530249037378, 0.4118008301\n185253, 0.41184674845518116, 0.41188880071685885, 0.4119250464392734, 0.411\n9537063944312, 0.41197329765271995, 0.4119827644270476  …  4.05641774845540\n05, 4.05641773820175, 4.056417731164946, 4.056417727958729, 4.0564177284843\n43, 4.056417732631651, 4.056417740353393, 4.056417751458394, 4.056417765516\n157, 4.056417781927513]\n [0.421178883717942, 0.42122490081186037, 0.42127273224506245, 0.4213205935\n2132606, 0.42136656486420737, 0.42140866497435914, 0.421444951375888, 0.421\n4736430958104, 0.42149325587312986, 0.4215027328817772  …  4.23412681426794\n4, 4.234126834790803, 4.234126848384466, 4.234126854951361, 4.2341268540976\n16, 4.234126845769279, 4.234126830318249, 4.234126808309182, 4.234126780420\n57, 4.234126747488131]\n [0.4255569709603833, 0.42560301293838904, 0.42565086989133055, 0.425698756\n25778114, 0.4257447512526154, 0.4257868727264482, 0.42582317727042507, 0.42\n585188312176897, 0.42587150553824715, 0.42588098706735406  …  4.29522520924\n0007, 4.295225243549162, 4.295225266516079, 4.295225277416021, 4.2952252758\n90809, 4.295225261987599, 4.295225236161456, 4.2952251992579855, 4.29522515\n2494508, 4.295225097441233]","category":"page"},{"location":"exercises/02-workshop_solutions/#Part-3:-Exploiting-Jacobian-Sparsity-with-Color-Differentiation","page":"SciML Workshop Exercise Solutions","title":"Part 3: Exploiting Jacobian Sparsity with Color Differentiation","text":"","category":"section"},{"location":"exercises/02-workshop_solutions/","page":"SciML Workshop Exercise Solutions","title":"SciML Workshop Exercise Solutions","text":"using SparseDiffTools, SparsityDetection\n\nsparsity_pattern = jacobian_sparsity(brusselator_2d_loop,similar(u0),u0,p,2.0)","category":"page"},{"location":"exercises/02-workshop_solutions/","page":"SciML Workshop Exercise Solutions","title":"SciML Workshop Exercise Solutions","text":"Explored path: SparsityDetection.Path(Bool[], 1)","category":"page"},{"location":"exercises/02-workshop_solutions/","page":"SciML Workshop Exercise Solutions","title":"SciML Workshop Exercise Solutions","text":"jac_sp = sparse(sparsity_pattern)\njac = Float64.(jac_sp)\ncolors = matrix_colors(jac)\nprob3 = ODEProblem(ODEFunction(brusselator_2d_loop, colorvec=colors,jac_prototype=jac_sp), u0, tspan, p)\nsol3 = @time solve(prob3, TRBDF2())","category":"page"},{"location":"exercises/02-workshop_solutions/","page":"SciML Workshop Exercise Solutions","title":"SciML Workshop Exercise Solutions","text":"Error: InexactError: Bool(-38444.40000000001)","category":"page"},{"location":"exercises/02-workshop_solutions/#(Optional)-Part-4:-Structured-Jacobians","page":"SciML Workshop Exercise Solutions","title":"(Optional) Part 4: Structured Jacobians","text":"","category":"section"},{"location":"exercises/02-workshop_solutions/#(Optional)-Part-5:-Automatic-Symbolicification-and-Analytical-Jacobian","page":"SciML Workshop Exercise Solutions","title":"(Optional) Part 5: Automatic Symbolicification and Analytical Jacobian","text":"","category":"section"},{"location":"exercises/02-workshop_solutions/#Part-6:-Utilizing-Preconditioned-GMRES-Linear-Solvers","page":"SciML Workshop Exercise Solutions","title":"Part 6: Utilizing Preconditioned-GMRES Linear Solvers","text":"","category":"section"},{"location":"exercises/02-workshop_solutions/","page":"SciML Workshop Exercise Solutions","title":"SciML Workshop Exercise Solutions","text":"using DiffEqOperators\nusing Sundials\nusing AlgebraicMultigrid: ruge_stuben, aspreconditioner, smoothed_aggregation\nprob6 = ODEProblem(ODEFunction(brusselator_2d_loop, jac_prototype=JacVecOperator{Float64}(brusselator_2d_loop, u0)), u0, tspan, p)\nII = Matrix{Float64}(I, N, N)\nOp = kron(Matrix{Float64}(I, 2, 2), kron(D2, II) + kron(II, D2))\nWapprox = -I+Op\n#ml = ruge_stuben(Wapprox)\nml = smoothed_aggregation(Wapprox)\nprecond = aspreconditioner(ml)\nsol_trbdf2 = @time solve(prob6, TRBDF2(linsolve=LinSolveGMRES())); # no preconditioner","category":"page"},{"location":"exercises/02-workshop_solutions/","page":"SciML Workshop Exercise Solutions","title":"SciML Workshop Exercise Solutions","text":"11.528428 seconds (12.99 M allocations: 4.895 GiB, 2.71% gc time)","category":"page"},{"location":"exercises/02-workshop_solutions/","page":"SciML Workshop Exercise Solutions","title":"SciML Workshop Exercise Solutions","text":"sol_trbdf2 = @time solve(prob6, TRBDF2(linsolve=LinSolveGMRES(Pl=lu(Wapprox)))); # sparse LU","category":"page"},{"location":"exercises/02-workshop_solutions/","page":"SciML Workshop Exercise Solutions","title":"SciML Workshop Exercise Solutions","text":"3.489017 seconds (6.15 M allocations: 716.016 MiB, 1.73% gc time)","category":"page"},{"location":"exercises/02-workshop_solutions/","page":"SciML Workshop Exercise Solutions","title":"SciML Workshop Exercise Solutions","text":"sol_trbdf2 = @time solve(prob6, TRBDF2(linsolve=LinSolveGMRES(Pl=precond))); # AMG","category":"page"},{"location":"exercises/02-workshop_solutions/","page":"SciML Workshop Exercise Solutions","title":"SciML Workshop Exercise Solutions","text":"3.107065 seconds (6.18 M allocations: 536.155 MiB, 2.83% gc time)","category":"page"},{"location":"exercises/02-workshop_solutions/","page":"SciML Workshop Exercise Solutions","title":"SciML Workshop Exercise Solutions","text":"sol_cvodebdf = @time solve(prob2, CVODE_BDF(linear_solver=:GMRES));","category":"page"},{"location":"exercises/02-workshop_solutions/","page":"SciML Workshop Exercise Solutions","title":"SciML Workshop Exercise Solutions","text":"1.651483 seconds (1.90 M allocations: 204.526 MiB)\nretcode: Success\nInterpolation: 3rd order Hermite\nt: 1928-element Array{Float64,1}:\n  0.0\n  5.653338356947935e-11\n  5.65390369078363e-7\n  2.57289768832925e-6\n  4.5804050075801365e-6\n  7.750237020809387e-6\n  1.430297275427241e-5\n  3.947737124517274e-5\n  6.465176973607307e-5\n  8.982616822697341e-5\n  ⋮\n 21.74842347830861\n 21.75377749261479\n 21.770859233529922\n 21.787940974445053\n 21.800484442937336\n 21.813027911429618\n 21.844693963335253\n 21.950342098966686\n 22.0\nu: 1928-element Array{Array{Float64,1},1}:\n [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0  …  2.5250877095783344, \n2.2620667554742258, 1.9735248771761977, 1.665005111992191, 1.34336401668221\n03, 1.0172186542655526, 0.6977464117458191, 0.4003323380813969, 0.148922584\n53196738, 0.0]\n [6.598117452445592e-8, 6.598117452452327e-8, 6.598117452463697e-8, 6.59811\n7452477148e-8, 6.598117452491596e-8, 6.598117452506346e-8, 6.59811745252089\n2e-8, 6.598117452534844e-8, 6.598117452547893e-8, 6.598117452559789e-8  …  \n2.52508769326683, 2.26206674160907, 1.9735248663224956, 1.6650051048635588,\n 1.3433640142351067, 1.0172186578909652, 0.6977464237297119, 0.400332363074\n9011, 0.1489226402117897, 8.090751419307378e-8]\n [0.0006587624172964451, 0.0006587624240399749, 0.0006587624354243716, 0.00\n06587624488920072, 0.0006587624633585051, 0.0006587624781271849, 0.00065876\n24926919035, 0.000658762506662457, 0.0006587625197283628, 0.000658762531638\n6175  …  2.5249246059817017, 2.2619281230446204, 1.973416370341658, 1.66493\n38727357148, 1.3433396209127182, 1.0172550381632066, 0.69786651676992, 0.40\n05832569059138, 0.14947914564976048, 0.0008077937954087897]\n [0.0029885190994651673, 0.0029885191897600113, 0.0029885193423737177, 0.00\n29885195232632685, 0.002988519717653178, 0.002988519916140473, 0.0029885201\n11906188, 0.002988520299697163, 0.0029885204753350315, 0.002988520635442596\n3  …  2.524345713343465, 2.261436162970071, 1.973031443407278, 1.6646813805\n594152, 1.343253651586457, 1.017385285060445, 0.698295128369312, 0.40148209\n36914462, 0.15145286366257169, 0.0036646545802277134]\n [0.005306022356073513, 0.005306022621712586, 0.0053060230717453995, 0.0053\n06023607201543, 0.005306024183137538, 0.005306024771435465, 0.0053060253517\n8454, 0.005306025908561257, 0.005306026429347995, 0.005306026904112427  …  \n2.5237671339498102, 2.260944575638989, 1.9726469809636227, 1.66442950338789\n62, 1.343168568455559, 1.0175169867522391, 0.6987268229191962, 0.4023910083\n0343055, 0.15342334401815053, 0.0065065496316772335]\n [0.00893834350995413, 0.00893834427987621, 0.00893834558850756, 0.00893834\n7153465821, 0.008938348839052852, 0.008938350561768801, 0.00893835226170432\n, 0.008938353892881468, 0.008938355418797277, 0.008938356809979058  …  2.52\n28542649298107, 2.2601692000771423, 1.9720409612790466, 1.66403317465477, 1\n.3430362221641639, 1.017728256881341, 0.6994155885173241, 0.403847823621840\n9, 0.15652751916175822, 0.01096090625912015]\n [0.01634429202116057, 0.01634429489952914, 0.016344299822335723, 0.0163443\n0576423857, 0.016344312182172048, 0.016344318748721217, 0.01634432523215556\n5, 0.01634433145550153, 0.01634433727856935, 0.016344342588309163  …  2.520\n9699337854867, 2.258569632374003, 1.970792317068139, 1.6632193768804995, 1.\n3427706450978134, 1.0181785268879573, 0.7008693575988351, 0.406937285311047\n1, 0.16291664462188093, 0.0200434281564615]\n [0.043646263363862924, 0.043646292669642976, 0.04364634410002619, 0.043646\n408299418085, 0.043646478690166544, 0.0436465511401205, 0.04364662287963492\n, 0.04364669185715508, 0.043646756468291935, 0.04364681542761546  …  2.5137\n65529699384, 2.2524662162038327, 1.96604803719552, 1.6601642835144645, 1.34\n18578790218518, 1.0201021423806298, 0.7068529962881926, 0.41955020644048985\n, 0.1871136496191611, 0.05353236358962729]\n [0.0692823968869293, 0.06928248583818256, 0.06928264396753456, 0.069282844\n55502629, 0.06928306665139533, 0.06928329638678168, 0.06928352441574115, 0.\n06928374395054913, 0.06928394975415433, 0.06928413765698549  …  2.506616550\n182622, 2.2464297079132223, 1.9613890075261213, 1.6572267432709649, 1.34112\n728871286, 1.0223507377796497, 0.7134630924575552, 0.43311194946272524, 0.2\n1076011686633297, 0.08498786962833081]\n [0.09349042837387436, 0.09349061562324566, 0.09349095207267255, 0.09349138\n44519549, 0.09349186761490513, 0.0934923699926786, 0.09349286998656095, 0.0\n9349335206219281, 0.09349380438256111, 0.09349421759820462  …  2.4995234731\n16373, 2.240461415578458, 1.956818523753225, 1.65441487227758, 1.3405970544\n326884, 1.0249482572805424, 0.720666723995856, 0.447302887948819, 0.2338561\n2858767357, 0.11470081104803237]\n ⋮\n [0.3797955575005551, 0.3798129120680182, 0.37983160912795294, 0.3798515167\n9769735, 0.3798700744173499, 0.3798877958739413, 0.37990413586835, 0.379917\n73881418767, 0.3799267950426437, 0.3799309569353526  …  3.4574052823485664,\n 3.4573936286619094, 3.457386402854468, 3.4573827565631308, 3.4573831040940\n81, 3.4573876418782974, 3.457395923872096, 3.4574086494131495, 3.4574240121\n578605, 3.4574420811420903]\n [0.37958401654816143, 0.3796201588394765, 0.37965786768047793, 0.379695834\n60132494, 0.3797327833587292, 0.379767041189448, 0.37979645035002474, 0.379\n81940648060253, 0.37983513643422023, 0.3798427397648622  …  3.4617077059990\n3, 3.4616995134797413, 3.4616938254044576, 3.4616910792093196, 3.4616914818\n578866, 3.4616948057305494, 3.46170100881632, 3.4617097544879343, 3.4617206\n586988303, 3.4617334162991207]\n [0.37898131515329514, 0.37904455623143324, 0.3791102395621268, 0.379171848\n92573214, 0.3792278014621423, 0.37927854226433344, 0.3793222968917526, 0.37\n935935408014265, 0.3793873038928219, 0.37940252613199893  …  3.475400682841\n286, 3.4754021781703925, 3.475405250938518, 3.4754068566952996, 3.475406283\n915746, 3.475404220521274, 3.475401075649539, 3.4754010132857456, 3.4754017\n445012275, 3.4754014416136703]\n [0.3784028728681648, 0.37847935063114085, 0.37855821248433963, 0.378635433\n8343628, 0.3787103744504435, 0.37877900390104313, 0.3788373625105384, 0.378\n88198986151156, 0.37891190751041437, 0.37892669234514176  …  3.489080362945\n1366, 3.489089294219412, 3.489094650501359, 3.489097497162135, 3.4890973438\n878747, 3.489093753047733, 3.489087808019096, 3.4890784385409153, 3.4890666\n40825046, 3.489052679244454]\n [0.37802806562457314, 0.3781081068261598, 0.37819023494543214, 0.378268702\n7300955, 0.37834355080180027, 0.37841307565234206, 0.37847181048385786, 0.3\n785172210264568, 0.37854884544138667, 0.3785659311574103  …  3.499071751303\n758, 3.4990834581052974, 3.4990920535881895, 3.499096339156102, 3.499095815\n52635, 3.4990905269259645, 3.49908103431579, 3.4990696874410214, 3.49905517\n5741332, 3.4990372237525125]\n [0.3776909382220414, 0.37776351115109563, 0.37783859475543263, 0.377912506\n00268866, 0.37798520447195416, 0.37805140767486484, 0.37810798564087067, 0.\n37815118643386414, 0.3781792196305945, 0.37819286030587723  …  3.5090277181\n657115, 3.5090394826004574, 3.5090464815977596, 3.509050187200965, 3.509049\n8417172786, 3.509045416275706, 3.5090377144093337, 3.509024825081179, 3.509\n0089285477553, 3.508989993790065]\n [0.3768537939605036, 0.376915458761548, 0.3769793531358606, 0.377042729545\n79915, 0.37710281438118, 0.3771570791988641, 0.37720388440231123, 0.3772415\n338113573, 0.37726733457251116, 0.3772798488606232  …  3.5341352486353617, \n3.5341466559569223, 3.534154680705109, 3.534158571433794, 3.534157981996896\n2, 3.5341533014526756, 3.5341445069751627, 3.534132413334222, 3.53411749417\n5883, 3.5340999041834755]\n [0.3740747443719409, 0.3741028206103584, 0.3741325900228058, 0.37416663902\n824293, 0.3742006984167679, 0.3742310255447786, 0.3742579572053362, 0.37427\n89270608717, 0.3742919258904212, 0.37429598291067795  …  3.6178769692717765\n, 3.6178851739555844, 3.617889139403817, 3.6178908996243493, 3.617890994937\n32, 3.617888791395569, 3.6178843129218543, 3.617874139997575, 3.61786105897\n74163, 3.617847139077364]\n [0.37278515952965974, 0.3728179321140629, 0.3728522412070423, 0.3728876482\n7093895, 0.37291708637372784, 0.37294295966405455, 0.37296625674297096, 0.3\n7298877738348996, 0.3730068685691214, 0.3730153360421533  …  3.657191327231\n621, 3.6571972377609487, 3.65720344716516, 3.6572059278358457, 3.6572051957\n615703, 3.6572021410971995, 3.6571953691210877, 3.657189705548747, 3.657182\n8565260756, 3.6571749711705777]","category":"page"},{"location":"exercises/02-workshop_solutions/#Part-7:-Exploring-IMEX-and-Exponential-Integrator-Techniques-(E)","page":"SciML Workshop Exercise Solutions","title":"Part 7: Exploring IMEX and Exponential Integrator Techniques (E)","text":"","category":"section"},{"location":"exercises/02-workshop_solutions/","page":"SciML Workshop Exercise Solutions","title":"SciML Workshop Exercise Solutions","text":"function laplacian2d(du, u, p, t)\n    A, B, α, xyd = p\n    dx = step(xyd)\n    N = length(xyd)\n    du = reshape(du, N, N, 2)\n    u = reshape(u, N, N, 2)\n    @inbounds begin\n        α = α/dx^2\n        limit = a -> let N=N\n            a == N+1 ? 1 :\n            a == 0 ? N :\n            a\n        end\n        for I in CartesianIndices((N, N))\n            x = xyd[I[1]]\n            y = xyd[I[2]]\n            i = I[1]\n            j = I[2]\n            ip1 = limit(i+1)\n            im1 = limit(i-1)\n            jp1 = limit(j+1)\n            jm1 = limit(j-1)\n            du[i,j,1] = α*(u[im1,j,1] + u[ip1,j,1] + u[i,jp1,1] + u[i,jm1,1] - 4u[i,j,1])\n            du[i,j,2] = α*(u[im1,j,2] + u[ip1,j,2] + u[i,jp1,2] + u[i,jm1,2] - 4u[i,j,2])\n        end\n    end\n    nothing\nend\nfunction brusselator_reaction(du, u, p, t)\n    A, B, α, xyd = p\n    dx = step(xyd)\n    N = length(xyd)\n    du = reshape(du, N, N, 2)\n    u = reshape(u, N, N, 2)\n    @inbounds begin\n        for I in CartesianIndices((N, N))\n            x = xyd[I[1]]\n            y = xyd[I[2]]\n            i = I[1]\n            j = I[2]\n            du[i,j,1] = B + u[i,j,1]^2*u[i,j,2] - (A + 1)*u[i,j,1] + brusselator_f(x, y, t)\n            du[i,j,2] = A*u[i,j,1] - u[i,j,1]^2*u[i,j,2]\n        end\n    end\n    nothing\nend\nprob7 = SplitODEProblem(laplacian2d, brusselator_reaction, u0, tspan, p)\nsol7 = @time solve(prob7, KenCarp4())","category":"page"},{"location":"exercises/02-workshop_solutions/","page":"SciML Workshop Exercise Solutions","title":"SciML Workshop Exercise Solutions","text":"6.407620 seconds (11.98 M allocations: 783.753 MiB, 1.66% gc time)","category":"page"},{"location":"exercises/02-workshop_solutions/","page":"SciML Workshop Exercise Solutions","title":"SciML Workshop Exercise Solutions","text":"M = MatrixFreeOperator((du,u,p)->laplacian2d(du, u, p, 0), (p,), size=(2*N^2, 2*N^2), opnorm=1000)\nprob7_2 = SplitODEProblem(M, brusselator_reaction, u0, tspan, p)\nsol7_2 = @time solve(prob7_2, ETDRK4(krylov=true), dt=1)","category":"page"},{"location":"exercises/02-workshop_solutions/","page":"SciML Workshop Exercise Solutions","title":"SciML Workshop Exercise Solutions","text":"2.917810 seconds (8.83 M allocations: 560.794 MiB, 4.01% gc time)","category":"page"},{"location":"exercises/02-workshop_solutions/","page":"SciML Workshop Exercise Solutions","title":"SciML Workshop Exercise Solutions","text":"prob7_3 = SplitODEProblem(DiffEqArrayOperator(Op), brusselator_reaction, u0, tspan, p)\nsol7_3 = solve(prob7_3, KenCarp4());","category":"page"},{"location":"exercises/02-workshop_solutions/","page":"SciML Workshop Exercise Solutions","title":"SciML Workshop Exercise Solutions","text":"retcode: Success\nInterpolation: 3rd order Hermite\nt: 411-element Array{Float64,1}:\n  0.0\n  2.888065882181688e-5\n  0.00031768724703998567\n  0.0027059840153272462\n  0.008731809471821457\n  0.02179419538626385\n  0.046044933347512154\n  0.08666612492700337\n  0.14668700100553306\n  0.2429330434920095\n  ⋮\n 21.642678211001897\n 21.669167858631038\n 21.69565750626018\n 21.745650901936376\n 21.842907495920542\n 21.862544058930474\n 21.883418684049154\n 21.924650607598824\n 22.0\nu: 411-element Array{Array{Float64,1},1}:\n [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0  …  2.5250877095783344, \n2.2620667554742258, 1.9735248771761977, 1.665005111992191, 1.34336401668221\n03, 1.0172186542655526, 0.6977464117458191, 0.4003323380813969, 0.148922584\n53196738, 0.0]\n [0.00338181359279749, 0.003381814525055848, 0.0033818161026810765, 0.00338\n18179763281625, 0.0033818199908016255, 0.003381822048157553, 0.003381824077\n5272284, 0.0033818260243597817, 0.00338182784528272, 0.003381829505247768  \n…  2.524255066788988, 2.261359157113013, 1.9729712293922774, 1.664641937979\n7444, 1.3432403152050174, 1.0174058169618412, 0.6983623120712237, 0.4016217\n8277595556, 0.1517635265052733, 0.004115818959992079]\n [0.03568250376202336, 0.03568266931785142, 0.035682955832227074, 0.0356833\n0729754052, 0.03568368941345571, 0.03568408140938937, 0.03568446895364048, \n0.035684841242777064, 0.035685189766591796, 0.03568550768135772  …  2.51599\n73402014577, 2.2543598849568935, 1.967523764161279, 1.6611194391842758, 1.3\n421496263916268, 1.0195052150551678, 0.704979868148862, 0.4156649097840782,\n 0.17979934864987152, 0.04350153844352491]\n [0.2388870086712341, 0.23890840746265182, 0.23894852951279852, 0.239002926\n71217413, 0.23906668747399049, 0.23913531679710034, 0.23920518662122434, 0.\n2392735177564327, 0.2393382102869443, 0.23939766131788623  …  2.45177455071\n75612, 2.2013122441306154, 1.9285687665074842, 1.6402584486989873, 1.345213\n7788742935, 1.0552180035855303, 0.7857635817095209, 0.5558670473603251, 0.3\n8607263451905216, 0.29539374940409546]\n [0.5564106150796982, 0.5566108464330898, 0.5569986710045511, 0.55755022257\n69137, 0.5582336728011149, 0.5590119152749861, 0.559846526329856, 0.5606997\n95457231, 0.561537663173318, 0.5623298108904917  …  2.3212076996976343, 2.1\n072090690298686, 1.880355997024359, 1.6487387710243555, 1.4216785859442722,\n 1.2094079500272332, 1.0225411460886549, 0.8713229853793858, 0.764708535522\n895, 0.7095402391463423]\n [0.9342714734084758, 0.9349598918146564, 0.936310382519549, 0.938262165081\n3462, 0.9407415908113002, 0.9436441970638244, 0.9468551430516244, 0.9502481\n957941415, 0.9536902430916663, 0.957050094472094  …  2.1614414096004184, 2.\n027111451991201, 1.8887980771792972, 1.751800690784729, 1.6215018392791603,\n 1.5031551617020042, 1.4016704666279294, 1.321363816947498, 1.2657330373145\n712, 1.2372638912267229]\n [1.2566772231894945, 1.2576431810047317, 1.2595383902093107, 1.26229311347\n9925, 1.2658028435853461, 1.2699372640323565, 1.274540022703064, 1.27943691\n0349005, 1.2844410563581503, 1.2893600761202952  …  2.0368655159549163, 1.9\n851294449856716, 1.9322949399059546, 1.8803923426225904, 1.8314233258837715\n, 1.7872824916440149, 1.749687377223869, 1.7201110332114784, 1.699714353288\n5108, 1.689307976958115]\n [1.4173304157928486, 1.4178104626035777, 1.4187536323652747, 1.42012345899\n5461, 1.421869253600005, 1.4239236083651097, 1.4262077943444462, 1.42863463\n98967849, 1.4311109979822425, 1.4335434070534994  …  1.984707244631404, 1.9\n744843346627017, 1.9640642411192235, 1.9538390653254547, 1.9442016835060763\n, 1.9355229382392862, 1.9281377603979366, 1.9223312732585927, 1.91833313347\n7084, 1.9162957064303392]\n [1.4079292375651262, 1.4080181845337447, 1.4081926434529766, 1.40844579737\n3808, 1.40876792341743, 1.4091467072462807, 1.4095677840064875, 1.410015143\n058539, 1.410471755723265, 1.4109202040012978  …  2.006848717030137, 2.0058\n633341206855, 2.004859241773954, 2.003874429852624, 2.0029462538824254, 2.0\n02109807224481, 2.0013971225351015, 2.000835759821026, 2.000448425718132, 2\n.0002507800301195]\n [1.3008722049712922, 1.3008801828116636, 1.3008945778368928, 1.30091484490\n6319, 1.3009396166641172, 1.3009679104321659, 1.3009992327229458, 1.3010331\n324351492, 1.3010682282392434, 1.3011028322919374  …  2.084972574467494, 2.\n0849211490150776, 2.0848702925700606, 2.0848214163333547, 2.08477743413165,\n 2.084738198481765, 2.0847036216234702, 2.084673859207271, 2.08465246394274\n, 2.0846409823084646]\n ⋮\n [0.39890859367367754, 0.3993441673525077, 0.3997975806788334, 0.4002518902\n321085, 0.4006888182480096, 0.4010893923770546, 0.40143496888258334, 0.4017\n0842611233254, 0.401895469313635, 0.40198591841037423  …  3.974042467040040\n7, 3.9740400700975256, 3.974038463649698, 3.974037701900219, 3.974037809267\n5783, 3.9740387819095946, 3.974040587360848, 3.974043164462041, 3.974046422\n7965795, 3.974050246993257]\n [0.399359295339172, 0.39974889839511, 0.40014696627279867, 0.4005384174406\n543, 0.4009068845049872, 0.40123752344283037, 0.40151687180652956, 0.401733\n60655661844, 0.401879356549643, 0.4019484860747507  …  3.9932059688091033, \n3.9932038478068232, 3.9932024382289315, 3.9932017744025847, 3.9932018738678\n297, 3.99320272691542, 3.993204321872256, 3.993206602084878, 3.993209523141\n2905, 3.9932129859626735]\n [0.3993686665009743, 0.39980665253816694, 0.4002705836448292, 0.4007431063\n3130167, 0.40120406441906215, 0.4016317190585153, 0.4020041495019104, 0.402\n30097607591025, 0.40250515220793087, 0.4026046039165201  …  4.0122858125097\n78, 4.012284245475603, 4.012283191763723, 4.01228269079853, 4.0122827626693\n17, 4.012283404160809, 4.012284589905506, 4.012286273787084, 4.012288391829\n275, 4.012290860181647]\n [0.4010117037388889, 0.4014585319070676, 0.40192471908753297, 0.4023929107\n571625, 0.40284400510226775, 0.4032581888842881, 0.4036158867371329, 0.4038\n991410242888, 0.4040929782391569, 0.40418678544141134  …  4.048074184182981\n5, 4.048072793476128, 4.048071860809855, 4.0480714180078925, 4.048071480580\n622, 4.04807204591452, 4.048073094164494, 4.0480745886306035, 4.04807647493\n2387, 4.048078682581573]\n [0.4040391360250253, 0.4044781455356283, 0.40493508964458735, 0.4053928897\n130187, 0.40583313109968033, 0.4062367046948323, 0.4065848385324651, 0.4068\n602985846021, 0.40704869896301227, 0.40713979724380694  …  4.11688589803744\n4, 4.116885469878567, 4.116885180300814, 4.116885042860157, 4.1168850632805\n38, 4.1168852404840575, 4.116885566552351, 4.116886026211559, 4.11688659676\n3158, 4.116887250002496]\n [0.4047700956071005, 0.40519815829045214, 0.4056399542593235, 0.4060787935\n4982956, 0.40649646573647547, 0.4068752731237485, 0.4071985546331393, 0.407\n45169655229097, 0.40762327673507454, 0.4077054230583039  …  4.1306436987736\n2, 4.130643465603472, 4.130643313409505, 4.130643244570406, 4.1306432586828\n51, 4.130643353557858, 4.130643529891911, 4.130643781395985, 4.130644101166\n296, 4.130644470170689]\n [0.405168629966455, 0.4055798821600529, 0.40601390501288664, 0.40645506728\n755565, 0.4068852428751017, 0.4072847292800238, 0.4076332639179229, 0.40791\n16747690355, 0.40810359543776764, 0.40819724273804125  …  4.145219717875681\n, 4.145219791546891, 4.145219834102426, 4.14521985299266, 4.145219852795447\n, 4.145219832891524, 4.145219787681931, 4.145219708636722, 4.14521958516251\n4, 4.145219403944229]\n [0.40704121426682677, 0.40748978803601077, 0.4079566870477457, 0.408424669\n7332447, 0.40887498057174415, 0.4092881700600071, 0.40964487371286185, 0.40\n9927358248609, 0.4101206777465779, 0.41021423546960456  …  4.17385578570464\n1, 4.17385633196801, 4.173856695023444, 4.173856867186141, 4.17385684409214\n35, 4.173856625935988, 4.173856217791514, 4.173855628428838, 4.173854869192\n83, 4.173853955130709]\n [0.4104280757891703, 0.4108700639501849, 0.41132984460416, 0.4117903516752\n1066, 0.41223306465343723, 0.41263893115959094, 0.41298899290397084, 0.4132\n6603039541165, 0.4134554904299645, 0.4135471107118313  …  4.225664869407304\n, 4.225666277355228, 4.225667215715375, 4.22566766028349, 4.225667599839396\n, 4.225667035917906, 4.225665982952057, 4.225664468355488, 4.22566253340619\n55, 4.225660233615377]","category":"page"},{"location":"exercises/02-workshop_solutions/#Part-8:-Work-Precision-Diagrams-for-Benchmarking-Solver-Choices","page":"SciML Workshop Exercise Solutions","title":"Part 8: Work-Precision Diagrams for Benchmarking Solver Choices","text":"","category":"section"},{"location":"exercises/02-workshop_solutions/","page":"SciML Workshop Exercise Solutions","title":"SciML Workshop Exercise Solutions","text":"using DiffEqDevTools\nabstols = 0.1 .^ (5:8)\nreltols = 0.1 .^ (1:4)\nsol = solve(prob3,CVODE_BDF(linear_solver=:GMRES),abstol=1/10^7,reltol=1/10^10)\ntest_sol = TestSolution(sol)\nprobs = [prob2, prob3, prob6]\nsetups = [Dict(:alg=>CVODE_BDF(),:prob_choice => 1),\n          Dict(:alg=>CVODE_BDF(linear_solver=:GMRES), :prob_choice => 1),\n          Dict(:alg=>TRBDF2(), :prob_choice => 1),\n          Dict(:alg=>TRBDF2(linsolve=LinSolveGMRES(Pl=precond)), :prob_choice => 3),\n          Dict(:alg=>TRBDF2(), :prob_choice => 2)\n         ]\nlabels = [\"CVODE_BDF (dense)\" \"CVODE_BDF (GMRES)\" \"TRBDF2 (dense)\" \"TRBDF2 (sparse)\" \"TRBDF2 (GMRES)\"]\nwp = WorkPrecisionSet(probs,abstols,reltols,setups;appxsol=[test_sol,test_sol,test_sol],save_everystep=false,numruns=3,\n  names=labels, print_names=true, seconds=0.5)","category":"page"},{"location":"exercises/02-workshop_solutions/","page":"SciML Workshop Exercise Solutions","title":"SciML Workshop Exercise Solutions","text":"CVODE_BDF (dense)\nCVODE_BDF (GMRES)\nTRBDF2 (dense)\nTRBDF2 (sparse)\nTRBDF2 (GMRES)\nError: InexactError: Bool(-38444.40000000001)","category":"page"},{"location":"exercises/02-workshop_solutions/","page":"SciML Workshop Exercise Solutions","title":"SciML Workshop Exercise Solutions","text":"plot(wp)","category":"page"},{"location":"exercises/02-workshop_solutions/","page":"SciML Workshop Exercise Solutions","title":"SciML Workshop Exercise Solutions","text":"Error: UndefVarError: wp not defined","category":"page"},{"location":"exercises/02-workshop_solutions/#Part-9:-GPU-Parallelism-for-PDEs-(E)","page":"SciML Workshop Exercise Solutions","title":"Part 9: GPU-Parallelism for PDEs (E)","text":"","category":"section"},{"location":"exercises/02-workshop_solutions/#Part-10:-Adjoint-Sensitivity-Analysis-for-Gradients-of-PDEs","page":"SciML Workshop Exercise Solutions","title":"Part 10: Adjoint Sensitivity Analysis for Gradients of PDEs","text":"","category":"section"},{"location":"exercises/02-workshop_solutions/#Problem-5:-Global-Parameter-Sensitivity-and-Optimality-with-GPU-and-Distributed-Ensembles-(B)","page":"SciML Workshop Exercise Solutions","title":"Problem 5: Global Parameter Sensitivity and Optimality with GPU and Distributed Ensembles (B)","text":"","category":"section"},{"location":"exercises/02-workshop_solutions/#Part-1:-Implementing-the-Henon-Heiles-System-(B)","page":"SciML Workshop Exercise Solutions","title":"Part 1: Implementing the Henon-Heiles System (B)","text":"","category":"section"},{"location":"exercises/02-workshop_solutions/","page":"SciML Workshop Exercise Solutions","title":"SciML Workshop Exercise Solutions","text":"function henon(dz,z,p,t)\n  p₁, p₂, q₁, q₂ = z[1], z[2], z[3], z[4]\n  dp₁ = -q₁*(1 + 2q₂)\n  dp₂ = -q₂-(q₁^2 - q₂^2)\n  dq₁ = p₁\n  dq₂ = p₂\n\n  dz .= [dp₁, dp₂, dq₁, dq₂]\n  return nothing\nend\n\nu₀ = [0.1, 0.0, 0.0, 0.5]\nprob = ODEProblem(henon, u₀, (0., 1000.))\nsol = solve(prob, Vern9(), abstol=1e-14, reltol=1e-14)\n\nplot(sol, vars=[(3,4,1)], tspan=(0,100))","category":"page"},{"location":"exercises/02-workshop_solutions/","page":"SciML Workshop Exercise Solutions","title":"SciML Workshop Exercise Solutions","text":"(Image: )","category":"page"},{"location":"exercises/02-workshop_solutions/#(Optional)-Part-2:-Alternative-Dynamical-Implmentations-of-Henon-Heiles-(B)","page":"SciML Workshop Exercise Solutions","title":"(Optional) Part 2: Alternative Dynamical Implmentations of Henon-Heiles (B)","text":"","category":"section"},{"location":"exercises/02-workshop_solutions/","page":"SciML Workshop Exercise Solutions","title":"SciML Workshop Exercise Solutions","text":"function henon(ddz,dz,z,p,t)\n  p₁, p₂ = dz[1], dz[2]\n  q₁, q₂ = z[1], z[2]\n  ddq₁ = -q₁*(1 + 2q₂)\n  ddq₂ = -q₂-(q₁^2 - q₂^2)\n\n  ddz .= [ddq₁, ddq₂]\nend\n\np₀ = u₀[1:2]\nq₀ = u₀[3:4]\nprob2 = SecondOrderODEProblem(henon, p₀, q₀, (0., 1000.))\nsol = solve(prob2, DPRKN6(), abstol=1e-10, reltol=1e-10)\n\nplot(sol, vars=[(3,4)], tspan=(0,100))\n\nH(p, q, params) = 1/2 * (p[1]^2 + p[2]^2) + 1/2 * (q[1]^2 + q[2]^2 + 2q[1]^2 * q[2] - 2/3*q[2]^3)\n\nprob3 = HamiltonianProblem(H, p₀, q₀, (0., 1000.))\nsol = solve(prob3, DPRKN6(), abstol=1e-10, reltol=1e-10)\n\nplot(sol, vars=[(3,4)], tspan=(0,100))","category":"page"},{"location":"exercises/02-workshop_solutions/","page":"SciML Workshop Exercise Solutions","title":"SciML Workshop Exercise Solutions","text":"(Image: )","category":"page"},{"location":"exercises/02-workshop_solutions/#Part-3:-Parallelized-Ensemble-Solving","page":"SciML Workshop Exercise Solutions","title":"Part 3: Parallelized Ensemble Solving","text":"","category":"section"},{"location":"exercises/02-workshop_solutions/","page":"SciML Workshop Exercise Solutions","title":"SciML Workshop Exercise Solutions","text":"In order to solve with an ensamble we need some initial conditions.","category":"page"},{"location":"exercises/02-workshop_solutions/","page":"SciML Workshop Exercise Solutions","title":"SciML Workshop Exercise Solutions","text":"function generate_ics(E,n)\n  # The hardcoded values bellow can be estimated by looking at the\n  # figures in the Henon-Heiles 1964 article\n  qrange = range(-0.4, stop = 1.0, length = n)\n  prange = range(-0.5, stop = 0.5, length = n)\n  z0 = Vector{Vector{typeof(E)}}()\n  for q in qrange\n    V = H([0,0],[0,q],nothing)\n    V ≥ E && continue\n    for p in prange\n      T = 1/2*p^2\n      T + V ≥ E && continue\n      z = [√(2(E-V-T)), p, 0, q]\n      push!(z0, z)\n    end\n  end\n  return z0\nend\n\nz0 = generate_ics(0.125, 10)\n\nfunction prob_func(prob,i,repeat)\n  @. prob.u0 = z0[i]\n  prob\nend\n\nensprob = EnsembleProblem(prob, prob_func=prob_func)\nsim = solve(ensprob, Vern9(), EnsembleThreads(), trajectories=length(z0))\n\nplot(sim, vars=(3,4), tspan=(0,10))","category":"page"},{"location":"exercises/02-workshop_solutions/","page":"SciML Workshop Exercise Solutions","title":"SciML Workshop Exercise Solutions","text":"(Image: )","category":"page"},{"location":"exercises/02-workshop_solutions/#Part-4:-Parallelized-GPU-Ensemble-Solving","page":"SciML Workshop Exercise Solutions","title":"Part 4: Parallelized GPU Ensemble Solving","text":"","category":"section"},{"location":"exercises/02-workshop_solutions/","page":"SciML Workshop Exercise Solutions","title":"SciML Workshop Exercise Solutions","text":"In order to use GPU parallelization we must make all inputs (initial conditions, tspan, etc.) Float32 and the function definition should be in the in-place form, avoid bound checking and return nothing.","category":"page"},{"location":"exercises/02-workshop_solutions/","page":"SciML Workshop Exercise Solutions","title":"SciML Workshop Exercise Solutions","text":"using DiffEqGPU\n\nfunction henon_gpu(dz,z,p,t)\n  @inbounds begin\n    dz[1] = -z[3]*(1 + 2z[4])\n    dz[2] = -z[4]-(z[3]^2 - z[4]^2)\n    dz[3] = z[1]\n    dz[4] = z[2]\n  end\n  return nothing\nend\n\nz0 = generate_ics(0.125f0, 50)\nprob_gpu = ODEProblem(henon_gpu, Float32.(u₀), (0.f0, 1000.f0))\nensprob = EnsembleProblem(prob_gpu, prob_func=prob_func)\nsim = solve(ensprob, Tsit5(), EnsembleGPUArray(), trajectories=length(z0))","category":"page"},{"location":"exercises/02-workshop_solutions/","page":"SciML Workshop Exercise Solutions","title":"SciML Workshop Exercise Solutions","text":"EnsembleSolution Solution of length 1440 with uType:\nDiffEqBase.ODESolution{Float32,2,Array{SubArray{Float32,1,Array{Float32,2},\nTuple{Base.Slice{Base.OneTo{Int64}},Int64},true},1},Nothing,Nothing,Array{F\nloat32,1},Nothing,DiffEqBase.ODEProblem{Array{Float32,1},Tuple{Float32,Floa\nt32},true,DiffEqBase.NullParameters,DiffEqBase.ODEFunction{true,typeof(Main\n.##WeaveSandBox#2247.henon_gpu),LinearAlgebra.UniformScaling{Bool},Nothing,\nNothing,Nothing,Nothing,Nothing,Nothing,Nothing,Nothing,Nothing,Nothing,Not\nhing,Nothing},Base.Iterators.Pairs{Union{},Union{},Tuple{},NamedTuple{(),Tu\nple{}}},DiffEqBase.StandardODEProblem},OrdinaryDiffEq.Tsit5,DiffEqBase.Line\narInterpolation{Array{Float32,1},Array{SubArray{Float32,1,Array{Float32,2},\nTuple{Base.Slice{Base.OneTo{Int64}},Int64},true},1}},DiffEqBase.DEStats}","category":"page"},{"location":"exercises/02-workshop_solutions/#Problem-6:-Training-Neural-Stochastic-Differential-Equations-with-GPU-acceleration-(I)","page":"SciML Workshop Exercise Solutions","title":"Problem 6: Training Neural Stochastic Differential Equations with GPU acceleration (I)","text":"","category":"section"},{"location":"exercises/02-workshop_solutions/#Part-1:-Constructing-and-Training-a-Basic-Neural-ODE","page":"SciML Workshop Exercise Solutions","title":"Part 1: Constructing and Training a Basic Neural ODE","text":"","category":"section"},{"location":"exercises/02-workshop_solutions/#Part-2:-GPU-accelerating-the-Neural-ODE-Process","page":"SciML Workshop Exercise Solutions","title":"Part 2: GPU-accelerating the Neural ODE Process","text":"","category":"section"},{"location":"exercises/02-workshop_solutions/#Part-3:-Defining-and-Training-a-Mixed-Neural-ODE","page":"SciML Workshop Exercise Solutions","title":"Part 3: Defining and Training a Mixed Neural ODE","text":"","category":"section"},{"location":"exercises/02-workshop_solutions/#Part-4:-Constructing-a-Basic-Neural-SDE","page":"SciML Workshop Exercise Solutions","title":"Part 4: Constructing a Basic Neural SDE","text":"","category":"section"},{"location":"exercises/02-workshop_solutions/#Part-5:-Optimizing-the-training-behavior-with-minibatching-(E)","page":"SciML Workshop Exercise Solutions","title":"Part 5: Optimizing the training behavior with minibatching (E)","text":"","category":"section"},{"location":"exercises/02-workshop_solutions/#Information-on-the-Build","page":"SciML Workshop Exercise Solutions","title":"Information on the Build","text":"","category":"section"},{"location":"exercises/02-workshop_solutions/#Appendix","page":"SciML Workshop Exercise Solutions","title":"Appendix","text":"","category":"section"},{"location":"exercises/02-workshop_solutions/","page":"SciML Workshop Exercise Solutions","title":"SciML Workshop Exercise Solutions","text":"This tutorial is part of the SciMLTutorials.jl repository, found at: https://github.com/SciMLTutorials/SciMLTutorials.jl.  For more information on doing scientific machine learning (SciML) with open source software, check out https://sciml.ai/.","category":"page"},{"location":"exercises/02-workshop_solutions/","page":"SciML Workshop Exercise Solutions","title":"SciML Workshop Exercise Solutions","text":"To locally run this tutorial, do the following commands:","category":"page"},{"location":"exercises/02-workshop_solutions/","page":"SciML Workshop Exercise Solutions","title":"SciML Workshop Exercise Solutions","text":"using SciMLTutorials\nSciMLTutorials.weave_file(\"exercises\",\"02-workshop_solutions.jmd\")","category":"page"},{"location":"exercises/02-workshop_solutions/","page":"SciML Workshop Exercise Solutions","title":"SciML Workshop Exercise Solutions","text":"Computer Information:","category":"page"},{"location":"exercises/02-workshop_solutions/","page":"SciML Workshop Exercise Solutions","title":"SciML Workshop Exercise Solutions","text":"Julia Version 1.4.2\nCommit 44fa15b150* (2020-05-23 18:35 UTC)\nPlatform Info:\n  OS: Linux (x86_64-pc-linux-gnu)\n  CPU: Intel(R) Core(TM) i7-9700K CPU @ 3.60GHz\n  WORD_SIZE: 64\n  LIBM: libopenlibm\n  LLVM: libLLVM-8.0.1 (ORCJIT, skylake)\nEnvironment:\n  JULIA_LOAD_PATH = /builds/JuliaGPU/DiffEqTutorials.jl:\n  JULIA_DEPOT_PATH = /builds/JuliaGPU/DiffEqTutorials.jl/.julia\n  JULIA_CUDA_MEMORY_LIMIT = 2147483648\n  JULIA_NUM_THREADS = 8\n","category":"page"},{"location":"exercises/02-workshop_solutions/","page":"SciML Workshop Exercise Solutions","title":"SciML Workshop Exercise Solutions","text":"Package Information:","category":"page"},{"location":"exercises/02-workshop_solutions/","page":"SciML Workshop Exercise Solutions","title":"SciML Workshop Exercise Solutions","text":"Status `/builds/JuliaGPU/DiffEqTutorials.jl/tutorials/exercises/Project.toml`\n[2169fc97-5a83-5252-b627-83903c6c433c] AlgebraicMultigrid 0.3.0\n[6e4b80f9-dd63-53aa-95a3-0cdb28fa8baf] BenchmarkTools 0.5.0\n[f3b72e0c-5b89-59e1-b016-84e28bfd966d] DiffEqDevTools 2.24.0\n[aae7a2af-3d4f-5e19-a356-7da93b79d9d0] DiffEqFlux 1.17.0\n[071ae1c0-96b5-11e9-1965-c90190d839ea] DiffEqGPU 1.3.0\n[9fdde737-9c7f-55bf-ade8-46b3f136cc48] DiffEqOperators 4.10.0\n[0c46a032-eb83-5123-abaf-570d42b7fbaa] DifferentialEquations 6.15.0\n[587475ba-b771-5e3f-ad9e-33799f191a9c] Flux 0.10.4\n[429524aa-4258-5aef-a3af-852621145aeb] Optim 0.22.0\n[91a5bcdd-55d7-5caf-9e0b-520d859cae80] Plots 1.5.6\n[47a9eef4-7e08-11e9-0b38-333d64bd3804] SparseDiffTools 1.9.1\n[684fba80-ace3-11e9-3d08-3bc7ed6f96df] SparsityDetection 0.3.3\n[c3572dad-4567-51f8-b174-8c6c989267f4] Sundials 4.2.5","category":"page"},{"location":"models/01-classical_physics/#Classical-Physics-Models","page":"Classical Physics Models","title":"Classical Physics Models","text":"","category":"section"},{"location":"models/01-classical_physics/","page":"Classical Physics Models","title":"Classical Physics Models","text":"If you're getting some cold feet to jump in to DiffEq land, here are some handcrafted differential equations mini problems to hold your hand along the beginning of your journey.","category":"page"},{"location":"models/01-classical_physics/#First-order-linear-ODE","page":"Classical Physics Models","title":"First order linear ODE","text":"","category":"section"},{"location":"models/01-classical_physics/#Radioactive-Decay-of-Carbon-14","page":"Classical Physics Models","title":"Radioactive Decay of Carbon-14","text":"","category":"section"},{"location":"models/01-classical_physics/","page":"Classical Physics Models","title":"Classical Physics Models","text":"f(tu) = fracdudt","category":"page"},{"location":"models/01-classical_physics/","page":"Classical Physics Models","title":"Classical Physics Models","text":"The Radioactive decay problem is the first order linear ODE problem of an exponential with a negative coefficient, which represents the half-life of the process in question. Should the coefficient be positive, this would represent a population growth equation.","category":"page"},{"location":"models/01-classical_physics/","page":"Classical Physics Models","title":"Classical Physics Models","text":"using OrdinaryDiffEq, Plots\ngr()\n\n#Half-life of Carbon-14 is 5,730 years.\nC₁ = 5.730\n\n#Setup\nu₀ = 1.0\ntspan = (0.0, 1.0)\n\n#Define the problem\nradioactivedecay(u,p,t) = -C₁*u\n\n#Pass to solver\nprob = ODEProblem(radioactivedecay,u₀,tspan)\nsol = solve(prob,Tsit5())\n\n#Plot\nplot(sol,linewidth=2,title =\"Carbon-14 half-life\", xaxis = \"Time in thousands of years\", yaxis = \"Percentage left\", label = \"Numerical Solution\")\nplot!(sol.t, t->exp(-C₁*t),lw=3,ls=:dash,label=\"Analytical Solution\")","category":"page"},{"location":"models/01-classical_physics/","page":"Classical Physics Models","title":"Classical Physics Models","text":"(Image: )","category":"page"},{"location":"models/01-classical_physics/#Second-Order-Linear-ODE","page":"Classical Physics Models","title":"Second Order Linear ODE","text":"","category":"section"},{"location":"models/01-classical_physics/#Simple-Harmonic-Oscillator","page":"Classical Physics Models","title":"Simple Harmonic Oscillator","text":"","category":"section"},{"location":"models/01-classical_physics/","page":"Classical Physics Models","title":"Classical Physics Models","text":"Another classical example is the harmonic oscillator, given by $ \\ddot{x} + \\omega^2 x = 0 $ with the known analytical solution $ \\begin{align} x(t) &= A\\cos(\\omega t - \\phi) \\\nv(t) &= -A\\omega\\sin(\\omega t - \\phi), \\end{align} $ where $ A = \\sqrt{c1 + c2} \\qquad\\text{and}\\qquad \\tan \\phi = \\frac{c2}{c1} $ with c_1 c_2 constants determined by the initial conditions such that c_1 is the initial position and omega c_2 is the initial velocity.","category":"page"},{"location":"models/01-classical_physics/","page":"Classical Physics Models","title":"Classical Physics Models","text":"Instead of transforming this to a system of ODEs to solve with ODEProblem, we can use SecondOrderODEProblem as follows.","category":"page"},{"location":"models/01-classical_physics/","page":"Classical Physics Models","title":"Classical Physics Models","text":"# Simple Harmonic Oscillator Problem\nusing OrdinaryDiffEq, Plots\n\n#Parameters\nω = 1\n\n#Initial Conditions\nx₀ = [0.0]\ndx₀ = [π/2]\ntspan = (0.0, 2π)\n\nϕ = atan((dx₀[1]/ω)/x₀[1])\nA = √(x₀[1]^2 + dx₀[1]^2)\n\n#Define the problem\nfunction harmonicoscillator(ddu,du,u,ω,t)\n    ddu .= -ω^2 * u\nend\n\n#Pass to solvers\nprob = SecondOrderODEProblem(harmonicoscillator, dx₀, x₀, tspan, ω)\nsol = solve(prob, DPRKN6())\n\n#Plot\nplot(sol, vars=[2,1], linewidth=2, title =\"Simple Harmonic Oscillator\", xaxis = \"Time\", yaxis = \"Elongation\", label = [\"x\" \"dx\"])\nplot!(t->A*cos(ω*t-ϕ), lw=3, ls=:dash, label=\"Analytical Solution x\")\nplot!(t->-A*ω*sin(ω*t-ϕ), lw=3, ls=:dash, label=\"Analytical Solution dx\")","category":"page"},{"location":"models/01-classical_physics/","page":"Classical Physics Models","title":"Classical Physics Models","text":"(Image: )","category":"page"},{"location":"models/01-classical_physics/","page":"Classical Physics Models","title":"Classical Physics Models","text":"Note that the order of the variables (and initial conditions) is dx, x. Thus, if we want the first series to be x, we have to flip the order with vars=[2,1].","category":"page"},{"location":"models/01-classical_physics/#Second-Order-Non-linear-ODE","page":"Classical Physics Models","title":"Second Order Non-linear ODE","text":"","category":"section"},{"location":"models/01-classical_physics/#Simple-Pendulum","page":"Classical Physics Models","title":"Simple Pendulum","text":"","category":"section"},{"location":"models/01-classical_physics/","page":"Classical Physics Models","title":"Classical Physics Models","text":"We will start by solving the pendulum problem. In the physics class, we often solve this problem by small angle approximation, i.e. $ sin(\\theta) \\approx \\theta$, because otherwise, we get an elliptic integral which doesn't have an analytic solution. The linearized form is","category":"page"},{"location":"models/01-classical_physics/","page":"Classical Physics Models","title":"Classical Physics Models","text":"ddottheta + fracgLtheta = 0","category":"page"},{"location":"models/01-classical_physics/","page":"Classical Physics Models","title":"Classical Physics Models","text":"But we have numerical ODE solvers! Why not solve the real pendulum?","category":"page"},{"location":"models/01-classical_physics/","page":"Classical Physics Models","title":"Classical Physics Models","text":"ddottheta + fracgLsin(theta) = 0","category":"page"},{"location":"models/01-classical_physics/","page":"Classical Physics Models","title":"Classical Physics Models","text":"Notice that now we have a second order ODE. In order to use the same method as above, we nee to transform it into a system of first order ODEs by employing the notation dtheta = dottheta.","category":"page"},{"location":"models/01-classical_physics/","page":"Classical Physics Models","title":"Classical Physics Models","text":"\nbeginalign*\ndottheta = dtheta \ndotdtheta = - fracgLsin(theta)\nendalign*\n\n\njulia\n Simple Pendulum Problem\nusing OrdinaryDiffEq Plots\n\nConstants\nconst g = 981\nL = 10\n\nInitial Conditions\nu₀ = 0π2\ntspan = (0063)\n\nDefine the problem\nfunction simplependulum(duupt)\n    θ = u1\n    dθ = u2\n    du1 = dθ\n    du2 = -(gL)*sin(θ)\nend\n\nPass to solvers\nprob = ODEProblem(simplependulum u₀ tspan)\nsol = solve(probTsit5())\n\nPlot\nplot(sollinewidth=2title =Simple Pendulum Problem xaxis = Time yaxis = Height label = theta dtheta)\n\n\n(figures01-classical_physics_3_1png)\n\n\n\nSo now we know that behaviour of the position versus time However it will be useful to us to look at the phase space of the pendulum ie and representation of all possible states of the system in question (the pendulum) by looking at its velocity and position Phase space analysis is ubiquitous in the analysis of dynamical systems and thus we will provide a few facilities for it\n\njulia\np = plot(solvars = (12) xlims = (-99) title = Phase Space Plot xaxis = Velocity yaxis = Position leg=false)\nfunction phase_plot(prob u0 p tspan=2pi)\n    _prob = ODEProblem(probfu0(00tspan))\n    sol = solve(_probVern9())  Use Vern9 solver for higher accuracy\n    plot(psolvars = (12) xlims = nothing ylims = nothing)\nend\nfor i in -4pipi24π\n    for j in -4pipi24π\n        phase_plot(prob ji p)\n    end\nend\nplot(pxlims = (-99))\n\n\n(figures01-classical_physics_4_1png)\n\n\n\n Double Pendulum\n\nA more complicated example is given by the double pendulum The equations governing\nits motion are given by the following (taken from this StackOverflow question(httpsmathematicastackexchangecomquestions40122help-to-plot-poincarC3A9-section-for-double-pendulum))\n\nfracddt\nbeginpmatrix\nalpha  l_alpha  beta  l_beta\nendpmatrix=\nbeginpmatrix\n2fracl_alpha - (1+cosbeta)l_beta3-cos 2beta \n-2sinalpha - sin(alpha + beta) \n2frac-(1+cosbeta)l_alpha + (3+2cosbeta)l_beta3-cos2beta\n-sin(alpha+beta) - 2sin(beta)frac(l_alpha-l_beta)l_beta3-cos2beta + 2sin(2beta)fracl_alpha^2-2(1+cosbeta)l_alpha l_beta + (3+2cosbeta)l_beta^2(3-cos2beta)^2\nendpmatrix","category":"page"},{"location":"models/01-classical_physics/","page":"Classical Physics Models","title":"Classical Physics Models","text":"#Double Pendulum Problem\nusing OrdinaryDiffEq, Plots\n\n#Constants and setup\nconst m₁, m₂, L₁, L₂ = 1, 2, 1, 2\ninitial = [0, π/3, 0, 3pi/5]\ntspan = (0.,50.)\n\n#Convenience function for transforming from polar to Cartesian coordinates\nfunction polar2cart(sol;dt=0.02,l1=L₁,l2=L₂,vars=(2,4))\n    u = sol.t[1]:dt:sol.t[end]\n\n    p1 = l1*map(x->x[vars[1]], sol.(u))\n    p2 = l2*map(y->y[vars[2]], sol.(u))\n\n    x1 = l1*sin.(p1)\n    y1 = l1*-cos.(p1)\n    (u, (x1 + l2*sin.(p2),\n     y1 - l2*cos.(p2)))\nend\n\n#Define the Problem\nfunction double_pendulum(xdot,x,p,t)\n    xdot[1]=x[2]\n    xdot[2]=-((g*(2*m₁+m₂)*sin(x[1])+m₂*(g*sin(x[1]-2*x[3])+2*(L₂*x[4]^2+L₁*x[2]^2*cos(x[1]-x[3]))*sin(x[1]-x[3])))/(2*L₁*(m₁+m₂-m₂*cos(x[1]-x[3])^2)))\n    xdot[3]=x[4]\n    xdot[4]=(((m₁+m₂)*(L₁*x[2]^2+g*cos(x[1]))+L₂*m₂*x[4]^2*cos(x[1]-x[3]))*sin(x[1]-x[3]))/(L₂*(m₁+m₂-m₂*cos(x[1]-x[3])^2))\nend\n\n#Pass to Solvers\ndouble_pendulum_problem = ODEProblem(double_pendulum, initial, tspan)\nsol = solve(double_pendulum_problem, Vern7(), abs_tol=1e-10, dt=0.05);","category":"page"},{"location":"models/01-classical_physics/","page":"Classical Physics Models","title":"Classical Physics Models","text":"Unrecognized keyword arguments: [:abs_tol]","category":"page"},{"location":"models/01-classical_physics/","page":"Classical Physics Models","title":"Classical Physics Models","text":"#Obtain coordinates in Cartesian Geometry\nts, ps = polar2cart(sol, l1=L₁, l2=L₂, dt=0.01)\nplot(ps...)","category":"page"},{"location":"models/01-classical_physics/","page":"Classical Physics Models","title":"Classical Physics Models","text":"(Image: )","category":"page"},{"location":"models/01-classical_physics/#Poincaré-section","page":"Classical Physics Models","title":"Poincaré section","text":"","category":"section"},{"location":"models/01-classical_physics/","page":"Classical Physics Models","title":"Classical Physics Models","text":"In this case the phase space is 4 dimensional and it cannot be easily visualized. Instead of looking at the full phase space, we can look at Poincaré sections, which are sections through a higher-dimensional phase space diagram. This helps to understand the dynamics of interactions and is wonderfully pretty.","category":"page"},{"location":"models/01-classical_physics/","page":"Classical Physics Models","title":"Classical Physics Models","text":"The Poincaré section in this is given by the collection of (βl_β) when α=0 and fracdαdt0.","category":"page"},{"location":"models/01-classical_physics/","page":"Classical Physics Models","title":"Classical Physics Models","text":"#Constants and setup\nusing OrdinaryDiffEq\ninitial2 = [0.01, 0.005, 0.01, 0.01]\ntspan2 = (0.,500.)\n\n#Define the problem\nfunction double_pendulum_hamiltonian(udot,u,p,t)\n    α  = u[1]\n    lα = u[2]\n    β  = u[3]\n    lβ = u[4]\n    udot .=\n    [2(lα-(1+cos(β))lβ)/(3-cos(2β)),\n    -2sin(α) - sin(α+β),\n    2(-(1+cos(β))lα + (3+2cos(β))lβ)/(3-cos(2β)),\n    -sin(α+β) - 2sin(β)*(((lα-lβ)lβ)/(3-cos(2β))) + 2sin(2β)*((lα^2 - 2(1+cos(β))lα*lβ + (3+2cos(β))lβ^2)/(3-cos(2β))^2)]\nend\n\n# Construct a ContiunousCallback\ncondition(u,t,integrator) = u[1]\naffect!(integrator) = nothing\ncb = ContinuousCallback(condition,affect!,nothing,\n                        save_positions = (true,false))\n\n# Construct Problem\npoincare = ODEProblem(double_pendulum_hamiltonian, initial2, tspan2)\nsol2 = solve(poincare, Vern9(), save_everystep = false, save_start=false, save_end=false, callback=cb, abstol=1e-16, reltol=1e-16,)\n\nfunction poincare_map(prob, u₀, p; callback=cb)\n    _prob = ODEProblem(prob.f, u₀, prob.tspan)\n    sol = solve(_prob, Vern9(), save_everystep = false, save_start=false, save_end=false, callback=cb, abstol=1e-16, reltol=1e-16)\n    scatter!(p, sol, vars=(3,4), markersize = 3, msw=0)\nend","category":"page"},{"location":"models/01-classical_physics/","page":"Classical Physics Models","title":"Classical Physics Models","text":"poincare_map (generic function with 1 method)","category":"page"},{"location":"models/01-classical_physics/","page":"Classical Physics Models","title":"Classical Physics Models","text":"lβrange = -0.02:0.0025:0.02\np = scatter(sol2, vars=(3,4), leg=false, markersize = 3, msw=0)\nfor lβ in lβrange\n    poincare_map(poincare, [0.01, 0.01, 0.01, lβ], p)\nend\nplot(p, xlabel=\"\\\\beta\", ylabel=\"l_\\\\beta\", ylims=(0, 0.03))","category":"page"},{"location":"models/01-classical_physics/","page":"Classical Physics Models","title":"Classical Physics Models","text":"(Image: )","category":"page"},{"location":"models/01-classical_physics/#Hénon-Heiles-System","page":"Classical Physics Models","title":"Hénon-Heiles System","text":"","category":"section"},{"location":"models/01-classical_physics/","page":"Classical Physics Models","title":"Classical Physics Models","text":"The Hénon-Heiles potential occurs when non-linear motion of a star around a galactic center with the motion restricted to a plane.","category":"page"},{"location":"models/01-classical_physics/","page":"Classical Physics Models","title":"Classical Physics Models","text":"\nbeginalign\nfracd^2xdt^2=-fracpartial Vpartial x\nfracd^2ydt^2=-fracpartial Vpartial y\nendalign\n\n\nwhere\n\nV(xy)=frac 12(x^2+y^2)+lambda left(x^2y-frac y^33right)","category":"page"},{"location":"models/01-classical_physics/","page":"Classical Physics Models","title":"Classical Physics Models","text":"We pick lambda=1 in this case, so","category":"page"},{"location":"models/01-classical_physics/","page":"Classical Physics Models","title":"Classical Physics Models","text":"V(xy) = frac12(x^2+y^2+2x^2y-frac23y^3)","category":"page"},{"location":"models/01-classical_physics/","page":"Classical Physics Models","title":"Classical Physics Models","text":"Then the total energy of the system can be expressed by","category":"page"},{"location":"models/01-classical_physics/","page":"Classical Physics Models","title":"Classical Physics Models","text":"E = T+V = V(xy)+frac12(dotx^2+doty^2)","category":"page"},{"location":"models/01-classical_physics/","page":"Classical Physics Models","title":"Classical Physics Models","text":"The total energy should conserve as this system evolves.","category":"page"},{"location":"models/01-classical_physics/","page":"Classical Physics Models","title":"Classical Physics Models","text":"using OrdinaryDiffEq, Plots\n\n#Setup\ninitial = [0.,0.1,0.5,0]\ntspan = (0,100.)\n\n#Remember, V is the potential of the system and T is the Total Kinetic Energy, thus E will\n#the total energy of the system.\nV(x,y) = 1//2 * (x^2 + y^2 + 2x^2*y - 2//3 * y^3)\nE(x,y,dx,dy) = V(x,y) + 1//2 * (dx^2 + dy^2);\n\n#Define the function\nfunction Hénon_Heiles(du,u,p,t)\n    x  = u[1]\n    y  = u[2]\n    dx = u[3]\n    dy = u[4]\n    du[1] = dx\n    du[2] = dy\n    du[3] = -x - 2x*y\n    du[4] = y^2 - y -x^2\nend\n\n#Pass to solvers\nprob = ODEProblem(Hénon_Heiles, initial, tspan)\nsol = solve(prob, Vern9(), abs_tol=1e-16, rel_tol=1e-16);","category":"page"},{"location":"models/01-classical_physics/","page":"Classical Physics Models","title":"Classical Physics Models","text":"Unrecognized keyword arguments: [:abs_tol, :rel_tol]","category":"page"},{"location":"models/01-classical_physics/","page":"Classical Physics Models","title":"Classical Physics Models","text":"# Plot the orbit\nplot(sol, vars=(1,2), title = \"The orbit of the Hénon-Heiles system\", xaxis = \"x\", yaxis = \"y\", leg=false)","category":"page"},{"location":"models/01-classical_physics/","page":"Classical Physics Models","title":"Classical Physics Models","text":"(Image: )","category":"page"},{"location":"models/01-classical_physics/","page":"Classical Physics Models","title":"Classical Physics Models","text":"#Optional Sanity check - what do you think this returns and why?\n@show sol.retcode\n\n#Plot -\nplot(sol, vars=(1,3), title = \"Phase space for the Hénon-Heiles system\", xaxis = \"Position\", yaxis = \"Velocity\")\nplot!(sol, vars=(2,4), leg = false)","category":"page"},{"location":"models/01-classical_physics/","page":"Classical Physics Models","title":"Classical Physics Models","text":"sol.retcode = :Success","category":"page"},{"location":"models/01-classical_physics/","page":"Classical Physics Models","title":"Classical Physics Models","text":"(Image: )","category":"page"},{"location":"models/01-classical_physics/","page":"Classical Physics Models","title":"Classical Physics Models","text":"#We map the Total energies during the time intervals of the solution (sol.u here) to a new vector\n#pass it to the plotter a bit more conveniently\nenergy = map(x->E(x...), sol.u)\n\n#We use @show here to easily spot erratic behaviour in our system by seeing if the loss in energy was too great.\n@show ΔE = energy[1]-energy[end]\n\n#Plot\nplot(sol.t, energy .- energy[1], title = \"Change in Energy over Time\", xaxis = \"Time in iterations\", yaxis = \"Change in Energy\")","category":"page"},{"location":"models/01-classical_physics/","page":"Classical Physics Models","title":"Classical Physics Models","text":"ΔE = energy[1] - energy[end] = -3.098606695015049e-5","category":"page"},{"location":"models/01-classical_physics/","page":"Classical Physics Models","title":"Classical Physics Models","text":"(Image: )","category":"page"},{"location":"models/01-classical_physics/#Symplectic-Integration","page":"Classical Physics Models","title":"Symplectic Integration","text":"","category":"section"},{"location":"models/01-classical_physics/","page":"Classical Physics Models","title":"Classical Physics Models","text":"To prevent energy drift, we can instead use a symplectic integrator. We can directly define and solve the SecondOrderODEProblem:","category":"page"},{"location":"models/01-classical_physics/","page":"Classical Physics Models","title":"Classical Physics Models","text":"function HH_acceleration!(dv,v,u,p,t)\n    x,y  = u\n    dx,dy = dv\n    dv[1] = -x - 2x*y\n    dv[2] = y^2 - y -x^2\nend\ninitial_positions = [0.0,0.1]\ninitial_velocities = [0.5,0.0]\nprob = SecondOrderODEProblem(HH_acceleration!,initial_velocities,initial_positions,tspan)\nsol2 = solve(prob, KahanLi8(), dt=1/10);","category":"page"},{"location":"models/01-classical_physics/","page":"Classical Physics Models","title":"Classical Physics Models","text":"Notice that we get the same results:","category":"page"},{"location":"models/01-classical_physics/","page":"Classical Physics Models","title":"Classical Physics Models","text":"# Plot the orbit\nplot(sol2, vars=(3,4), title = \"The orbit of the Hénon-Heiles system\", xaxis = \"x\", yaxis = \"y\", leg=false)","category":"page"},{"location":"models/01-classical_physics/","page":"Classical Physics Models","title":"Classical Physics Models","text":"(Image: )","category":"page"},{"location":"models/01-classical_physics/","page":"Classical Physics Models","title":"Classical Physics Models","text":"plot(sol2, vars=(3,1), title = \"Phase space for the Hénon-Heiles system\", xaxis = \"Position\", yaxis = \"Velocity\")\nplot!(sol2, vars=(4,2), leg = false)","category":"page"},{"location":"models/01-classical_physics/","page":"Classical Physics Models","title":"Classical Physics Models","text":"(Image: )","category":"page"},{"location":"models/01-classical_physics/","page":"Classical Physics Models","title":"Classical Physics Models","text":"but now the energy change is essentially zero:","category":"page"},{"location":"models/01-classical_physics/","page":"Classical Physics Models","title":"Classical Physics Models","text":"energy = map(x->E(x[3], x[4], x[1], x[2]), sol2.u)\n#We use @show here to easily spot erratic behaviour in our system by seeing if the loss in energy was too great.\n@show ΔE = energy[1]-energy[end]\n\n#Plot\nplot(sol2.t, energy .- energy[1], title = \"Change in Energy over Time\", xaxis = \"Time in iterations\", yaxis = \"Change in Energy\")","category":"page"},{"location":"models/01-classical_physics/","page":"Classical Physics Models","title":"Classical Physics Models","text":"ΔE = energy[1] - energy[end] = 9.048317650695026e-15","category":"page"},{"location":"models/01-classical_physics/","page":"Classical Physics Models","title":"Classical Physics Models","text":"(Image: )","category":"page"},{"location":"models/01-classical_physics/","page":"Classical Physics Models","title":"Classical Physics Models","text":"And let's try to use a Runge-Kutta-Nyström solver to solve this. Note that Runge-Kutta-Nyström isn't symplectic.","category":"page"},{"location":"models/01-classical_physics/","page":"Classical Physics Models","title":"Classical Physics Models","text":"sol3 = solve(prob, DPRKN6());\nenergy = map(x->E(x[3], x[4], x[1], x[2]), sol3.u)\n@show ΔE = energy[1]-energy[end]\ngr()\nplot(sol3.t, energy .- energy[1], title = \"Change in Energy over Time\", xaxis = \"Time in iterations\", yaxis = \"Change in Energy\")","category":"page"},{"location":"models/01-classical_physics/","page":"Classical Physics Models","title":"Classical Physics Models","text":"ΔE = energy[1] - energy[end] = -2.7232529575260678e-6","category":"page"},{"location":"models/01-classical_physics/","page":"Classical Physics Models","title":"Classical Physics Models","text":"(Image: )","category":"page"},{"location":"models/01-classical_physics/","page":"Classical Physics Models","title":"Classical Physics Models","text":"Note that we are using the DPRKN6 sovler at reltol=1e-3 (the default), yet it has a smaller energy variation than Vern9 at abs_tol=1e-16, rel_tol=1e-16. Therefore, using specialized solvers to solve its particular problem is very efficient.","category":"page"},{"location":"models/01-classical_physics/#Appendix","page":"Classical Physics Models","title":"Appendix","text":"","category":"section"},{"location":"models/01-classical_physics/","page":"Classical Physics Models","title":"Classical Physics Models","text":"These tutorials are a part of the SciMLTutorials.jl repository, found at: https://github.com/SciML/SciMLTutorials.jl. For more information on high-performance scientific machine learning, check out the SciML Open Source Software Organization https://sciml.ai.","category":"page"},{"location":"models/01-classical_physics/","page":"Classical Physics Models","title":"Classical Physics Models","text":"To locally run this tutorial, do the following commands:","category":"page"},{"location":"models/01-classical_physics/","page":"Classical Physics Models","title":"Classical Physics Models","text":"using SciMLTutorials\nSciMLTutorials.weave_file(\"tutorials/models\",\"01-classical_physics.jmd\")","category":"page"},{"location":"models/01-classical_physics/","page":"Classical Physics Models","title":"Classical Physics Models","text":"Computer Information:","category":"page"},{"location":"models/01-classical_physics/","page":"Classical Physics Models","title":"Classical Physics Models","text":"Julia Version 1.8.0\nCommit 5544a0fab76 (2022-08-17 13:38 UTC)\nPlatform Info:\n  OS: Linux (x86_64-linux-gnu)\n  CPU: 128 × AMD EPYC 7502 32-Core Processor\n  WORD_SIZE: 64\n  LIBM: libopenlibm\n  LLVM: libLLVM-13.0.1 (ORCJIT, znver2)\n  Threads: 1 on 128 virtual cores\nEnvironment:\n  JULIA_CPU_THREADS = 128\n  JULIA_DEPOT_PATH = /cache/julia-buildkite-plugin/depots/a6029d3a-f78b-41ea-bc97-28aa57c6c6ea\n","category":"page"},{"location":"models/01-classical_physics/","page":"Classical Physics Models","title":"Classical Physics Models","text":"Package Information:","category":"page"},{"location":"models/01-classical_physics/","page":"Classical Physics Models","title":"Classical Physics Models","text":"Status `/cache/build/exclusive-amdci1-0/julialang/scimltutorials-dot-jl/tutorials/models/Project.toml`\n  [479239e8] Catalyst v12.2.1\n  [459566f4] DiffEqCallbacks v2.24.1\n  [f3b72e0c] DiffEqDevTools v2.31.2\n  [055956cb] DiffEqPhysics v3.9.0\n  [0c46a032] DifferentialEquations v7.3.0\n  [31c24e10] Distributions v0.25.70\n  [587475ba] Flux v0.13.5\n  [f6369f11] ForwardDiff v0.10.32\n  [23fbe1c1] Latexify v0.15.16\n  [961ee093] ModelingToolkit v8.21.0\n  [2774e3e8] NLsolve v4.5.1\n⌅ [315f7962] NeuralPDE v4.11.0\n  [429524aa] Optim v1.7.2\n  [1dea7af3] OrdinaryDiffEq v6.26.2\n  [91a5bcdd] Plots v1.32.0\n  [731186ca] RecursiveArrayTools v2.32.0\n  [30cb0354] SciMLTutorials v1.0.0\n  [789caeaf] StochasticDiffEq v6.53.0\n  [37e2e46d] LinearAlgebra\n  [2f01184e] SparseArrays\nInfo Packages marked with ⌅ have new versions available but cannot be upgraded. To see why use `status --outdated`","category":"page"},{"location":"models/01-classical_physics/","page":"Classical Physics Models","title":"Classical Physics Models","text":"And the full manifest:","category":"page"},{"location":"models/01-classical_physics/","page":"Classical Physics Models","title":"Classical Physics Models","text":"Status `/cache/build/exclusive-amdci1-0/julialang/scimltutorials-dot-jl/tutorials/models/Manifest.toml`\n  [c3fe647b] AbstractAlgebra v0.27.4\n  [621f4979] AbstractFFTs v1.2.1\n  [1520ce14] AbstractTrees v0.4.2\n  [7d9f7c33] Accessors v0.1.20\n  [79e6a3ab] Adapt v3.4.0\n  [dce04be8] ArgCheck v2.3.0\n  [ec485272] ArnoldiMethod v0.2.0\n  [4fba245c] ArrayInterface v6.0.23\n  [30b0a656] ArrayInterfaceCore v0.1.20\n  [6ba088a2] ArrayInterfaceGPUArrays v0.2.1\n  [015c0d05] ArrayInterfaceOffsetArrays v0.1.6\n  [b0d46f97] ArrayInterfaceStaticArrays v0.1.4\n  [dd5226c6] ArrayInterfaceStaticArraysCore v0.1.0\n  [a2b0951a] ArrayInterfaceTracker v0.1.1\n  [4c555306] ArrayLayouts v0.8.11\n  [15f4f7f2] AutoHashEquals v0.2.0\n  [ab4f0b2a] BFloat16s v0.2.0\n  [aae01518] BandedMatrices v0.17.6\n  [198e06fe] BangBang v0.3.36\n  [9718e550] Baselet v0.1.1\n  [e2ed5e7c] Bijections v0.1.4\n  [62783981] BitTwiddlingConvenienceFunctions v0.1.4\n  [8e7c35d0] BlockArrays v0.16.20\n  [ffab5731] BlockBandedMatrices v0.11.9\n  [764a87c0] BoundaryValueDiffEq v2.9.0\n  [fa961155] CEnum v0.4.2\n  [2a0fbf3d] CPUSummary v0.1.25\n  [00ebfdb7] CSTParser v3.3.6\n  [052768ef] CUDA v3.12.0\n  [49dc2e85] Calculus v0.5.1\n  [7057c7e9] Cassette v0.3.10\n  [479239e8] Catalyst v12.2.1\n  [082447d4] ChainRules v1.44.6\n  [d360d2e6] ChainRulesCore v1.15.4\n  [9e997f8a] ChangesOfVariables v0.1.4\n  [fb6a15b2] CloseOpenIntervals v0.1.10\n  [944b1d66] CodecZlib v0.7.0\n  [35d6a980] ColorSchemes v3.19.0\n  [3da002f7] ColorTypes v0.11.4\n  [c3611d14] ColorVectorSpace v0.9.9\n  [5ae59095] Colors v0.12.8\n  [861a8166] Combinatorics v1.0.2\n  [a80b9123] CommonMark v0.8.6\n  [38540f10] CommonSolve v0.2.1\n  [bbf7d656] CommonSubexpressions v0.3.0\n⌅ [34da2185] Compat v3.46.0\n  [b0b7db55] ComponentArrays v0.13.2\n  [b152e2b5] CompositeTypes v0.1.2\n  [a33af91c] CompositionsBase v0.1.1\n  [8f4d0f93] Conda v1.7.0\n  [88cd18e8] ConsoleProgressMonitor v0.1.2\n  [187b0558] ConstructionBase v1.4.1\n  [6add18c4] ContextVariablesX v0.1.2\n  [d38c429a] Contour v0.6.2\n  [adafc99b] CpuId v0.3.1\n  [a8cc5b0e] Crayons v4.1.1\n  [8a292aeb] Cuba v2.2.0\n  [667455a9] Cubature v1.5.1\n  [9a962f9c] DataAPI v1.10.0\n  [82cc6244] DataInterpolations v3.10.1\n  [864edb3b] DataStructures v0.18.13\n  [e2d170a0] DataValueInterfaces v1.0.0\n  [244e2a9f] DefineSingletons v0.1.2\n  [bcd4f6db] DelayDiffEq v5.37.1\n  [b429d917] DensityInterface v0.4.0\n  [2b5f629d] DiffEqBase v6.100.0\n  [459566f4] DiffEqCallbacks v2.24.1\n  [f3b72e0c] DiffEqDevTools v2.31.2\n  [aae7a2af] DiffEqFlux v1.52.0\n  [77a26b50] DiffEqNoiseProcess v5.12.3\n  [9fdde737] DiffEqOperators v4.43.1\n  [055956cb] DiffEqPhysics v3.9.0\n  [41bf760c] DiffEqSensitivity v6.79.0\n  [163ba53b] DiffResults v1.0.3\n  [b552c78f] DiffRules v1.11.1\n  [0c46a032] DifferentialEquations v7.3.0\n  [b4f34e82] Distances v0.10.7\n  [31c24e10] Distributions v0.25.70\n  [ced4e74d] DistributionsAD v0.6.42\n⌅ [ffbed154] DocStringExtensions v0.8.6\n  [5b8099bc] DomainSets v0.5.13\n  [fa6b7ba4] DualNumbers v0.6.8\n  [7c1d4256] DynamicPolynomials v0.4.5\n  [da5c29d0] EllipsisNotation v1.6.0\n  [7da242da] Enzyme v0.10.4\n  [d4d017d3] ExponentialUtilities v1.18.0\n  [e2ba6199] ExprTools v0.1.8\n  [411431e0] Extents v0.1.1\n  [c87230d0] FFMPEG v0.4.1\n  [cc61a311] FLoops v0.2.0\n  [b9860ae5] FLoopsBase v0.1.1\n  [7034ab61] FastBroadcast v0.2.1\n  [9aa1b823] FastClosures v0.3.2\n  [29a986be] FastLapackInterface v1.2.6\n  [1a297f60] FillArrays v0.13.4\n⌃ [6a86dc24] FiniteDiff v2.13.1\n  [53c48c17] FixedPointNumbers v0.8.4\n  [587475ba] Flux v0.13.5\n  [9c68100b] FoldsThreads v0.1.1\n  [59287772] Formatting v0.4.2\n  [f6369f11] ForwardDiff v0.10.32\n  [069b7b12] FunctionWrappers v1.1.2\n  [77dc65aa] FunctionWrappersWrappers v0.1.1\n  [d9f16b24] Functors v0.3.0\n  [0c68f7d7] GPUArrays v8.5.0\n  [46192b85] GPUArraysCore v0.1.2\n  [61eb1bfa] GPUCompiler v0.16.3\n  [28b8d3ca] GR v0.66.2\n  [c145ed77] GenericSchur v0.5.3\n  [cf35fbd7] GeoInterface v1.0.1\n  [5c1252a2] GeometryBasics v0.4.3\n  [86223c79] Graphs v1.7.2\n  [42e2da0e] Grisu v1.0.2\n  [0b43b601] Groebner v0.2.10\n  [d5909c97] GroupsCore v0.4.0\n  [19dc6840] HCubature v1.5.0\n  [cd3eb016] HTTP v1.3.3\n⌅ [eafb193a] Highlights v0.4.5\n  [3e5b6fbb] HostCPUFeatures v0.1.8\n  [34004b35] HypergeometricFunctions v0.3.11\n  [7073ff75] IJulia v1.23.3\n  [7869d1d1] IRTools v0.4.6\n  [615f187c] IfElse v0.1.1\n  [d25df0c9] Inflate v0.1.3\n  [83e8ac13] IniFile v0.5.1\n  [22cec73e] InitialValues v0.3.1\n  [18e54dd8] IntegerMathUtils v0.1.0\n  [8197267c] IntervalSets v0.7.2\n  [3587e190] InverseFunctions v0.1.7\n  [92d709cd] IrrationalConstants v0.1.1\n  [c8e1da08] IterTools v1.4.0\n  [42fd0dbc] IterativeSolvers v0.9.2\n  [82899510] IteratorInterfaceExtensions v1.0.0\n  [692b3bcd] JLLWrappers v1.4.1\n  [682c06a0] JSON v0.21.3\n  [98e50ef6] JuliaFormatter v1.0.9\n  [b14d175d] JuliaVariables v0.2.4\n  [ccbc3e58] JumpProcesses v9.2.0\n  [ef3ab10e] KLU v0.3.0\n  [ba0b0d4f] Krylov v0.8.3\n  [0b1a1467] KrylovKit v0.5.4\n  [929cbde3] LLVM v4.14.0\n  [b964fa9f] LaTeXStrings v1.3.0\n  [2ee39098] LabelledArrays v1.12.0\n  [23fbe1c1] Latexify v0.15.16\n  [a5e1c1ea] LatinHypercubeSampling v1.8.0\n  [73f95e8e] LatticeRules v0.0.1\n  [10f19ff3] LayoutPointers v0.1.10\n  [50d2b5c4] Lazy v0.15.1\n  [5078a376] LazyArrays v0.22.11\n⌅ [d7e5e226] LazyBandedMatrices v0.7.17\n  [0fc2ff8b] LeastSquaresOptim v0.8.3\n  [1d6d02ad] LeftChildRightSiblingTrees v0.2.0\n  [2d8b4e74] LevyArea v1.0.0\n  [d3d80556] LineSearches v7.2.0\n  [7ed4a6bd] LinearSolve v1.26.0\n  [2ab3a3ac] LogExpFunctions v0.3.18\n  [e6f89c97] LoggingExtras v0.4.9\n  [bdcacae8] LoopVectorization v0.12.125\n  [b2108857] Lux v0.4.21\n  [d8e11817] MLStyle v0.4.13\n  [f1d291b0] MLUtils v0.2.10\n  [1914dd2f] MacroTools v0.5.9\n  [d125e4d3] ManualMemory v0.1.8\n  [a3b82374] MatrixFactorizations v0.9.2\n  [739be429] MbedTLS v1.1.5\n  [442fdcdd] Measures v0.3.1\n  [c03570c3] Memoize v0.4.4\n  [e9d8d322] Metatheory v1.3.4\n  [128add7d] MicroCollections v0.1.2\n  [e1d29d7a] Missings v1.0.2\n  [961ee093] ModelingToolkit v8.21.0\n⌅ [4886b29c] MonteCarloIntegration v0.0.3\n  [46d2c3a1] MuladdMacro v0.2.2\n  [102ac46a] MultivariatePolynomials v0.4.6\n  [ffc61752] Mustache v1.0.14\n  [d8a4904e] MutableArithmetics v1.0.4\n  [d41bc354] NLSolversBase v7.8.2\n  [2774e3e8] NLsolve v4.5.1\n  [872c559c] NNlib v0.8.9\n  [a00861dc] NNlibCUDA v0.2.4\n  [77ba4419] NaNMath v1.0.1\n  [71a1bf82] NameResolution v0.1.5\n⌅ [315f7962] NeuralPDE v4.11.0\n  [8913a72c] NonlinearSolve v0.3.22\n  [d8793406] ObjectFile v0.3.7\n  [6fe1bfb0] OffsetArrays v1.12.7\n  [429524aa] Optim v1.7.2\n  [3bd65402] Optimisers v0.2.9\n  [7f7a1694] Optimization v3.8.2\n  [253f991c] OptimizationFlux v0.1.0\n  [36348300] OptimizationOptimJL v0.1.2\n  [42dfb2eb] OptimizationOptimisers v0.1.0\n  [500b13db] OptimizationPolyalgorithms v0.1.0\n  [bac558e1] OrderedCollections v1.4.1\n  [1dea7af3] OrdinaryDiffEq v6.26.2\n  [90014a1f] PDMats v0.11.16\n  [d96e819e] Parameters v0.12.3\n  [69de0a69] Parsers v2.4.0\n  [ccf2f8ad] PlotThemes v3.0.0\n  [995b91a9] PlotUtils v1.3.0\n  [91a5bcdd] Plots v1.32.0\n  [e409e4f3] PoissonRandom v0.4.1\n  [f517fe37] Polyester v0.6.15\n  [1d0040c9] PolyesterWeave v0.1.9\n  [85a6dd25] PositiveFactorizations v0.2.4\n  [d236fae5] PreallocationTools v0.4.2\n  [21216c6a] Preferences v1.3.0\n  [8162dcfd] PrettyPrint v0.2.0\n  [27ebfcd6] Primes v0.5.3\n  [33c8b6b6] ProgressLogging v0.1.4\n  [92933f4c] ProgressMeter v1.7.2\n  [1fd47b50] QuadGK v2.5.0\n  [67601950] Quadrature v2.1.0\n  [e0ec9b62] QuadratureCubature v0.1.1\n  [8a4e6c94] QuasiMonteCarlo v0.2.9\n  [74087812] Random123 v1.6.0\n  [fb686558] RandomExtensions v0.4.3\n  [e6cf234a] RandomNumbers v1.5.3\n  [c1ae055f] RealDot v0.1.0\n  [3cdcf5f2] RecipesBase v1.2.1\n  [01d81517] RecipesPipeline v0.6.3\n  [731186ca] RecursiveArrayTools v2.32.0\n  [f2c3362d] RecursiveFactorization v0.2.12\n  [189a3867] Reexport v1.2.2\n  [42d2dcc6] Referenceables v0.1.2\n  [29dad682] RegularizationTools v0.6.0\n⌅ [05181044] RelocatableFolders v0.3.0\n  [ae029012] Requires v1.3.0\n  [ae5879a3] ResettableStacks v1.1.1\n  [37e2e3b7] ReverseDiff v1.14.1\n  [79098fc4] Rmath v0.7.0\n  [47965b36] RootedTrees v2.13.0\n  [7e49a35a] RuntimeGeneratedFunctions v0.5.3\n  [3cdde19b] SIMDDualNumbers v0.1.1\n  [94e857df] SIMDTypes v0.1.0\n  [476501e8] SLEEFPirates v0.6.35\n  [0bca4576] SciMLBase v1.53.2\n  [1ed8b502] SciMLSensitivity v7.7.0\n  [30cb0354] SciMLTutorials v1.0.0\n  [6c6a2e73] Scratch v1.1.1\n⌅ [efcf1570] Setfield v0.8.2\n  [605ecd9f] ShowCases v0.1.0\n  [992d4aef] Showoff v1.0.3\n  [777ac1f9] SimpleBufferStream v1.1.0\n  [699a6c99] SimpleTraits v0.9.4\n  [66db9d55] SnoopPrecompile v1.0.1\n  [ed01d8cd] Sobol v1.5.0\n  [b85f4697] SoftGlobalScope v1.1.0\n  [a2af1166] SortingAlgorithms v1.0.1\n  [47a9eef4] SparseDiffTools v1.26.2\n  [276daf66] SpecialFunctions v2.1.7\n  [171d559e] SplittablesBase v0.1.14\n  [860ef19b] StableRNGs v1.0.0\n  [aedffcd0] Static v0.7.6\n  [90137ffa] StaticArrays v1.5.6\n  [1e83bf80] StaticArraysCore v1.3.0\n  [82ae8749] StatsAPI v1.5.0\n  [2913bbd2] StatsBase v0.33.21\n  [4c63d2b9] StatsFuns v1.0.1\n  [9672c7b4] SteadyStateDiffEq v1.9.0\n  [789caeaf] StochasticDiffEq v6.53.0\n  [7792a7ef] StrideArraysCore v0.3.15\n  [69024149] StringEncodings v0.3.5\n  [09ab397b] StructArrays v0.6.12\n  [53d494c1] StructIO v0.3.0\n  [c3572dad] Sundials v4.10.1\n  [d1185830] SymbolicUtils v0.19.11\n  [0c5d862f] Symbolics v4.10.4\n  [3783bdb8] TableTraits v1.0.1\n  [bd369af6] Tables v1.7.0\n  [62fd8b95] TensorCore v0.1.1\n⌅ [8ea1fca8] TermInterface v0.2.3\n  [5d786b92] TerminalLoggers v0.1.6\n  [8290d209] ThreadingUtilities v0.5.0\n  [ac1d9e8a] ThreadsX v0.1.10\n  [a759f4b9] TimerOutputs v0.5.21\n  [0796e94c] Tokenize v0.5.24\n  [9f7883ad] Tracker v0.2.21\n  [3bb67fe8] TranscodingStreams v0.9.9\n  [28d57a85] Transducers v0.4.73\n  [a2a6695c] TreeViews v0.3.0\n  [d5829a12] TriangularSolve v0.1.13\n  [410a4b4d] Tricks v0.1.6\n  [5c2747f8] URIs v1.4.0\n  [3a884ed6] UnPack v1.0.2\n  [d9a01c3f] Underscores v3.0.0\n  [1cfade01] UnicodeFun v0.4.1\n  [1986cc42] Unitful v1.11.0\n  [41fe7b60] Unzip v0.2.0\n  [3d5dd08c] VectorizationBase v0.21.47\n  [81def892] VersionParsing v1.3.0\n  [19fa3120] VertexSafeGraphs v0.2.0\n⌃ [44d3d7a6] Weave v0.10.9\n  [ddb6d928] YAML v0.4.7\n  [c2297ded] ZMQ v1.2.1\n  [e88e6eb3] Zygote v0.6.47\n  [700de1a5] ZygoteRules v0.2.2\n  [6e34b625] Bzip2_jll v1.0.8+0\n  [83423d85] Cairo_jll v1.16.1+1\n  [3bed1096] Cuba_jll v4.2.2+1\n  [7bc98958] Cubature_jll v1.0.5+0\n  [5ae413db] EarCut_jll v2.2.3+0\n⌅ [7cc45869] Enzyme_jll v0.0.33+0\n  [2e619515] Expat_jll v2.4.8+0\n  [b22a6f82] FFMPEG_jll v4.4.2+0\n  [a3f928ae] Fontconfig_jll v2.13.93+0\n  [d7e528f0] FreeType2_jll v2.10.4+0\n  [559328eb] FriBidi_jll v1.0.10+0\n  [0656b61e] GLFW_jll v3.3.8+0\n  [d2c73de3] GR_jll v0.66.2+0\n  [78b55507] Gettext_jll v0.21.0+0\n  [7746bdde] Glib_jll v2.68.3+2\n  [3b182d85] Graphite2_jll v1.3.14+0\n  [2e76f6c2] HarfBuzz_jll v2.8.1+1\n  [aacddb02] JpegTurbo_jll v2.1.2+0\n  [c1c5ebd0] LAME_jll v3.100.1+0\n  [88015f11] LERC_jll v3.0.0+1\n  [dad2f222] LLVMExtra_jll v0.0.16+0\n  [dd4b983a] LZO_jll v2.10.1+0\n  [e9f186c6] Libffi_jll v3.2.2+1\n  [d4300ac3] Libgcrypt_jll v1.8.7+0\n  [7e76a0d4] Libglvnd_jll v1.3.0+3\n  [7add5ba3] Libgpg_error_jll v1.42.0+0\n  [94ce4f54] Libiconv_jll v1.16.1+1\n  [4b2f31a3] Libmount_jll v2.35.0+0\n  [89763e89] Libtiff_jll v4.4.0+0\n  [38a345b3] Libuuid_jll v2.36.0+0\n  [e7412a2a] Ogg_jll v1.3.5+1\n  [458c3c95] OpenSSL_jll v1.1.17+0\n  [efe28fd5] OpenSpecFun_jll v0.5.5+0\n  [91d4177d] Opus_jll v1.3.2+0\n  [2f80f16e] PCRE_jll v8.44.0+0\n  [30392449] Pixman_jll v0.40.1+0\n  [ea2cea3b] Qt5Base_jll v5.15.3+1\n  [f50d1b31] Rmath_jll v0.3.0+0\n  [fb77eaff] Sundials_jll v5.2.1+0\n  [a2964d1f] Wayland_jll v1.19.0+0\n  [2381bf8a] Wayland_protocols_jll v1.25.0+0\n  [02c8fc9c] XML2_jll v2.9.14+0\n  [aed1982a] XSLT_jll v1.1.34+0\n  [4f6342f7] Xorg_libX11_jll v1.6.9+4\n  [0c0b7dd1] Xorg_libXau_jll v1.0.9+4\n  [935fb764] Xorg_libXcursor_jll v1.2.0+4\n  [a3789734] Xorg_libXdmcp_jll v1.1.3+4\n  [1082639a] Xorg_libXext_jll v1.3.4+4\n  [d091e8ba] Xorg_libXfixes_jll v5.0.3+4\n  [a51aa0fd] Xorg_libXi_jll v1.7.10+4\n  [d1454406] Xorg_libXinerama_jll v1.1.4+4\n  [ec84b674] Xorg_libXrandr_jll v1.5.2+4\n  [ea2f1a96] Xorg_libXrender_jll v0.9.10+4\n  [14d82f49] Xorg_libpthread_stubs_jll v0.1.0+3\n  [c7cfdc94] Xorg_libxcb_jll v1.13.0+3\n  [cc61e674] Xorg_libxkbfile_jll v1.1.0+4\n  [12413925] Xorg_xcb_util_image_jll v0.4.0+1\n  [2def613f] Xorg_xcb_util_jll v0.4.0+1\n  [975044d2] Xorg_xcb_util_keysyms_jll v0.4.0+1\n  [0d47668e] Xorg_xcb_util_renderutil_jll v0.3.9+1\n  [c22f9ab0] Xorg_xcb_util_wm_jll v0.4.1+1\n  [35661453] Xorg_xkbcomp_jll v1.4.2+4\n  [33bec58e] Xorg_xkeyboard_config_jll v2.27.0+4\n  [c5fb5394] Xorg_xtrans_jll v1.4.0+3\n  [8f1865be] ZeroMQ_jll v4.3.4+0\n  [3161d3a3] Zstd_jll v1.5.2+0\n  [a4ae2306] libaom_jll v3.4.0+0\n  [0ac62f75] libass_jll v0.15.1+0\n  [f638f0a6] libfdk_aac_jll v2.0.2+0\n  [b53b4c65] libpng_jll v1.6.38+0\n  [a9144af2] libsodium_jll v1.0.20+0\n  [f27f6e37] libvorbis_jll v1.3.7+1\n  [1270edf5] x264_jll v2021.5.5+0\n  [dfaa095f] x265_jll v3.5.0+0\n  [d8fb68d0] xkbcommon_jll v1.4.1+0\n  [0dad84c5] ArgTools v1.1.1\n  [56f22d72] Artifacts\n  [2a0f44e3] Base64\n  [ade2ca70] Dates\n  [8bb1440f] DelimitedFiles\n  [8ba89e20] Distributed\n  [f43a241f] Downloads v1.6.0\n  [7b1f6079] FileWatching\n  [9fa8497b] Future\n  [b77e0a4c] InteractiveUtils\n  [4af54fe1] LazyArtifacts\n  [b27032c2] LibCURL v0.6.3\n  [76f85450] LibGit2\n  [8f399da3] Libdl\n  [37e2e46d] LinearAlgebra\n  [56ddb016] Logging\n  [d6f4376e] Markdown\n  [a63ad114] Mmap\n  [ca575930] NetworkOptions v1.2.0\n  [44cfe95a] Pkg v1.8.0\n  [de0858da] Printf\n  [3fa0cd96] REPL\n  [9a3f8284] Random\n  [ea8e919c] SHA v0.7.0\n  [9e88b42a] Serialization\n  [1a1011a3] SharedArrays\n  [6462fe0b] Sockets\n  [2f01184e] SparseArrays\n  [10745b16] Statistics\n  [4607b0f0] SuiteSparse\n  [fa267f1f] TOML v1.0.0\n  [a4e569a6] Tar v1.10.0\n  [8dfed614] Test\n  [cf7118a7] UUIDs\n  [4ec0a83e] Unicode\n  [e66e0078] CompilerSupportLibraries_jll v0.5.2+0\n  [deac9b47] LibCURL_jll v7.84.0+0\n  [29816b5a] LibSSH2_jll v1.10.2+0\n  [c8ffd9c3] MbedTLS_jll v2.28.0+0\n  [14a3606d] MozillaCACerts_jll v2022.2.1\n  [4536629a] OpenBLAS_jll v0.3.20+0\n  [05823500] OpenLibm_jll v0.8.1+0\n  [bea87d4a] SuiteSparse_jll v5.10.1+0\n  [83775a58] Zlib_jll v1.2.12+3\n  [8e850b90] libblastrampoline_jll v5.1.1+0\n  [8e850ede] nghttp2_jll v1.48.0+0\n  [3f19e933] p7zip_jll v17.4.0+0\nInfo Packages marked with ⌃ and ⌅ have new versions available, but those with ⌅ cannot be upgraded. To see why use `status --outdated -m`","category":"page"},{"location":"advanced/02-diffusion_implicit_heat_equation/#Solving-the-heat-equation-with-diffusion-implicit-time-stepping","page":"Solving the heat equation with diffusion-implicit time-stepping","title":"Solving the heat equation with diffusion-implicit time-stepping","text":"","category":"section"},{"location":"advanced/02-diffusion_implicit_heat_equation/","page":"Solving the heat equation with diffusion-implicit time-stepping","title":"Solving the heat equation with diffusion-implicit time-stepping","text":"In this tutorial, we'll be solving the heat equation:","category":"page"},{"location":"advanced/02-diffusion_implicit_heat_equation/","page":"Solving the heat equation with diffusion-implicit time-stepping","title":"Solving the heat equation with diffusion-implicit time-stepping","text":"_t T = α ²(T) + β sin(γ z)","category":"page"},{"location":"advanced/02-diffusion_implicit_heat_equation/","page":"Solving the heat equation with diffusion-implicit time-stepping","title":"Solving the heat equation with diffusion-implicit time-stepping","text":"with boundary conditions: T(z=a) = T_bottom T(z=b) = T_top. We'll solve these equations numerically using Finite Difference Method on cell faces. The same exercise could easily be done on cell centers.","category":"page"},{"location":"advanced/02-diffusion_implicit_heat_equation/#Code-loading-and-parameters","page":"Solving the heat equation with diffusion-implicit time-stepping","title":"Code loading and parameters","text":"","category":"section"},{"location":"advanced/02-diffusion_implicit_heat_equation/","page":"Solving the heat equation with diffusion-implicit time-stepping","title":"Solving the heat equation with diffusion-implicit time-stepping","text":"First, we'll use / import some packages:","category":"page"},{"location":"advanced/02-diffusion_implicit_heat_equation/","page":"Solving the heat equation with diffusion-implicit time-stepping","title":"Solving the heat equation with diffusion-implicit time-stepping","text":"import Plots\nusing LinearAlgebra\nusing DiffEqBase\nusing OrdinaryDiffEq: SplitODEProblem, solve, IMEXEuler\nimport SciMLBase","category":"page"},{"location":"advanced/02-diffusion_implicit_heat_equation/","page":"Solving the heat equation with diffusion-implicit time-stepping","title":"Solving the heat equation with diffusion-implicit time-stepping","text":"Next, we'll define some global problem parameters:","category":"page"},{"location":"advanced/02-diffusion_implicit_heat_equation/","page":"Solving the heat equation with diffusion-implicit time-stepping","title":"Solving the heat equation with diffusion-implicit time-stepping","text":"a,b, n = 0, 1, 10               # zmin, zmax, number of cells\nn̂_min, n̂_max = -1, 1            # Outward facing unit vectors\nα = 100;                        # thermal diffusivity, larger means more stiff\nβ, γ = 10000, π;                # source term coefficients\nΔt = 1000;                      # timestep size\nN_t = 10;                       # number of timesteps to take\nFT = Float64;                   # float type\nΔz = FT(b-a)/FT(n)\nΔz² = Δz^2;\n∇²_op = [1/Δz², -2/Δz², 1/Δz²]; # interior Laplacian operator\n∇T_bottom = 10;                 # Temperature gradient at the top\nT_top = 1;                      # Temperature at the bottom\nS(z) = β*sin(γ*z)               # source term, (sin for easy integration)\nzf = range(a, b, length=n+1);   # coordinates on cell faces","category":"page"},{"location":"advanced/02-diffusion_implicit_heat_equation/#Derivation-of-analytic-solution","page":"Solving the heat equation with diffusion-implicit time-stepping","title":"Derivation of analytic solution","text":"","category":"section"},{"location":"advanced/02-diffusion_implicit_heat_equation/","page":"Solving the heat equation with diffusion-implicit time-stepping","title":"Solving the heat equation with diffusion-implicit time-stepping","text":"Here, we'll derive the analytic solution:","category":"page"},{"location":"advanced/02-diffusion_implicit_heat_equation/","page":"Solving the heat equation with diffusion-implicit time-stepping","title":"Solving the heat equation with diffusion-implicit time-stepping","text":"frac²T²z = -fracS(z)α = -fracβ sin(γ z)α \nfracTz = fracβ cos(γ z)γ α+c_1 \nT(z) = fracβ sin(γ z)γ^2 α+c_1 z+c_2 qquad text(generic solution)","category":"page"},{"location":"advanced/02-diffusion_implicit_heat_equation/","page":"Solving the heat equation with diffusion-implicit time-stepping","title":"Solving the heat equation with diffusion-implicit time-stepping","text":"Apply bottom boundary condition:","category":"page"},{"location":"advanced/02-diffusion_implicit_heat_equation/","page":"Solving the heat equation with diffusion-implicit time-stepping","title":"Solving the heat equation with diffusion-implicit time-stepping","text":"fracTz(a) = fracβ cos(γ a)γ α+c_1 = T_bottom \nc_1 = T_bottom-fracβ cos(γ a)γ α","category":"page"},{"location":"advanced/02-diffusion_implicit_heat_equation/","page":"Solving the heat equation with diffusion-implicit time-stepping","title":"Solving the heat equation with diffusion-implicit time-stepping","text":"Apply top boundary condition:","category":"page"},{"location":"advanced/02-diffusion_implicit_heat_equation/","page":"Solving the heat equation with diffusion-implicit time-stepping","title":"Solving the heat equation with diffusion-implicit time-stepping","text":"T(b) = fracβ sin(γ b)γ^2 α+c_1 b+c_2 = T_top \nc_2 = T_top-left(fracβ sin(γ b)γ^2 α+c_1 bright)","category":"page"},{"location":"advanced/02-diffusion_implicit_heat_equation/","page":"Solving the heat equation with diffusion-implicit time-stepping","title":"Solving the heat equation with diffusion-implicit time-stepping","text":"And now let's define this in a julia function:","category":"page"},{"location":"advanced/02-diffusion_implicit_heat_equation/","page":"Solving the heat equation with diffusion-implicit time-stepping","title":"Solving the heat equation with diffusion-implicit time-stepping","text":"function T_analytic(z) # Analytic steady state solution\n    c1 = ∇T_bottom-β*cos(γ*a)/(γ*α)\n    c2 = T_top-(β*sin(γ*b)/(γ^2*α)+c1*b)\n    return β*sin(γ*z)/(γ^2*α)+c1*z+c2\nend","category":"page"},{"location":"advanced/02-diffusion_implicit_heat_equation/","page":"Solving the heat equation with diffusion-implicit time-stepping","title":"Solving the heat equation with diffusion-implicit time-stepping","text":"T_analytic (generic function with 1 method)","category":"page"},{"location":"advanced/02-diffusion_implicit_heat_equation/#Derive-the-temporal-discretization","page":"Solving the heat equation with diffusion-implicit time-stepping","title":"Derive the temporal discretization","text":"","category":"section"},{"location":"advanced/02-diffusion_implicit_heat_equation/","page":"Solving the heat equation with diffusion-implicit time-stepping","title":"Solving the heat equation with diffusion-implicit time-stepping","text":"Here, we'll derivation the matrix form of the temporal discretization we wish to use (diffusion-implicit and explicit Euler):","category":"page"},{"location":"advanced/02-diffusion_implicit_heat_equation/","page":"Solving the heat equation with diffusion-implicit time-stepping","title":"Solving the heat equation with diffusion-implicit time-stepping","text":"_t T = α ²T + S \n(T^n+1-T^n) = Δt (α  ²T^n+1 + S) \n(T^n+1 - Δt α ²T^n+1) = T^n + Δt S \n(I - Δt α ²) T^n+1 = T^n + Δt S","category":"page"},{"location":"advanced/02-diffusion_implicit_heat_equation/","page":"Solving the heat equation with diffusion-implicit time-stepping","title":"Solving the heat equation with diffusion-implicit time-stepping","text":"Note that, since the ² reaches to boundary points, we'll need to modify the stencils to account for boundary conditions.","category":"page"},{"location":"advanced/02-diffusion_implicit_heat_equation/#Derive-the-finite-difference-stencil","page":"Solving the heat equation with diffusion-implicit time-stepping","title":"Derive the finite difference stencil","text":"","category":"section"},{"location":"advanced/02-diffusion_implicit_heat_equation/","page":"Solving the heat equation with diffusion-implicit time-stepping","title":"Solving the heat equation with diffusion-implicit time-stepping","text":"For the interior domain, a central and second-order finite difference stencil is simply:","category":"page"},{"location":"advanced/02-diffusion_implicit_heat_equation/","page":"Solving the heat equation with diffusion-implicit time-stepping","title":"Solving the heat equation with diffusion-implicit time-stepping","text":"²f = fracf_i-1 -2f_i + f_i+1Δz² qquad textor \n² = leftfrac1Δz² frac-2Δz² frac1Δz²right ","category":"page"},{"location":"advanced/02-diffusion_implicit_heat_equation/","page":"Solving the heat equation with diffusion-implicit time-stepping","title":"Solving the heat equation with diffusion-implicit time-stepping","text":"At the boundaries, we need to modify the stencil to account for Dirichlet and Neumann BCs. Using the following index denotion:","category":"page"},{"location":"advanced/02-diffusion_implicit_heat_equation/","page":"Solving the heat equation with diffusion-implicit time-stepping","title":"Solving the heat equation with diffusion-implicit time-stepping","text":"i first interior index\nb boundary index\ng ghost index","category":"page"},{"location":"advanced/02-diffusion_implicit_heat_equation/","page":"Solving the heat equation with diffusion-implicit time-stepping","title":"Solving the heat equation with diffusion-implicit time-stepping","text":"the Dirichlet boundary stencil & source:","category":"page"},{"location":"advanced/02-diffusion_implicit_heat_equation/","page":"Solving the heat equation with diffusion-implicit time-stepping","title":"Solving the heat equation with diffusion-implicit time-stepping","text":"_t T = α fracTi-1+Tb-2 TiΔz² + S \n_t T = α fracTi-1-2 TiΔz² + S + α fracTbΔz²","category":"page"},{"location":"advanced/02-diffusion_implicit_heat_equation/","page":"Solving the heat equation with diffusion-implicit time-stepping","title":"Solving the heat equation with diffusion-implicit time-stepping","text":"and Neumann boundary stencil & source:","category":"page"},{"location":"advanced/02-diffusion_implicit_heat_equation/","page":"Solving the heat equation with diffusion-implicit time-stepping","title":"Solving the heat equation with diffusion-implicit time-stepping","text":"T_bottom n = fracTg - Ti2Δz qquad    n = -11  z_minz_max \nTi + 2 Δz T_bottom n = Tg \n_t T = α fracfrac(Ti + 2 Δz T_bottom n) - TbΔz - fracTb - TiΔzΔz + S \n_t T = α fracfracTi - TbΔz - fracTb - TiΔzΔz + S + α 2 Δz fracT_bottomΔz² \n_t T = α frac2 Ti - 2 TbΔz² + S + 2α fracT_bottom nΔz","category":"page"},{"location":"advanced/02-diffusion_implicit_heat_equation/#Define-the-discrete-diffusion-operator","page":"Solving the heat equation with diffusion-implicit time-stepping","title":"Define the discrete diffusion operator","text":"","category":"section"},{"location":"advanced/02-diffusion_implicit_heat_equation/","page":"Solving the heat equation with diffusion-implicit time-stepping","title":"Solving the heat equation with diffusion-implicit time-stepping","text":"# Initialize interior and boundary stencils:\n∇² = Tridiagonal(\n    ones(FT, n) .* ∇²_op[1],\n    ones(FT, n+1)   .* ∇²_op[2],\n    ones(FT, n) .* ∇²_op[3]\n);\n\n# Modify boundary stencil to account for BCs\n\n∇².d[1] = -2/Δz²\n∇².du[1] = +2/Δz²\n\n# Modify boundary stencil to account for BCs\n∇².du[n] = 0  # modified stencil\n∇².d[n+1] = 0 # to ensure `∂_t T = 0` at `z=zmax`\n∇².dl[n] = 0  # to ensure `∂_t T = 0` at `z=zmax`\nD = α .* ∇²","category":"page"},{"location":"advanced/02-diffusion_implicit_heat_equation/","page":"Solving the heat equation with diffusion-implicit time-stepping","title":"Solving the heat equation with diffusion-implicit time-stepping","text":"11×11 LinearAlgebra.Tridiagonal{Float64, Vector{Float64}}:\n -20000.0   20000.0        ⋅         ⋅   …        ⋅         ⋅         ⋅    \n⋅ \n  10000.0  -20000.0   10000.0        ⋅            ⋅         ⋅         ⋅    \n⋅ \n       ⋅    10000.0  -20000.0   10000.0           ⋅         ⋅         ⋅    \n⋅ \n       ⋅         ⋅    10000.0  -20000.0           ⋅         ⋅         ⋅    \n⋅ \n       ⋅         ⋅         ⋅    10000.0           ⋅         ⋅         ⋅    \n⋅ \n       ⋅         ⋅         ⋅         ⋅   …        ⋅         ⋅         ⋅    \n⋅ \n       ⋅         ⋅         ⋅         ⋅       10000.0        ⋅         ⋅    \n⋅ \n       ⋅         ⋅         ⋅         ⋅      -20000.0   10000.0        ⋅    \n⋅ \n       ⋅         ⋅         ⋅         ⋅       10000.0  -20000.0   10000.0   \n⋅ \n       ⋅         ⋅         ⋅         ⋅            ⋅    10000.0  -20000.0  0\n.0\n       ⋅         ⋅         ⋅         ⋅   …        ⋅         ⋅        0.0  0\n.0","category":"page"},{"location":"advanced/02-diffusion_implicit_heat_equation/#Define-boundary-source","page":"Solving the heat equation with diffusion-implicit time-stepping","title":"Define boundary source","text":"","category":"section"},{"location":"advanced/02-diffusion_implicit_heat_equation/","page":"Solving the heat equation with diffusion-implicit time-stepping","title":"Solving the heat equation with diffusion-implicit time-stepping","text":"Here, we'll compute the boundary source left(fracα TbΔz²right)","category":"page"},{"location":"advanced/02-diffusion_implicit_heat_equation/","page":"Solving the heat equation with diffusion-implicit time-stepping","title":"Solving the heat equation with diffusion-implicit time-stepping","text":"AT_b = zeros(FT, n+1);\nAT_b[1] = α*2/Δz*∇T_bottom*n̂_min;\nAT_b[end-1] = α*T_top/Δz²;","category":"page"},{"location":"advanced/02-diffusion_implicit_heat_equation/#Set-initial-condition","page":"Solving the heat equation with diffusion-implicit time-stepping","title":"Set initial condition","text":"","category":"section"},{"location":"advanced/02-diffusion_implicit_heat_equation/","page":"Solving the heat equation with diffusion-implicit time-stepping","title":"Solving the heat equation with diffusion-implicit time-stepping","text":"Let's just initialize the solution to 1, and also set the top boundary condition:","category":"page"},{"location":"advanced/02-diffusion_implicit_heat_equation/","page":"Solving the heat equation with diffusion-implicit time-stepping","title":"Solving the heat equation with diffusion-implicit time-stepping","text":"T = zeros(FT, n+1);\nT .= 1;\nT[n+1] = T_top; # set top BC","category":"page"},{"location":"advanced/02-diffusion_implicit_heat_equation/#Define-right-hand-side-sources","page":"Solving the heat equation with diffusion-implicit time-stepping","title":"Define right-hand side sources","text":"","category":"section"},{"location":"advanced/02-diffusion_implicit_heat_equation/","page":"Solving the heat equation with diffusion-implicit time-stepping","title":"Solving the heat equation with diffusion-implicit time-stepping","text":"Here, we define the right-hand side (RHS) sources:","category":"page"},{"location":"advanced/02-diffusion_implicit_heat_equation/","page":"Solving the heat equation with diffusion-implicit time-stepping","title":"Solving the heat equation with diffusion-implicit time-stepping","text":"function rhs!(dT, T, params, t)\n    n = params.n\n    i = 1:n # interior domain\n    dT[i] .= S.(zf[i]) .+ AT_b[i]\n    return dT\nend;","category":"page"},{"location":"advanced/02-diffusion_implicit_heat_equation/","page":"Solving the heat equation with diffusion-implicit time-stepping","title":"Solving the heat equation with diffusion-implicit time-stepping","text":"Next, we'll pacakge up parameters needed in the RHS function, define the ODE problem, and solve.","category":"page"},{"location":"advanced/02-diffusion_implicit_heat_equation/","page":"Solving the heat equation with diffusion-implicit time-stepping","title":"Solving the heat equation with diffusion-implicit time-stepping","text":"params = (;n)\n\ntspan = (FT(0), N_t*FT(Δt))\n\nprob = SplitODEProblem(\n    SciMLBase.DiffEqArrayOperator(\n        D,\n    ),\n    rhs!,\n    T,\n    tspan,\n    params\n)\nalg = IMEXEuler(linsolve=LinSolveFactorize(lu!))\nprintln(\"Solving...\")\nsol = solve(\n    prob,\n    alg,\n    dt = Δt,\n    saveat = range(FT(0), N_t*FT(Δt), length=5),\n    progress = true,\n    progress_message = (dt, u, p, t) -> t,\n);","category":"page"},{"location":"advanced/02-diffusion_implicit_heat_equation/","page":"Solving the heat equation with diffusion-implicit time-stepping","title":"Solving the heat equation with diffusion-implicit time-stepping","text":"Solving...","category":"page"},{"location":"advanced/02-diffusion_implicit_heat_equation/#Visualizing-results","page":"Solving the heat equation with diffusion-implicit time-stepping","title":"Visualizing results","text":"","category":"section"},{"location":"advanced/02-diffusion_implicit_heat_equation/","page":"Solving the heat equation with diffusion-implicit time-stepping","title":"Solving the heat equation with diffusion-implicit time-stepping","text":"Now, let's visualize the results of the solution and error:","category":"page"},{"location":"advanced/02-diffusion_implicit_heat_equation/","page":"Solving the heat equation with diffusion-implicit time-stepping","title":"Solving the heat equation with diffusion-implicit time-stepping","text":"T_end = sol.u[end]\n\np1 = Plots.plot(zf, T_analytic.(zf), label=\"analytic\", markershape=:circle, markersize=6)\np1 = Plots.plot!(p1, zf, T_end, label=\"numerical\", markershape=:diamond)\np1 = Plots.plot!(p1, title=\"T ∈ cell faces\")\n\np2 = Plots.plot(zf, abs.(T_end .- T_analytic.(zf)), label=\"error\", markershape=:circle, markersize=6)\np2 = Plots.plot!(p2, title=\"T ∈ cell faces\")\n\nPlots.plot(p1, p2)","category":"page"},{"location":"advanced/02-diffusion_implicit_heat_equation/","page":"Solving the heat equation with diffusion-implicit time-stepping","title":"Solving the heat equation with diffusion-implicit time-stepping","text":"(Image: )","category":"page"},{"location":"perturbation/01-perturbation_algebraic/#Mixed-Symbolic/Numerical-Methods-for-Perturbation-Theory-Algebraic-Equations","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","text":"","category":"section"},{"location":"perturbation/01-perturbation_algebraic/#Background","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","title":"Background","text":"","category":"section"},{"location":"perturbation/01-perturbation_algebraic/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","text":"Symbolics.jl is a fast and modern Computer Algebra System (CAS) written in the Julia Programming Language. It is an integral part of the SciML ecosystem of differential equation solvers and scientific machine learning packages. While Symbolics.jl is primarily designed for modern scientific computing (e.g., auto-differentiation, machine learning), it is a powerful CAS and can also be useful for classic scientific computing. One such application is using the perturbation theory to solve algebraic and differential equations.","category":"page"},{"location":"perturbation/01-perturbation_algebraic/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","text":"Perturbation methods are a collection of techniques to solve intractable problems that generally don't have a closed solution but depend on a tunable parameter and have closed or easy solutions for some values of the parameter. The main idea is to assume a solution as a power series in the tunable parameter (say ϵ), such that ϵ = 0 corresponds to an easy solution.","category":"page"},{"location":"perturbation/01-perturbation_algebraic/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","text":"We will discuss the general steps of the perturbation methods to solve algebraic (this tutorial) and differential equations (Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations).","category":"page"},{"location":"perturbation/01-perturbation_algebraic/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","text":"The hallmark of the perturbation method is the generation of long and convoluted intermediate equations, which are subjected to algorithmic and mechanical manipulations. Therefore, these problems are well suited for CAS. In fact, CAS softwares have been used to help with the perturbation calculations since the early 1970s.","category":"page"},{"location":"perturbation/01-perturbation_algebraic/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","text":"In this tutorial our goal is to show how to use a mix of symbolic manipulations (Symbolics.jl) and numerical methods (DifferentialEquations.jl) to solve simple perturbation problems.","category":"page"},{"location":"perturbation/01-perturbation_algebraic/#Solving-the-Quintic","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","title":"Solving the Quintic","text":"","category":"section"},{"location":"perturbation/01-perturbation_algebraic/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","text":"We start with the \"hello world!\" analog of the perturbation problems, solving the quintic (fifth-order) equations. We want to find a real valued x such that x^5 + x = 1. According to the Abel's theorem, a general quintic equation does not have a closed form solution. Of course, we can easily solve this equation numerically; for example, by using the Newton's method. We use the following implementation of the Newton's method:","category":"page"},{"location":"perturbation/01-perturbation_algebraic/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","text":"using Symbolics, SymbolicUtils\n\nfunction solve_newton(f, x, x₀; abstol=1e-8, maxiter=50)\n    xₙ = Float64(x₀)\n    fₙ₊₁ = x - f / Symbolics.derivative(f, x)\n\n    for i = 1:maxiter\n        xₙ₊₁ = substitute(fₙ₊₁, Dict(x => xₙ))\n        if abs(xₙ₊₁ - xₙ) < abstol\n            return xₙ₊₁\n        else\n            xₙ = xₙ₊₁\n        end\n    end\n    return xₙ₊₁\nend","category":"page"},{"location":"perturbation/01-perturbation_algebraic/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","text":"solve_newton (generic function with 1 method)","category":"page"},{"location":"perturbation/01-perturbation_algebraic/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","text":"In this code, Symbolics.derivative(eq, x) does exactly what it names implies: it calculates the symbolic derivative of eq (a Symbolics.jl expression) with respect to x (a Symbolics.jl variable). We use Symbolics.substitute(eq, D) to evaluate the update formula by substituting variables or sub-expressions (defined in a dictionary D) in eq. It should be noted that substitute is the workhorse of our code and will be used multiple times in the rest of these tutorials. solve_newton is written with simplicity and clarity, and not performance, in mind but suffices for our purpose.","category":"page"},{"location":"perturbation/01-perturbation_algebraic/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","text":"Let's go back to our quintic. We can define a Symbolics variable as @variables x and then solve the equation solve_newton(x^5 + x - 1, x, 1.0) (here, x₀ = 0 is our first guess). The answer is 0.7549. Now, let's see how we can solve the same problem using the perturbation methods.","category":"page"},{"location":"perturbation/01-perturbation_algebraic/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","text":"We introduce a tuning parameter epsilon into our equation: x^5 + epsilon x = 1. If epsilon = 1, we get our original problem. For epsilon = 0, the problem transforms to an easy one: x^5 = 1 which has an exact real solution x = 1 (and four complex solutions which we ignore here). We expand x as a power series on epsilon:","category":"page"},{"location":"perturbation/01-perturbation_algebraic/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","text":"$","category":"page"},{"location":"perturbation/01-perturbation_algebraic/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","text":"x(\\epsilon) = a0 + a1 \\epsilon + a_2 \\epsilon^2 + O(\\epsilon^3)   \\,. $","category":"page"},{"location":"perturbation/01-perturbation_algebraic/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","text":"a_0","category":"page"},{"location":"perturbation/01-perturbation_algebraic/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","text":"is the solution of the easy equation, therefore a_0 = 1. Substituting into the original problem,","category":"page"},{"location":"perturbation/01-perturbation_algebraic/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","text":"$","category":"page"},{"location":"perturbation/01-perturbation_algebraic/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","text":"(a0 + a1 \\epsilon + a2 \\epsilon^2)^5 + \\epsilon (a0 + a1 \\epsilon + a2 \\epsilon^2) - 1 = 0   \\,. $","category":"page"},{"location":"perturbation/01-perturbation_algebraic/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","text":"Expanding the equations, we get $   \\epsilon (1 + 5 a1) + \\epsilon^2 (a1 + 5 a2 + 10 a12) + 𝑂(\\epsilon^3) = 0   \\,. $","category":"page"},{"location":"perturbation/01-perturbation_algebraic/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","text":"This equation should hold for each power of epsilon. Therefore,","category":"page"},{"location":"perturbation/01-perturbation_algebraic/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","text":"$","category":"page"},{"location":"perturbation/01-perturbation_algebraic/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","text":"1 + 5 a_1 = 0   \\,, $","category":"page"},{"location":"perturbation/01-perturbation_algebraic/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","text":"and","category":"page"},{"location":"perturbation/01-perturbation_algebraic/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","text":"$","category":"page"},{"location":"perturbation/01-perturbation_algebraic/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","text":"a1 + 5 a2 + 10 a_1^2 = 0   \\,. $","category":"page"},{"location":"perturbation/01-perturbation_algebraic/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","text":"This system of equations does not initially seem to be linear because of the presence of terms like 10 a_1^2, but upon closer inspection is found to be in fact linear (this is a feature of the perturbation methods). In addition, the system is in a triangular form, meaning the first equation depends only on a_1, the second one on a_1 and a_2, such that we can replace the result of a_1 from the first one into the second equation and remove the non-linear term. We solve the first equation to get a_1 = -frac15. Substituting in the second one and solve for a_2:","category":"page"},{"location":"perturbation/01-perturbation_algebraic/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","text":"$","category":"page"},{"location":"perturbation/01-perturbation_algebraic/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","text":"a_2 = \\frac{(-\\frac{1}{5} + 10(-(\\frac{1}{5})²)}{5}  = -\\frac{1}{25}   \\,. $","category":"page"},{"location":"perturbation/01-perturbation_algebraic/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","text":"Finally,","category":"page"},{"location":"perturbation/01-perturbation_algebraic/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","text":"$","category":"page"},{"location":"perturbation/01-perturbation_algebraic/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","text":"x(\\epsilon) = 1 - \\frac{\\epsilon}{5} - \\frac{\\epsilon^2}{25} + O(\\epsilon^3)   \\,. $","category":"page"},{"location":"perturbation/01-perturbation_algebraic/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","text":"Solving the original problem, x(1) = 076, compared to 0.7548 calculated numerically. We can improve the accuracy by including more terms in the expansion of x. However, the calculations, while straightforward, become messy and intractable to do manually very quickly. This is why a CAS is very helpful to solve perturbation problems.","category":"page"},{"location":"perturbation/01-perturbation_algebraic/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","text":"Now, let's see how we can do these calculations in Julia. Let n be the order of the expansion. We start by defining the symbolic variables:","category":"page"},{"location":"perturbation/01-perturbation_algebraic/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","text":"n = 2\n@variables ϵ a[1:n]","category":"page"},{"location":"perturbation/01-perturbation_algebraic/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","text":"2-element Vector{Any}:\n ϵ\n  Symbolics.Num[a₁, a₂]","category":"page"},{"location":"perturbation/01-perturbation_algebraic/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","text":"Then, we define","category":"page"},{"location":"perturbation/01-perturbation_algebraic/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","text":"x = 1 + a[1]*ϵ + a[2]*ϵ^2","category":"page"},{"location":"perturbation/01-perturbation_algebraic/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","text":"1 + a₁*ϵ + a₂*(ϵ^2)","category":"page"},{"location":"perturbation/01-perturbation_algebraic/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","text":"The next step is to substitute x in the problem equation","category":"page"},{"location":"perturbation/01-perturbation_algebraic/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","text":"  eq = x^5 + ϵ*x - 1","category":"page"},{"location":"perturbation/01-perturbation_algebraic/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","text":"ϵ*(1 + a₁*ϵ + a₂*(ϵ^2)) + (1 + a₁*ϵ + a₂*(ϵ^2))^5 - 1","category":"page"},{"location":"perturbation/01-perturbation_algebraic/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","text":"The expanded form of eq is","category":"page"},{"location":"perturbation/01-perturbation_algebraic/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","text":"expand(eq)","category":"page"},{"location":"perturbation/01-perturbation_algebraic/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","text":"ϵ + a₁*(ϵ^2) + a₂*(ϵ^3) + (a₁^5)*(ϵ^5) + (a₂^5)*(ϵ^10) + 5a₁*ϵ + 5a₂*(ϵ^2) \n+ 10(a₁^2)*(ϵ^2) + 10(a₁^3)*(ϵ^3) + 5(a₁^4)*(ϵ^4) + 10(a₂^2)*(ϵ^4) + 10(a₂^\n3)*(ϵ^6) + 5(a₂^4)*(ϵ^8) + 20a₁*a₂*(ϵ^3) + 30a₁*(a₂^2)*(ϵ^5) + 20a₁*(a₂^3)*\n(ϵ^7) + 5a₁*(a₂^4)*(ϵ^9) + 30a₂*(a₁^2)*(ϵ^4) + 20a₂*(a₁^3)*(ϵ^5) + 5a₂*(a₁^\n4)*(ϵ^6) + 30(a₁^2)*(a₂^2)*(ϵ^6) + 10(a₁^2)*(a₂^3)*(ϵ^8) + 10(a₁^3)*(a₂^2)*\n(ϵ^7)","category":"page"},{"location":"perturbation/01-perturbation_algebraic/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","text":"We need a way to get the coefficients of different powers of ϵ. Function collect_powers(eq, x, ns) returns the powers of variable x in expression eq. Argument ns is the range of the powers.","category":"page"},{"location":"perturbation/01-perturbation_algebraic/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","text":"function collect_powers(eq, x, ns; max_power=100)\n    eq = substitute(expand(eq), Dict(x^j => 0 for j=last(ns)+1:max_power))\n\n    eqs = []\n    for i in ns\n        powers = Dict(x^j => (i==j ? 1 : 0) for j=1:last(ns))\n        push!(eqs, substitute(eq, powers))\n    end\n    eqs\nend","category":"page"},{"location":"perturbation/01-perturbation_algebraic/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","text":"collect_powers (generic function with 1 method)","category":"page"},{"location":"perturbation/01-perturbation_algebraic/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","text":"To return the coefficients of ϵ and ϵ^2 in eq, we can write","category":"page"},{"location":"perturbation/01-perturbation_algebraic/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","text":"eqs = collect_powers(eq, ϵ, 1:2)","category":"page"},{"location":"perturbation/01-perturbation_algebraic/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","text":"2-element Vector{Any}:\n             1 + 5a₁\n a₁ + 5a₂ + 10(a₁^2)","category":"page"},{"location":"perturbation/01-perturbation_algebraic/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","text":"A few words on how collect_powers works, It uses substitute to find the coefficient of a given power of x by passing a Dict with all powers of x set to 0, except the target power which is set to 1. For example, the following expression returns the coefficient of ϵ^2 in eq,","category":"page"},{"location":"perturbation/01-perturbation_algebraic/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","text":"substitute(expand(eq), Dict(\n  ϵ => 0,\n  ϵ^2 => 1,\n  ϵ^3 => 0,\n  ϵ^4 => 0,\n  ϵ^5 => 0,\n  ϵ^6 => 0,\n  ϵ^7 => 0,\n  ϵ^8 => 0)\n)","category":"page"},{"location":"perturbation/01-perturbation_algebraic/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","text":"a₁ + 5a₂ + 10(a₁^2)","category":"page"},{"location":"perturbation/01-perturbation_algebraic/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","text":"Back to our problem. Having the coefficients of the powers of ϵ, we can set each equation in eqs to 0 (remember, we rearrange the problem such that eq is 0) and solve the system of linear equations to find the numerical values of the coefficients. Symbolics.jl has a function Symbolics.solve_for that can solve systems of linear equations. However, the presence of higher order terms in eqs prevents Symbolics.solve_for(eqs .~ 0, a) from workings properly. Instead, we can exploit the fact that our system is in a triangular form and start by solving eqs[1] for a₁ and then substitute this in eqs[2] and solve for a₂ (as continue the same process for higher order terms).  This cascading process is done by function solve_coef(eqs, ps):","category":"page"},{"location":"perturbation/01-perturbation_algebraic/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","text":"function solve_coef(eqs, ps)\n    vals = Dict()\n\n    for i = 1:length(ps)\n        eq = substitute(eqs[i], vals)\n        vals[ps[i]] = Symbolics.solve_for(eq ~ 0, ps[i])\n    end\n    vals\nend","category":"page"},{"location":"perturbation/01-perturbation_algebraic/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","text":"solve_coef (generic function with 1 method)","category":"page"},{"location":"perturbation/01-perturbation_algebraic/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","text":"Here, eqs is an array of expressions (assumed to be equal to 0) and ps is an array of variables. The result is a dictionary of variable => value pairs. We apply solve_coef to eqs to get the numerical values of the parameters:","category":"page"},{"location":"perturbation/01-perturbation_algebraic/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","text":"solve_coef(eqs, a)","category":"page"},{"location":"perturbation/01-perturbation_algebraic/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","text":"Dict{Any, Any} with 2 entries:\n  a₂ => -0.04\n  a₁ => -0.2","category":"page"},{"location":"perturbation/01-perturbation_algebraic/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","text":"Finally, we substitute back the values of a in the definition of x as a function of 𝜀. Note that 𝜀 is a number (usually Float64), whereas ϵ is a symbolic variable.","category":"page"},{"location":"perturbation/01-perturbation_algebraic/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","text":"X = 𝜀 -> 1 + a[1]*𝜀 + a[2]*𝜀^2","category":"page"},{"location":"perturbation/01-perturbation_algebraic/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","text":"#9 (generic function with 1 method)","category":"page"},{"location":"perturbation/01-perturbation_algebraic/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","text":"Therefore, the solution to our original problem becomes X(1), which is equal to 0.76. We can use larger values of n to improve the accuracy of estimations.","category":"page"},{"location":"perturbation/01-perturbation_algebraic/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","text":"n x\n1 0.8\n2 0.76\n3 0.752\n4 0.752\n5 0.7533\n6 0.7543\n7 0.7548\n8 0.7550","category":"page"},{"location":"perturbation/01-perturbation_algebraic/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","text":"Remember the numerical value is 0.7549. The two functions collect_powers and solve_coef(eqs, a) are used in all the examples in this and the next tutorial.","category":"page"},{"location":"perturbation/01-perturbation_algebraic/#Solving-the-Kepler's-Equation","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","title":"Solving the Kepler's Equation","text":"","category":"section"},{"location":"perturbation/01-perturbation_algebraic/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","text":"Historically, the perturbation methods were first invented to solve orbital calculations of the Moon and the planets. In homage to this history, our second example has a celestial theme. Our goal is solve the Kepler's equation:","category":"page"},{"location":"perturbation/01-perturbation_algebraic/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","text":"$","category":"page"},{"location":"perturbation/01-perturbation_algebraic/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","text":"E - e\\sin(E) = M   \\,. $","category":"page"},{"location":"perturbation/01-perturbation_algebraic/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","text":"where e is the eccentricity of the elliptical orbit, M is the mean anomaly, and E (unknown) is the eccentric anomaly (the angle between the position of a planet in an elliptical orbit and the point of periapsis). This equation is central to solving two-body Keplerian orbits.","category":"page"},{"location":"perturbation/01-perturbation_algebraic/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","text":"Similar to the first example, it is easy to solve this problem using the Newton's method. For example, let e = 001671 (the eccentricity of the Earth) and M = pi2. We have solve_newton(x - e*sin(x) - M, x, M) equals to 1.5875 (compared to π/2 = 1.5708). Now, we try to solve the same problem using the perturbation techniques (see function test_kepler).","category":"page"},{"location":"perturbation/01-perturbation_algebraic/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","text":"For e = 0, we get E = M. Therefore, we can use e as our perturbation parameter. For consistency with other problems, we also rename e to epsilon and E to x.","category":"page"},{"location":"perturbation/01-perturbation_algebraic/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","text":"From here on, we use the helper function def_taylor to define Taylor's series by calling it as x = def_taylor(ϵ, a, 1), where the arguments are, respectively, the perturbation variable, an array of coefficients (starting from the coefficient of epsilon^1), and an optional constant term.","category":"page"},{"location":"perturbation/01-perturbation_algebraic/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","text":"def_taylor(x, ps) = sum([a*x^i for (i,a) in enumerate(ps)])\ndef_taylor(x, ps, p₀) = p₀ + def_taylor(x, ps)","category":"page"},{"location":"perturbation/01-perturbation_algebraic/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","text":"def_taylor (generic function with 2 methods)","category":"page"},{"location":"perturbation/01-perturbation_algebraic/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","text":"We start by defining the variables (assuming n = 3):","category":"page"},{"location":"perturbation/01-perturbation_algebraic/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","text":"n = 3\n@variables ϵ M a[1:n]\nx = def_taylor(ϵ, a, M)","category":"page"},{"location":"perturbation/01-perturbation_algebraic/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","text":"M + a₁*ϵ + a₂*(ϵ^2) + a₃*(ϵ^3)","category":"page"},{"location":"perturbation/01-perturbation_algebraic/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","text":"We further simplify by substituting sin with its power series using the expand_sin helper function:","category":"page"},{"location":"perturbation/01-perturbation_algebraic/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","text":"expand_sin(x, n) = sum([(isodd(k) ? -1 : 1)*(-x)^(2k-1)/factorial(2k-1) for k=1:n])","category":"page"},{"location":"perturbation/01-perturbation_algebraic/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","text":"expand_sin (generic function with 1 method)","category":"page"},{"location":"perturbation/01-perturbation_algebraic/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","text":"To test,","category":"page"},{"location":"perturbation/01-perturbation_algebraic/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","text":"expand_sin(0.1, 10) ≈ sin(0.1)","category":"page"},{"location":"perturbation/01-perturbation_algebraic/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","text":"true","category":"page"},{"location":"perturbation/01-perturbation_algebraic/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","text":"The problem equation is","category":"page"},{"location":"perturbation/01-perturbation_algebraic/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","text":"eq = x - ϵ * expand_sin(x, n) - M","category":"page"},{"location":"perturbation/01-perturbation_algebraic/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","text":"a₁*ϵ + a₂*(ϵ^2) + a₃*(ϵ^3) - (ϵ*(M + a₁*ϵ + a₂*(ϵ^2) + a₃*(ϵ^3) + 0.1666666\n6666666666((-M - (a₁*ϵ) - (a₂*(ϵ^2)) - (a₃*(ϵ^3)))^3) - (0.0083333333333333\n33((-M - (a₁*ϵ) - (a₂*(ϵ^2)) - (a₃*(ϵ^3)))^5))))","category":"page"},{"location":"perturbation/01-perturbation_algebraic/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","text":"We follow the same process as the first example. We collect the coefficients of the powers of ϵ","category":"page"},{"location":"perturbation/01-perturbation_algebraic/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","text":"eqs = collect_powers(eq, ϵ, 1:n)","category":"page"},{"location":"perturbation/01-perturbation_algebraic/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","text":"3-element Vector{Any}:\n a₁ + 0.16666666666666666(M^3) - M - (0.008333333333333333(M^5))\n a₂ + 0.5a₁*(M^2) - a₁ - (0.041666666666666664a₁*(M^4))\n a₃ + 0.5M*(a₁^2) + 0.5a₂*(M^2) - a₂ - (0.041666666666666664a₂*(M^4)) - (0.\n08333333333333333(M^3)*(a₁^2))","category":"page"},{"location":"perturbation/01-perturbation_algebraic/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","text":"and then solve for a:","category":"page"},{"location":"perturbation/01-perturbation_algebraic/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","text":"vals = solve_coef(eqs, a)","category":"page"},{"location":"perturbation/01-perturbation_algebraic/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","text":"Dict{Any, Any} with 3 entries:\n  a₂ => M + 0.00833333(M^5) + 0.0416667(M + 0.00833333(M^5) - (0.166667(M^3\n)))*…\n  a₃ => M + 0.00833333(M^5) + 0.0416667(M + 0.00833333(M^5) - (0.166667(M^3\n)))*…\n  a₁ => M + 0.00833333(M^5) - (0.166667(M^3))","category":"page"},{"location":"perturbation/01-perturbation_algebraic/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","text":"Finally, we substitute vals back in x:","category":"page"},{"location":"perturbation/01-perturbation_algebraic/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","text":"x′ = substitute(x, vals)\nX = (𝜀, 𝑀) -> substitute(x′, Dict(ϵ => 𝜀, M => 𝑀))\nX(0.01671, π/2)","category":"page"},{"location":"perturbation/01-perturbation_algebraic/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","text":"1.5875853629172587","category":"page"},{"location":"perturbation/01-perturbation_algebraic/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","text":"The result is 1.5876, compared to the numerical value of 1.5875. It is customary to order X based on the powers of 𝑀 instead of 𝜀. We can calculate this series as collect_powers(sol, M, 0:3). The result (after manual cleanup) is","category":"page"},{"location":"perturbation/01-perturbation_algebraic/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","text":"(1 + 𝜀 + 𝜀^2 + 𝜀^3)*𝑀\n- (𝜀 + 4*𝜀^2 + 10*𝜀^3)*𝑀^3/6\n+ (𝜀 + 16*𝜀^2 + 91*𝜀^3)*𝑀^5/120","category":"page"},{"location":"perturbation/01-perturbation_algebraic/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","text":"Comparing the formula to the one for 𝐸 in the Wikipedia article on the Kepler's equation:","category":"page"},{"location":"perturbation/01-perturbation_algebraic/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","text":"$","category":"page"},{"location":"perturbation/01-perturbation_algebraic/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","text":"E = \\frac{1}{1-\\epsilon}M     -\\frac{\\epsilon}{(1-\\epsilon)^4} \\frac{M^3}{3!} + \\frac{(9\\epsilon^2     + \\epsilon)}{(1-\\epsilon)^7}\\frac{M^5}{5!}\\cdots $","category":"page"},{"location":"perturbation/01-perturbation_algebraic/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","text":"The first deviation is in the coefficient of epsilon^3 M^5.","category":"page"},{"location":"perturbation/01-perturbation_algebraic/#Appendix","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","title":"Appendix","text":"","category":"section"},{"location":"perturbation/01-perturbation_algebraic/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","text":"These tutorials are a part of the SciMLTutorials.jl repository, found at: https://github.com/SciML/SciMLTutorials.jl. For more information on high-performance scientific machine learning, check out the SciML Open Source Software Organization https://sciml.ai.","category":"page"},{"location":"perturbation/01-perturbation_algebraic/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","text":"To locally run this tutorial, do the following commands:","category":"page"},{"location":"perturbation/01-perturbation_algebraic/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","text":"using SciMLTutorials\nSciMLTutorials.weave_file(\"tutorials/perturbation\",\"01-perturbation_algebraic.jmd\")","category":"page"},{"location":"perturbation/01-perturbation_algebraic/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","text":"Computer Information:","category":"page"},{"location":"perturbation/01-perturbation_algebraic/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","text":"Julia Version 1.6.2\nCommit 1b93d53fc4 (2021-07-14 15:36 UTC)\nPlatform Info:\n  OS: Linux (x86_64-pc-linux-gnu)\n  CPU: AMD EPYC 7502 32-Core Processor\n  WORD_SIZE: 64\n  LIBM: libopenlibm\n  LLVM: libLLVM-11.0.1 (ORCJIT, znver2)\nEnvironment:\n  JULIA_DEPOT_PATH = /root/.cache/julia-buildkite-plugin/depots/a6029d3a-f78b-41ea-bc97-28aa57c6c6ea\n  JULIA_NUM_THREADS = 16\n","category":"page"},{"location":"perturbation/01-perturbation_algebraic/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","text":"Package Information:","category":"page"},{"location":"perturbation/01-perturbation_algebraic/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","text":"      Status `/var/lib/buildkite-agent/builds/2-amdci4-julia-csail-mit-edu/julialang/scimltutorials-dot-jl/tutorials/perturbation/Project.toml`\n  [0c46a032] DifferentialEquations v6.17.1\n  [961ee093] ModelingToolkit v5.17.3\n  [91a5bcdd] Plots v1.15.2\n  [30cb0354] SciMLTutorials v0.9.0\n  [d1185830] SymbolicUtils v0.11.2\n  [0c5d862f] Symbolics v0.1.25","category":"page"},{"location":"perturbation/01-perturbation_algebraic/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","text":"And the full manifest:","category":"page"},{"location":"perturbation/01-perturbation_algebraic/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations","text":"      Status `/var/lib/buildkite-agent/builds/2-amdci4-julia-csail-mit-edu/julialang/scimltutorials-dot-jl/tutorials/perturbation/Manifest.toml`\n  [c3fe647b] AbstractAlgebra v0.16.0\n  [1520ce14] AbstractTrees v0.3.4\n  [79e6a3ab] Adapt v3.3.0\n  [ec485272] ArnoldiMethod v0.1.0\n  [4fba245c] ArrayInterface v3.1.15\n  [4c555306] ArrayLayouts v0.7.0\n  [aae01518] BandedMatrices v0.16.9\n  [764a87c0] BoundaryValueDiffEq v2.7.1\n  [fa961155] CEnum v0.4.1\n  [00ebfdb7] CSTParser v2.5.0\n  [d360d2e6] ChainRulesCore v0.9.44\n  [b630d9fa] CheapThreads v0.2.5\n  [35d6a980] ColorSchemes v3.12.1\n  [3da002f7] ColorTypes v0.11.0\n  [5ae59095] Colors v0.12.8\n  [861a8166] Combinatorics v1.0.2\n  [a80b9123] CommonMark v0.8.1\n  [38540f10] CommonSolve v0.2.0\n  [bbf7d656] CommonSubexpressions v0.3.0\n  [34da2185] Compat v3.30.0\n  [8f4d0f93] Conda v1.5.2\n  [187b0558] ConstructionBase v1.2.1\n  [d38c429a] Contour v0.5.7\n  [a8cc5b0e] Crayons v4.0.4\n  [9a962f9c] DataAPI v1.6.0\n  [864edb3b] DataStructures v0.18.9\n  [e2d170a0] DataValueInterfaces v1.0.0\n  [bcd4f6db] DelayDiffEq v5.31.0\n  [2b5f629d] DiffEqBase v6.62.2\n  [459566f4] DiffEqCallbacks v2.16.1\n  [5a0ffddc] DiffEqFinancial v2.4.0\n  [c894b116] DiffEqJump v6.14.2\n  [77a26b50] DiffEqNoiseProcess v5.7.3\n  [055956cb] DiffEqPhysics v3.9.0\n  [163ba53b] DiffResults v1.0.3\n  [b552c78f] DiffRules v1.0.2\n  [0c46a032] DifferentialEquations v6.17.1\n  [c619ae07] DimensionalPlotRecipes v1.2.0\n  [b4f34e82] Distances v0.10.3\n  [31c24e10] Distributions v0.24.18\n  [ffbed154] DocStringExtensions v0.8.4\n  [e30172f5] Documenter v0.26.3\n  [d4d017d3] ExponentialUtilities v1.8.4\n  [e2ba6199] ExprTools v0.1.3\n  [c87230d0] FFMPEG v0.4.0\n  [7034ab61] FastBroadcast v0.1.8\n  [9aa1b823] FastClosures v0.3.2\n  [1a297f60] FillArrays v0.11.7\n  [6a86dc24] FiniteDiff v2.8.0\n  [53c48c17] FixedPointNumbers v0.8.4\n  [59287772] Formatting v0.4.2\n  [f6369f11] ForwardDiff v0.10.18\n  [069b7b12] FunctionWrappers v1.1.2\n  [28b8d3ca] GR v0.57.4\n  [5c1252a2] GeometryBasics v0.3.12\n  [42e2da0e] Grisu v1.0.2\n  [cd3eb016] HTTP v0.9.9\n  [eafb193a] Highlights v0.4.5\n  [0e44f5e4] Hwloc v2.0.0\n  [7073ff75] IJulia v1.23.2\n  [b5f81e59] IOCapture v0.1.1\n  [615f187c] IfElse v0.1.0\n  [d25df0c9] Inflate v0.1.2\n  [83e8ac13] IniFile v0.5.0\n  [c8e1da08] IterTools v1.3.0\n  [42fd0dbc] IterativeSolvers v0.9.1\n  [82899510] IteratorInterfaceExtensions v1.0.0\n  [692b3bcd] JLLWrappers v1.3.0\n  [682c06a0] JSON v0.21.1\n  [98e50ef6] JuliaFormatter v0.13.7\n  [b964fa9f] LaTeXStrings v1.2.1\n  [2ee39098] LabelledArrays v1.6.1\n  [23fbe1c1] Latexify v0.15.5\n  [093fc24a] LightGraphs v1.3.5\n  [d3d80556] LineSearches v7.1.1\n  [2ab3a3ac] LogExpFunctions v0.2.4\n  [bdcacae8] LoopVectorization v0.12.23\n  [1914dd2f] MacroTools v0.5.6\n  [739be429] MbedTLS v1.0.3\n  [442fdcdd] Measures v0.3.1\n  [e1d29d7a] Missings v1.0.0\n  [961ee093] ModelingToolkit v5.17.3\n  [46d2c3a1] MuladdMacro v0.2.2\n  [f9640e96] MultiScaleArrays v1.8.1\n  [ffc61752] Mustache v1.0.10\n  [d41bc354] NLSolversBase v7.8.0\n  [2774e3e8] NLsolve v4.5.1\n  [77ba4419] NaNMath v0.3.5\n  [8913a72c] NonlinearSolve v0.3.8\n  [6fe1bfb0] OffsetArrays v1.9.0\n  [429524aa] Optim v1.3.0\n  [bac558e1] OrderedCollections v1.4.1\n  [1dea7af3] OrdinaryDiffEq v5.56.0\n  [90014a1f] PDMats v0.11.0\n  [65888b18] ParameterizedFunctions v5.10.0\n  [d96e819e] Parameters v0.12.2\n  [69de0a69] Parsers v1.1.0\n  [ccf2f8ad] PlotThemes v2.0.1\n  [995b91a9] PlotUtils v1.0.10\n  [91a5bcdd] Plots v1.15.2\n  [e409e4f3] PoissonRandom v0.4.0\n  [f517fe37] Polyester v0.3.1\n  [85a6dd25] PositiveFactorizations v0.2.4\n  [21216c6a] Preferences v1.2.2\n  [1fd47b50] QuadGK v2.4.1\n  [74087812] Random123 v1.3.1\n  [fb686558] RandomExtensions v0.4.3\n  [e6cf234a] RandomNumbers v1.4.0\n  [3cdcf5f2] RecipesBase v1.1.1\n  [01d81517] RecipesPipeline v0.3.2\n  [731186ca] RecursiveArrayTools v2.11.4\n  [f2c3362d] RecursiveFactorization v0.1.12\n  [189a3867] Reexport v1.0.0\n  [ae029012] Requires v1.1.3\n  [ae5879a3] ResettableStacks v1.1.0\n  [79098fc4] Rmath v0.7.0\n  [7e49a35a] RuntimeGeneratedFunctions v0.5.2\n  [476501e8] SLEEFPirates v0.6.20\n  [1bc83da4] SafeTestsets v0.0.1\n  [0bca4576] SciMLBase v1.13.4\n  [30cb0354] SciMLTutorials v0.9.0\n  [6c6a2e73] Scratch v1.0.3\n  [efcf1570] Setfield v0.7.0\n  [992d4aef] Showoff v1.0.3\n  [699a6c99] SimpleTraits v0.9.3\n  [b85f4697] SoftGlobalScope v1.1.0\n  [a2af1166] SortingAlgorithms v1.0.0\n  [47a9eef4] SparseDiffTools v1.13.2\n  [276daf66] SpecialFunctions v1.4.1\n  [aedffcd0] Static v0.2.4\n  [90137ffa] StaticArrays v1.2.0\n  [82ae8749] StatsAPI v1.0.0\n  [2913bbd2] StatsBase v0.33.8\n  [4c63d2b9] StatsFuns v0.9.8\n  [9672c7b4] SteadyStateDiffEq v1.6.2\n  [789caeaf] StochasticDiffEq v6.34.1\n  [7792a7ef] StrideArraysCore v0.1.11\n  [09ab397b] StructArrays v0.5.1\n  [c3572dad] Sundials v4.4.3\n  [d1185830] SymbolicUtils v0.11.2\n  [0c5d862f] Symbolics v0.1.25\n  [3783bdb8] TableTraits v1.0.1\n  [bd369af6] Tables v1.4.2\n  [8290d209] ThreadingUtilities v0.4.4\n  [a759f4b9] TimerOutputs v0.5.9\n  [0796e94c] Tokenize v0.5.16\n  [a2a6695c] TreeViews v0.3.0\n  [5c2747f8] URIs v1.3.0\n  [3a884ed6] UnPack v1.0.2\n  [1986cc42] Unitful v1.7.0\n  [3d5dd08c] VectorizationBase v0.20.11\n  [81def892] VersionParsing v1.2.0\n  [19fa3120] VertexSafeGraphs v0.1.2\n  [44d3d7a6] Weave v0.10.8\n  [ddb6d928] YAML v0.4.6\n  [c2297ded] ZMQ v1.2.1\n  [700de1a5] ZygoteRules v0.2.1\n  [6e34b625] Bzip2_jll v1.0.6+5\n  [83423d85] Cairo_jll v1.16.0+6\n  [5ae413db] EarCut_jll v2.1.5+1\n  [2e619515] Expat_jll v2.2.10+0\n  [b22a6f82] FFMPEG_jll v4.3.1+4\n  [a3f928ae] Fontconfig_jll v2.13.1+14\n  [d7e528f0] FreeType2_jll v2.10.1+5\n  [559328eb] FriBidi_jll v1.0.5+6\n  [0656b61e] GLFW_jll v3.3.4+0\n  [d2c73de3] GR_jll v0.57.2+0\n  [78b55507] Gettext_jll v0.21.0+0\n  [7746bdde] Glib_jll v2.68.1+0\n  [e33a78d0] Hwloc_jll v2.4.1+0\n  [aacddb02] JpegTurbo_jll v2.0.1+3\n  [c1c5ebd0] LAME_jll v3.100.0+3\n  [dd4b983a] LZO_jll v2.10.1+0\n  [dd192d2f] LibVPX_jll v1.9.0+1\n  [e9f186c6] Libffi_jll v3.2.2+0\n  [d4300ac3] Libgcrypt_jll v1.8.7+0\n  [7e76a0d4] Libglvnd_jll v1.3.0+3\n  [7add5ba3] Libgpg_error_jll v1.42.0+0\n  [94ce4f54] Libiconv_jll v1.16.1+0\n  [4b2f31a3] Libmount_jll v2.35.0+0\n  [89763e89] Libtiff_jll v4.1.0+2\n  [38a345b3] Libuuid_jll v2.36.0+0\n  [e7412a2a] Ogg_jll v1.3.4+2\n  [458c3c95] OpenSSL_jll v1.1.1+6\n  [efe28fd5] OpenSpecFun_jll v0.5.4+0\n  [91d4177d] Opus_jll v1.3.1+3\n  [2f80f16e] PCRE_jll v8.44.0+0\n  [30392449] Pixman_jll v0.40.1+0\n  [ea2cea3b] Qt5Base_jll v5.15.2+0\n  [f50d1b31] Rmath_jll v0.3.0+0\n  [fb77eaff] Sundials_jll v5.2.0+1\n  [a2964d1f] Wayland_jll v1.17.0+4\n  [2381bf8a] Wayland_protocols_jll v1.18.0+4\n  [02c8fc9c] XML2_jll v2.9.12+0\n  [aed1982a] XSLT_jll v1.1.34+0\n  [4f6342f7] Xorg_libX11_jll v1.6.9+4\n  [0c0b7dd1] Xorg_libXau_jll v1.0.9+4\n  [935fb764] Xorg_libXcursor_jll v1.2.0+4\n  [a3789734] Xorg_libXdmcp_jll v1.1.3+4\n  [1082639a] Xorg_libXext_jll v1.3.4+4\n  [d091e8ba] Xorg_libXfixes_jll v5.0.3+4\n  [a51aa0fd] Xorg_libXi_jll v1.7.10+4\n  [d1454406] Xorg_libXinerama_jll v1.1.4+4\n  [ec84b674] Xorg_libXrandr_jll v1.5.2+4\n  [ea2f1a96] Xorg_libXrender_jll v0.9.10+4\n  [14d82f49] Xorg_libpthread_stubs_jll v0.1.0+3\n  [c7cfdc94] Xorg_libxcb_jll v1.13.0+3\n  [cc61e674] Xorg_libxkbfile_jll v1.1.0+4\n  [12413925] Xorg_xcb_util_image_jll v0.4.0+1\n  [2def613f] Xorg_xcb_util_jll v0.4.0+1\n  [975044d2] Xorg_xcb_util_keysyms_jll v0.4.0+1\n  [0d47668e] Xorg_xcb_util_renderutil_jll v0.3.9+1\n  [c22f9ab0] Xorg_xcb_util_wm_jll v0.4.1+1\n  [35661453] Xorg_xkbcomp_jll v1.4.2+4\n  [33bec58e] Xorg_xkeyboard_config_jll v2.27.0+4\n  [c5fb5394] Xorg_xtrans_jll v1.4.0+3\n  [8f1865be] ZeroMQ_jll v4.3.2+6\n  [3161d3a3] Zstd_jll v1.5.0+0\n  [0ac62f75] libass_jll v0.14.0+4\n  [f638f0a6] libfdk_aac_jll v0.1.6+4\n  [b53b4c65] libpng_jll v1.6.38+0\n  [a9144af2] libsodium_jll v1.0.20+0\n  [f27f6e37] libvorbis_jll v1.3.6+6\n  [1270edf5] x264_jll v2020.7.14+2\n  [dfaa095f] x265_jll v3.0.0+3\n  [d8fb68d0] xkbcommon_jll v0.9.1+5\n  [0dad84c5] ArgTools\n  [56f22d72] Artifacts\n  [2a0f44e3] Base64\n  [ade2ca70] Dates\n  [8bb1440f] DelimitedFiles\n  [8ba89e20] Distributed\n  [f43a241f] Downloads\n  [7b1f6079] FileWatching\n  [9fa8497b] Future\n  [b77e0a4c] InteractiveUtils\n  [b27032c2] LibCURL\n  [76f85450] LibGit2\n  [8f399da3] Libdl\n  [37e2e46d] LinearAlgebra\n  [56ddb016] Logging\n  [d6f4376e] Markdown\n  [a63ad114] Mmap\n  [ca575930] NetworkOptions\n  [44cfe95a] Pkg\n  [de0858da] Printf\n  [3fa0cd96] REPL\n  [9a3f8284] Random\n  [ea8e919c] SHA\n  [9e88b42a] Serialization\n  [1a1011a3] SharedArrays\n  [6462fe0b] Sockets\n  [2f01184e] SparseArrays\n  [10745b16] Statistics\n  [4607b0f0] SuiteSparse\n  [fa267f1f] TOML\n  [a4e569a6] Tar\n  [8dfed614] Test\n  [cf7118a7] UUIDs\n  [4ec0a83e] Unicode\n  [e66e0078] CompilerSupportLibraries_jll\n  [deac9b47] LibCURL_jll\n  [29816b5a] LibSSH2_jll\n  [c8ffd9c3] MbedTLS_jll\n  [14a3606d] MozillaCACerts_jll\n  [4536629a] OpenBLAS_jll\n  [bea87d4a] SuiteSparse_jll\n  [83775a58] Zlib_jll\n  [8e850ede] nghttp2_jll\n  [3f19e933] p7zip_jll","category":"page"},{"location":"test/","page":"-","title":"-","text":"","category":"page"},{"location":"test/","page":"-","title":"-","text":"author: \"Chris Rackauckas\" title: \"Test\" –-","category":"page"},{"location":"test/","page":"-","title":"-","text":"This is a test of the builder system.","category":"page"},{"location":"test/#Appendix","page":"-","title":"Appendix","text":"","category":"section"},{"location":"test/","page":"-","title":"-","text":"This tutorial is part of the SciMLTutorials.jl repository, found at: https://github.com/SciML/SciMLTutorials.jl.  For more information on doing scientific machine learning (SciML) with open source software, check out https://sciml.ai/.","category":"page"},{"location":"test/","page":"-","title":"-","text":"To locally run this tutorial, do the following commands:","category":"page"},{"location":"test/","page":"-","title":"-","text":"using SciMLTutorials\nSciMLTutorials.weave_file(\".\",\"Testing/test.jmd\")","category":"page"},{"location":"test/","page":"-","title":"-","text":"Computer Information:","category":"page"},{"location":"test/","page":"-","title":"-","text":"Julia Version 1.6.1\nCommit 6aaedecc44 (2021-04-23 05:59 UTC)\nPlatform Info:\n  OS: macOS (x86_64-apple-darwin18.7.0)\n  CPU: Intel(R) Core(TM) i5-5350U CPU @ 1.80GHz\n  WORD_SIZE: 64\n  LIBM: libopenlibm\n  LLVM: libLLVM-11.0.1 (ORCJIT, broadwell)\nEnvironment:\n  JULIA_LOAD_PATH = @:/var/folders/lv/kg1z6t3s4wdf1sss2p42dr200000gn/T/jl_NMW2d4\n","category":"page"},{"location":"test/","page":"-","title":"-","text":"      Status `~/.julia/dev/SciMLTutorials/tutorials/Testing/Project.toml`\n  [30cb0354] SciMLTutorials v0.8.0","category":"page"},{"location":"test/","page":"-","title":"-","text":"And the full manifest:","category":"page"},{"location":"test/","page":"-","title":"-","text":"      Status `~/.julia/dev/SciMLTutorials/tutorials/Testing/Manifest.toml`\n  [621f4979] AbstractFFTs v1.0.1\n  [79e6a3ab] Adapt v3.3.0\n  [d360d2e6] ChainRulesCore v0.9.44\n  [35d6a980] ColorSchemes v3.12.1\n  [3da002f7] ColorTypes v0.11.0\n  [5ae59095] Colors v0.12.8\n  [34da2185] Compat v3.30.0\n  [8f4d0f93] Conda v1.5.2\n  [d38c429a] Contour v0.5.7\n  [717857b8] DSP v0.6.10\n  [9a962f9c] DataAPI v1.6.0\n  [864edb3b] DataStructures v0.18.9\n  [e2d170a0] DataValueInterfaces v1.0.0\n  [ffbed154] DocStringExtensions v0.8.4\n  [e2ba6199] ExprTools v0.1.3\n  [8f5d6c58] EzXML v1.1.0\n  [c87230d0] FFMPEG v0.4.0\n  [7a1cc6ca] FFTW v1.4.1\n  [53c48c17] FixedPointNumbers v0.8.4\n  [59287772] Formatting v0.4.2\n  [28b8d3ca] GR v0.57.4\n  [5c1252a2] GeometryBasics v0.3.12\n  [42e2da0e] Grisu v1.0.2\n  [cd3eb016] HTTP v0.9.8\n  [eafb193a] Highlights v0.4.5\n  [7073ff75] IJulia v1.23.2\n  [83e8ac13] IniFile v0.5.0\n  [d8418881] Intervals v1.5.0\n  [c8e1da08] IterTools v1.3.0\n  [82899510] IteratorInterfaceExtensions v1.0.0\n  [692b3bcd] JLLWrappers v1.3.0\n  [682c06a0] JSON v0.21.1\n  [b964fa9f] LaTeXStrings v1.2.1\n  [23fbe1c1] Latexify v0.15.5\n  [2ab3a3ac] LogExpFunctions v0.2.4\n  [1914dd2f] MacroTools v0.5.6\n  [739be429] MbedTLS v1.0.3\n  [442fdcdd] Measures v0.3.1\n  [e1d29d7a] Missings v1.0.0\n  [78c3b35d] Mocking v0.7.1\n  [ffc61752] Mustache v1.0.10\n  [77ba4419] NaNMath v0.3.5\n  [6fe1bfb0] OffsetArrays v1.8.0\n  [bac558e1] OrderedCollections v1.4.1\n  [69de0a69] Parsers v1.1.0\n  [ccf2f8ad] PlotThemes v2.0.1\n  [995b91a9] PlotUtils v1.0.10\n  [91a5bcdd] Plots v1.15.2\n  [f27b6e38] Polynomials v1.2.1\n  [21216c6a] Preferences v1.2.2\n  [3cdcf5f2] RecipesBase v1.1.1\n  [01d81517] RecipesPipeline v0.3.2\n  [189a3867] Reexport v1.0.0\n  [ae029012] Requires v1.1.3\n  [30cb0354] SciMLTutorials v0.8.0\n  [6c6a2e73] Scratch v1.0.3\n  [992d4aef] Showoff v1.0.3\n  [b85f4697] SoftGlobalScope v1.1.0\n  [a2af1166] SortingAlgorithms v1.0.0\n  [276daf66] SpecialFunctions v1.4.1\n  [90137ffa] StaticArrays v1.2.0\n  [82ae8749] StatsAPI v1.0.0\n  [2913bbd2] StatsBase v0.33.8\n  [09ab397b] StructArrays v0.5.1\n  [3783bdb8] TableTraits v1.0.1\n  [bd369af6] Tables v1.4.2\n  [f269a46b] TimeZones v1.5.5\n  [5c2747f8] URIs v1.3.0\n  [81def892] VersionParsing v1.2.0\n  [44d3d7a6] Weave v0.10.8\n  [ddb6d928] YAML v0.4.6\n  [c2297ded] ZMQ v1.2.1\n  [6e34b625] Bzip2_jll v1.0.6+5\n  [83423d85] Cairo_jll v1.16.0+6\n  [5ae413db] EarCut_jll v2.1.5+1\n  [2e619515] Expat_jll v2.2.10+0\n  [b22a6f82] FFMPEG_jll v4.3.1+4\n  [f5851436] FFTW_jll v3.3.9+7\n  [a3f928ae] Fontconfig_jll v2.13.1+14\n  [d7e528f0] FreeType2_jll v2.10.1+5\n  [559328eb] FriBidi_jll v1.0.5+6\n  [0656b61e] GLFW_jll v3.3.4+0\n  [d2c73de3] GR_jll v0.57.2+0\n  [78b55507] Gettext_jll v0.21.0+0\n  [7746bdde] Glib_jll v2.68.1+0\n  [1d5cc7b8] IntelOpenMP_jll v2018.0.3+2\n  [aacddb02] JpegTurbo_jll v2.0.1+3\n  [c1c5ebd0] LAME_jll v3.100.0+3\n  [dd4b983a] LZO_jll v2.10.0+3\n  [dd192d2f] LibVPX_jll v1.9.0+1\n  [e9f186c6] Libffi_jll v3.2.2+0\n  [d4300ac3] Libgcrypt_jll v1.8.5+4\n  [7e76a0d4] Libglvnd_jll v1.3.0+3\n  [7add5ba3] Libgpg_error_jll v1.36.0+3\n  [94ce4f54] Libiconv_jll v1.16.1+0\n  [4b2f31a3] Libmount_jll v2.35.0+0\n  [89763e89] Libtiff_jll v4.1.0+2\n  [38a345b3] Libuuid_jll v2.36.0+0\n  [856f044c] MKL_jll v2021.1.1+1\n  [e7412a2a] Ogg_jll v1.3.4+2\n  [458c3c95] OpenSSL_jll v1.1.1+6\n  [efe28fd5] OpenSpecFun_jll v0.5.4+0\n  [91d4177d] Opus_jll v1.3.1+3\n  [2f80f16e] PCRE_jll v8.44.0+0\n  [30392449] Pixman_jll v0.40.0+0\n  [ea2cea3b] Qt5Base_jll v5.15.2+0\n  [a2964d1f] Wayland_jll v1.17.0+4\n  [2381bf8a] Wayland_protocols_jll v1.18.0+4\n  [02c8fc9c] XML2_jll v2.9.12+0\n  [aed1982a] XSLT_jll v1.1.33+4\n  [4f6342f7] Xorg_libX11_jll v1.6.9+4\n  [0c0b7dd1] Xorg_libXau_jll v1.0.9+4\n  [935fb764] Xorg_libXcursor_jll v1.2.0+4\n  [a3789734] Xorg_libXdmcp_jll v1.1.3+4\n  [1082639a] Xorg_libXext_jll v1.3.4+4\n  [d091e8ba] Xorg_libXfixes_jll v5.0.3+4\n  [a51aa0fd] Xorg_libXi_jll v1.7.10+4\n  [d1454406] Xorg_libXinerama_jll v1.1.4+4\n  [ec84b674] Xorg_libXrandr_jll v1.5.2+4\n  [ea2f1a96] Xorg_libXrender_jll v0.9.10+4\n  [14d82f49] Xorg_libpthread_stubs_jll v0.1.0+3\n  [c7cfdc94] Xorg_libxcb_jll v1.13.0+3\n  [cc61e674] Xorg_libxkbfile_jll v1.1.0+4\n  [12413925] Xorg_xcb_util_image_jll v0.4.0+1\n  [2def613f] Xorg_xcb_util_jll v0.4.0+1\n  [975044d2] Xorg_xcb_util_keysyms_jll v0.4.0+1\n  [0d47668e] Xorg_xcb_util_renderutil_jll v0.3.9+1\n  [c22f9ab0] Xorg_xcb_util_wm_jll v0.4.1+1\n  [35661453] Xorg_xkbcomp_jll v1.4.2+4\n  [33bec58e] Xorg_xkeyboard_config_jll v2.27.0+4\n  [c5fb5394] Xorg_xtrans_jll v1.4.0+3\n  [8f1865be] ZeroMQ_jll v4.3.2+6\n  [3161d3a3] Zstd_jll v1.5.0+0\n  [0ac62f75] libass_jll v0.14.0+4\n  [f638f0a6] libfdk_aac_jll v0.1.6+4\n  [b53b4c65] libpng_jll v1.6.37+6\n  [a9144af2] libsodium_jll v1.0.20+0\n  [f27f6e37] libvorbis_jll v1.3.6+6\n  [1270edf5] x264_jll v2020.7.14+2\n  [dfaa095f] x265_jll v3.0.0+3\n  [d8fb68d0] xkbcommon_jll v0.9.1+5\n  [0dad84c5] ArgTools\n  [56f22d72] Artifacts\n  [2a0f44e3] Base64\n  [ade2ca70] Dates\n  [8bb1440f] DelimitedFiles\n  [8ba89e20] Distributed\n  [f43a241f] Downloads\n  [7b1f6079] FileWatching\n  [b77e0a4c] InteractiveUtils\n  [4af54fe1] LazyArtifacts\n  [b27032c2] LibCURL\n  [76f85450] LibGit2\n  [8f399da3] Libdl\n  [37e2e46d] LinearAlgebra\n  [56ddb016] Logging\n  [d6f4376e] Markdown\n  [a63ad114] Mmap\n  [ca575930] NetworkOptions\n  [44cfe95a] Pkg\n  [de0858da] Printf\n  [3fa0cd96] REPL\n  [9a3f8284] Random\n  [ea8e919c] SHA\n  [9e88b42a] Serialization\n  [1a1011a3] SharedArrays\n  [6462fe0b] Sockets\n  [2f01184e] SparseArrays\n  [10745b16] Statistics\n  [fa267f1f] TOML\n  [a4e569a6] Tar\n  [8dfed614] Test\n  [cf7118a7] UUIDs\n  [4ec0a83e] Unicode\n  [e66e0078] CompilerSupportLibraries_jll\n  [deac9b47] LibCURL_jll\n  [29816b5a] LibSSH2_jll\n  [c8ffd9c3] MbedTLS_jll\n  [14a3606d] MozillaCACerts_jll\n  [83775a58] Zlib_jll\n  [8e850ede] nghttp2_jll\n  [3f19e933] p7zip_jll","category":"page"},{"location":"model_inference/01-pendulum_bayesian_inference/#Bayesian-Inference-on-a-Pendulum-using-DiffEqBayes.jl","page":"Bayesian Inference on a Pendulum using DiffEqBayes.jl","title":"Bayesian Inference on a Pendulum using DiffEqBayes.jl","text":"","category":"section"},{"location":"model_inference/01-pendulum_bayesian_inference/#Set-up-simple-pendulum-problem","page":"Bayesian Inference on a Pendulum using DiffEqBayes.jl","title":"Set up simple pendulum problem","text":"","category":"section"},{"location":"model_inference/01-pendulum_bayesian_inference/","page":"Bayesian Inference on a Pendulum using DiffEqBayes.jl","title":"Bayesian Inference on a Pendulum using DiffEqBayes.jl","text":"using DiffEqBayes, OrdinaryDiffEq, RecursiveArrayTools, Distributions, Plots, StatsPlots, BenchmarkTools, TransformVariables, CmdStan, DynamicHMC","category":"page"},{"location":"model_inference/01-pendulum_bayesian_inference/","page":"Bayesian Inference on a Pendulum using DiffEqBayes.jl","title":"Bayesian Inference on a Pendulum using DiffEqBayes.jl","text":"Let's define our simple pendulum problem. Here our pendulum has a drag term ω and a length L.","category":"page"},{"location":"model_inference/01-pendulum_bayesian_inference/","page":"Bayesian Inference on a Pendulum using DiffEqBayes.jl","title":"Bayesian Inference on a Pendulum using DiffEqBayes.jl","text":"(Image: pendulum)","category":"page"},{"location":"model_inference/01-pendulum_bayesian_inference/","page":"Bayesian Inference on a Pendulum using DiffEqBayes.jl","title":"Bayesian Inference on a Pendulum using DiffEqBayes.jl","text":"We get first order equations by defining the first term as the velocity and the second term as the position, getting:","category":"page"},{"location":"model_inference/01-pendulum_bayesian_inference/","page":"Bayesian Inference on a Pendulum using DiffEqBayes.jl","title":"Bayesian Inference on a Pendulum using DiffEqBayes.jl","text":"function pendulum(du,u,p,t)\n    ω,L = p\n    x,y = u\n    du[1] = y\n    du[2] = - ω*y -(9.8/L)*sin(x)\nend\n\nu0 = [1.0,0.1]\ntspan = (0.0,10.0)\nprob1 = ODEProblem(pendulum,u0,tspan,[1.0,2.5])","category":"page"},{"location":"model_inference/01-pendulum_bayesian_inference/","page":"Bayesian Inference on a Pendulum using DiffEqBayes.jl","title":"Bayesian Inference on a Pendulum using DiffEqBayes.jl","text":"ODEProblem with uType Array{Float64,1} and tType Float64. In-place: true\ntimespan: (0.0, 10.0)\nu0: [1.0, 0.1]","category":"page"},{"location":"model_inference/01-pendulum_bayesian_inference/#Solve-the-model-and-plot","page":"Bayesian Inference on a Pendulum using DiffEqBayes.jl","title":"Solve the model and plot","text":"","category":"section"},{"location":"model_inference/01-pendulum_bayesian_inference/","page":"Bayesian Inference on a Pendulum using DiffEqBayes.jl","title":"Bayesian Inference on a Pendulum using DiffEqBayes.jl","text":"To understand the model and generate data, let's solve and visualize the solution with the known parameters:","category":"page"},{"location":"model_inference/01-pendulum_bayesian_inference/","page":"Bayesian Inference on a Pendulum using DiffEqBayes.jl","title":"Bayesian Inference on a Pendulum using DiffEqBayes.jl","text":"sol = solve(prob1,Tsit5())\nplot(sol)","category":"page"},{"location":"model_inference/01-pendulum_bayesian_inference/","page":"Bayesian Inference on a Pendulum using DiffEqBayes.jl","title":"Bayesian Inference on a Pendulum using DiffEqBayes.jl","text":"(Image: )","category":"page"},{"location":"model_inference/01-pendulum_bayesian_inference/","page":"Bayesian Inference on a Pendulum using DiffEqBayes.jl","title":"Bayesian Inference on a Pendulum using DiffEqBayes.jl","text":"It's the pendulum, so you know what it looks like. It's periodic, but since we have not made a small angle assumption it's not exactly sin or cos. Because the true dampening parameter ω is 1, the solution does not decay over time, nor does it increase. The length L determines the period.","category":"page"},{"location":"model_inference/01-pendulum_bayesian_inference/#Create-some-dummy-data-to-use-for-estimation","page":"Bayesian Inference on a Pendulum using DiffEqBayes.jl","title":"Create some dummy data to use for estimation","text":"","category":"section"},{"location":"model_inference/01-pendulum_bayesian_inference/","page":"Bayesian Inference on a Pendulum using DiffEqBayes.jl","title":"Bayesian Inference on a Pendulum using DiffEqBayes.jl","text":"We now generate some dummy data to use for estimation","category":"page"},{"location":"model_inference/01-pendulum_bayesian_inference/","page":"Bayesian Inference on a Pendulum using DiffEqBayes.jl","title":"Bayesian Inference on a Pendulum using DiffEqBayes.jl","text":"t = collect(range(1,stop=10,length=10))\nrandomized = VectorOfArray([(sol(t[i]) + .01randn(2)) for i in 1:length(t)])\ndata = convert(Array,randomized)","category":"page"},{"location":"model_inference/01-pendulum_bayesian_inference/","page":"Bayesian Inference on a Pendulum using DiffEqBayes.jl","title":"Bayesian Inference on a Pendulum using DiffEqBayes.jl","text":"2×10 Array{Float64,2}:\n  0.0669231  -0.377851  0.119404   0.0795968  …  -0.01553     0.00535298\n -1.21411     0.344681  0.323712  -0.253243       0.0164092  -0.00897403","category":"page"},{"location":"model_inference/01-pendulum_bayesian_inference/","page":"Bayesian Inference on a Pendulum using DiffEqBayes.jl","title":"Bayesian Inference on a Pendulum using DiffEqBayes.jl","text":"Let's see what our data looks like on top of the real solution","category":"page"},{"location":"model_inference/01-pendulum_bayesian_inference/","page":"Bayesian Inference on a Pendulum using DiffEqBayes.jl","title":"Bayesian Inference on a Pendulum using DiffEqBayes.jl","text":"scatter!(data')","category":"page"},{"location":"model_inference/01-pendulum_bayesian_inference/","page":"Bayesian Inference on a Pendulum using DiffEqBayes.jl","title":"Bayesian Inference on a Pendulum using DiffEqBayes.jl","text":"(Image: )","category":"page"},{"location":"model_inference/01-pendulum_bayesian_inference/","page":"Bayesian Inference on a Pendulum using DiffEqBayes.jl","title":"Bayesian Inference on a Pendulum using DiffEqBayes.jl","text":"This data captures the non-dampening effect and the true period, making it perfect to attempting a Bayesian inference.","category":"page"},{"location":"model_inference/01-pendulum_bayesian_inference/#Perform-Bayesian-Estimation","page":"Bayesian Inference on a Pendulum using DiffEqBayes.jl","title":"Perform Bayesian Estimation","text":"","category":"section"},{"location":"model_inference/01-pendulum_bayesian_inference/","page":"Bayesian Inference on a Pendulum using DiffEqBayes.jl","title":"Bayesian Inference on a Pendulum using DiffEqBayes.jl","text":"Now let's fit the pendulum to the data. Since we know our model is correct, this should give us back the parameters that we used to generate the data! Define priors on our parameters. In this case, let's assume we don't have much information, but have a prior belief that ω is between 0.1 and 3.0, while the length of the pendulum L is probably around 3.0:","category":"page"},{"location":"model_inference/01-pendulum_bayesian_inference/","page":"Bayesian Inference on a Pendulum using DiffEqBayes.jl","title":"Bayesian Inference on a Pendulum using DiffEqBayes.jl","text":"priors = [Uniform(0.1,3.0), Normal(3.0,1.0)]","category":"page"},{"location":"model_inference/01-pendulum_bayesian_inference/","page":"Bayesian Inference on a Pendulum using DiffEqBayes.jl","title":"Bayesian Inference on a Pendulum using DiffEqBayes.jl","text":"2-element Array{Distributions.Distribution{Distributions.Univariate,Distrib\nutions.Continuous},1}:\n Distributions.Uniform{Float64}(a=0.1, b=3.0)\n Distributions.Normal{Float64}(μ=3.0, σ=1.0)","category":"page"},{"location":"model_inference/01-pendulum_bayesian_inference/","page":"Bayesian Inference on a Pendulum using DiffEqBayes.jl","title":"Bayesian Inference on a Pendulum using DiffEqBayes.jl","text":"Finally let's run the estimation routine from DiffEqBayes.jl with the Turing.jl backend to check if we indeed recover the parameters!","category":"page"},{"location":"model_inference/01-pendulum_bayesian_inference/","page":"Bayesian Inference on a Pendulum using DiffEqBayes.jl","title":"Bayesian Inference on a Pendulum using DiffEqBayes.jl","text":"bayesian_result = turing_inference(prob1,Tsit5(),t,data,priors;num_samples=10_000,\n                                   syms = [:omega,:L])","category":"page"},{"location":"model_inference/01-pendulum_bayesian_inference/","page":"Bayesian Inference on a Pendulum using DiffEqBayes.jl","title":"Bayesian Inference on a Pendulum using DiffEqBayes.jl","text":"Chains MCMC chain (9000×15×1 Array{Float64,3}):\n\nIterations        = 1:9000\nThinning interval = 1\nChains            = 1\nSamples per chain = 9000\nparameters        = L, omega, σ[1]\ninternals         = acceptance_rate, hamiltonian_energy, hamiltonian_energy\n_error, is_accept, log_density, lp, max_hamiltonian_energy_error, n_steps, \nnom_step_size, numerical_error, step_size, tree_depth\n\nSummary Statistics\n  parameters      mean       std   naive_se      mcse         ess      rhat\n  \n      Symbol   Float64   Float64    Float64   Float64     Float64   Float64\n  \n                                                                           \n  \n           L    2.5036    0.2148     0.0023    0.0035   3703.0703    1.0000\n  \n       omega    1.0777    0.2217     0.0023    0.0048   2000.0506    1.0008\n  \n        σ[1]    0.1603    0.0390     0.0004    0.0007   3326.8139    0.9999\n  \n\nQuantiles\n  parameters      2.5%     25.0%     50.0%     75.0%     97.5%  \n      Symbol   Float64   Float64   Float64   Float64   Float64  \n                                                                \n           L    2.0761    2.3766    2.5024    2.6302    2.9287  \n       omega    0.7670    0.9384    1.0395    1.1706    1.6059  \n        σ[1]    0.1018    0.1325    0.1540    0.1812    0.2529","category":"page"},{"location":"model_inference/01-pendulum_bayesian_inference/","page":"Bayesian Inference on a Pendulum using DiffEqBayes.jl","title":"Bayesian Inference on a Pendulum using DiffEqBayes.jl","text":"Notice that while our guesses had the wrong means, the learned parameters converged to the correct means, meaning that it learned good posterior distributions for the parameters. To look at these posterior distributions on the parameters, we can examine the chains:","category":"page"},{"location":"model_inference/01-pendulum_bayesian_inference/","page":"Bayesian Inference on a Pendulum using DiffEqBayes.jl","title":"Bayesian Inference on a Pendulum using DiffEqBayes.jl","text":"plot(bayesian_result)","category":"page"},{"location":"model_inference/01-pendulum_bayesian_inference/","page":"Bayesian Inference on a Pendulum using DiffEqBayes.jl","title":"Bayesian Inference on a Pendulum using DiffEqBayes.jl","text":"(Image: )","category":"page"},{"location":"model_inference/01-pendulum_bayesian_inference/","page":"Bayesian Inference on a Pendulum using DiffEqBayes.jl","title":"Bayesian Inference on a Pendulum using DiffEqBayes.jl","text":"As a diagnostic, we will also check the parameter chains. The chain is the MCMC sampling process. The chain should explore parameter space and converge reasonably well, and we should be taking a lot of samples after it converges (it is these samples that form the posterior distribution!)","category":"page"},{"location":"model_inference/01-pendulum_bayesian_inference/","page":"Bayesian Inference on a Pendulum using DiffEqBayes.jl","title":"Bayesian Inference on a Pendulum using DiffEqBayes.jl","text":"plot(bayesian_result, colordim = :parameter)","category":"page"},{"location":"model_inference/01-pendulum_bayesian_inference/","page":"Bayesian Inference on a Pendulum using DiffEqBayes.jl","title":"Bayesian Inference on a Pendulum using DiffEqBayes.jl","text":"(Image: )","category":"page"},{"location":"model_inference/01-pendulum_bayesian_inference/","page":"Bayesian Inference on a Pendulum using DiffEqBayes.jl","title":"Bayesian Inference on a Pendulum using DiffEqBayes.jl","text":"Notice that after awhile these chains converge to a \"fuzzy line\", meaning it found the area with the most likelihood and then starts to sample around there, which builds a posterior distribution around the true mean.","category":"page"},{"location":"model_inference/01-pendulum_bayesian_inference/","page":"Bayesian Inference on a Pendulum using DiffEqBayes.jl","title":"Bayesian Inference on a Pendulum using DiffEqBayes.jl","text":"DiffEqBayes.jl allows the choice of using Stan.jl, Turing.jl and DynamicHMC.jl for MCMC, you can also use ApproxBayes.jl for Approximate Bayesian computation algorithms. Let's compare the timings across the different MCMC backends. We'll stick with the default arguments and 10,000 samples in each since there is a lot of room for micro-optimization specific to each package and algorithm combinations, you might want to do your own experiments for specific problems to get better understanding of the performance.","category":"page"},{"location":"model_inference/01-pendulum_bayesian_inference/","page":"Bayesian Inference on a Pendulum using DiffEqBayes.jl","title":"Bayesian Inference on a Pendulum using DiffEqBayes.jl","text":"@btime bayesian_result = turing_inference(prob1,Tsit5(),t,data,priors;syms = [:omega,:L],num_samples=10_000)","category":"page"},{"location":"model_inference/01-pendulum_bayesian_inference/","page":"Bayesian Inference on a Pendulum using DiffEqBayes.jl","title":"Bayesian Inference on a Pendulum using DiffEqBayes.jl","text":"2.710 s (23598867 allocations: 1.50 GiB)\nChains MCMC chain (9000×15×1 Array{Float64,3}):\n\nIterations        = 1:9000\nThinning interval = 1\nChains            = 1\nSamples per chain = 9000\nparameters        = L, omega, σ[1]\ninternals         = acceptance_rate, hamiltonian_energy, hamiltonian_energy\n_error, is_accept, log_density, lp, max_hamiltonian_energy_error, n_steps, \nnom_step_size, numerical_error, step_size, tree_depth\n\nSummary Statistics\n  parameters      mean       std   naive_se      mcse         ess      rhat\n  \n      Symbol   Float64   Float64    Float64   Float64     Float64   Float64\n  \n                                                                           \n  \n           L    2.5019    0.2081     0.0022    0.0034   3767.3721    1.0000\n  \n       omega    1.0773    0.2137     0.0023    0.0040   2973.1493    1.0001\n  \n        σ[1]    0.1593    0.0371     0.0004    0.0006   4173.1326    1.0004\n  \n\nQuantiles\n  parameters      2.5%     25.0%     50.0%     75.0%     97.5%  \n      Symbol   Float64   Float64   Float64   Float64   Float64  \n                                                                \n           L    2.0844    2.3770    2.5029    2.6269    2.9178  \n       omega    0.7660    0.9383    1.0424    1.1743    1.6056  \n        σ[1]    0.1032    0.1325    0.1538    0.1793    0.2468","category":"page"},{"location":"model_inference/01-pendulum_bayesian_inference/","page":"Bayesian Inference on a Pendulum using DiffEqBayes.jl","title":"Bayesian Inference on a Pendulum using DiffEqBayes.jl","text":"@btime bayesian_result = stan_inference(prob1,t,data,priors;num_samples=10_000,printsummary=false)","category":"page"},{"location":"model_inference/01-pendulum_bayesian_inference/","page":"Bayesian Inference on a Pendulum using DiffEqBayes.jl","title":"Bayesian Inference on a Pendulum using DiffEqBayes.jl","text":"Error: MethodError: no method matching iterate(::ModelingToolkit.ODESystem)\nClosest candidates are:\n  iterate(!Matched::Core.SimpleVector) at essentials.jl:603\n  iterate(!Matched::Core.SimpleVector, !Matched::Any) at essentials.jl:603\n  iterate(!Matched::ExponentialBackOff) at error.jl:253\n  ...","category":"page"},{"location":"model_inference/01-pendulum_bayesian_inference/","page":"Bayesian Inference on a Pendulum using DiffEqBayes.jl","title":"Bayesian Inference on a Pendulum using DiffEqBayes.jl","text":"@btime bayesian_result = dynamichmc_inference(prob1,Tsit5(),t,data,priors;num_samples = 10_000)","category":"page"},{"location":"model_inference/01-pendulum_bayesian_inference/","page":"Bayesian Inference on a Pendulum using DiffEqBayes.jl","title":"Bayesian Inference on a Pendulum using DiffEqBayes.jl","text":"6.027 s (40540072 allocations: 3.52 GiB)\n(posterior = NamedTuple{(:parameters, :σ),Tuple{Array{Float64,1},Array{Floa\nt64,1}}}[(parameters = [0.9925322562437633, 2.499846186491921], σ = [0.0059\n66804814045917, 0.008177933301622841]), (parameters = [0.9963837443808898, \n2.502334158254934], σ = [0.006778656235910425, 0.009222937077381753]), (par\nameters = [1.0036593578298718, 2.5036585671312954], σ = [0.0052096129327429\n53, 0.009389702547257326]), (parameters = [1.012182569162702, 2.49418373759\n8965], σ = [0.009352843917833122, 0.006784007433840137]), (parameters = [0.\n9776075654162109, 2.506917713604719], σ = [0.00819375792385741, 0.008509449\n758223278]), (parameters = [0.9711538245294002, 2.52311064587977], σ = [0.0\n08075286197741678, 0.008380689150424841]), (parameters = [1.030127379473760\n4, 2.4900769004417103], σ = [0.005671628576862689, 0.009404135319949877]), \n(parameters = [1.027662532372297, 2.47639876182845], σ = [0.005769289829077\n621, 0.010107438192968452]), (parameters = [1.02159465396289, 2.47247053938\n56765], σ = [0.005902386622399507, 0.009452950393124696]), (parameters = [1\n.022343560476168, 2.4776243412273726], σ = [0.0058799594731072675, 0.009630\n482440656476])  …  (parameters = [0.99920993073967, 2.507790860320399], σ =\n [0.011498727162582899, 0.009257041097492019]), (parameters = [1.0033967451\n562795, 2.5151332738328414], σ = [0.009519097562008954, 0.00920901544856593\n2]), (parameters = [0.9976601690281769, 2.507783954703131], σ = [0.00947878\n0454357206, 0.008575044597729732]), (parameters = [0.9944432965906622, 2.50\n63137783766347], σ = [0.006264533060570234, 0.00805770806170044]), (paramet\ners = [0.995789590567554, 2.507352981860877], σ = [0.005952805608239749, 0.\n008806071695367526]), (parameters = [1.0082385919204935, 2.497953403941628]\n, σ = [0.005182367418104671, 0.008522531747426976]), (parameters = [0.99962\n84152075758, 2.5189801260651614], σ = [0.009705763622756209, 0.010744838454\n615106]), (parameters = [1.0119656370109682, 2.494765752066562], σ = [0.004\n729975947126395, 0.007155123027207663]), (parameters = [1.0046646904759642,\n 2.4934723249796953], σ = [0.005248078221127134, 0.008421618259762318]), (p\narameters = [1.005881733899965, 2.5009460269940513], σ = [0.005481409918559\n183, 0.008388170512741225])], chain = [[-0.007495766955188785, 0.9162292045\n781582, -5.121543701879515, -4.8063158129028745], [-0.0036228100779651584, \n0.9172239595836579, -4.993976391966563, -4.686061737110957], [0.00365267866\n93412507, 0.917753088961152, -5.257249719116282, -4.66814166387209], [0.012\n108958905343204, 0.913961516396238, -4.6720748195944335, -4.993187284703021\n], [-0.022646951830213737, 0.9190539959828018, -4.804382643391568, -4.76657\n7996745424], [-0.029270404566869655, 0.9254925235842713, -4.818946968056696\n, -4.781825130348601], [0.029682463987115947, 0.9123135937112545, -5.172278\n975524333, -4.666605758791736], [0.02728683723620924, 0.9068053926743036, -\n5.155206285919641, -4.5944836714353015], [0.021364792718281282, 0.905217869\n1295568, -5.132398497592392, -4.6614283752915044], [0.022097600140248842, 0\n.9073001741472317, -5.13620540942405, -4.64282195674715]  …  [-0.0007903815\n295350864, 0.9194022302666618, -4.465518931253114, -4.682370817294514], [0.\n0033909892480041516, 0.9223257937313328, -4.654455228578712, -4.68757233469\n34475], [-0.0023425726538614036, 0.9193994765973328, -4.65869961504571, -4.\n7588990850422315], [-0.0055721993164947236, 0.9188130594802799, -5.07285122\n4845033, -4.821126122491971], [-0.004219298165150283, 0.9192276077735035, -\n5.123892639763714, -4.732313830031988], [0.008204839974368702, 0.9154717581\n833844, -5.262493296595247, -4.765041828828386], [-0.0003716538471601385, 0\n.9238541077264724, -4.63503538201953, -4.533329783471124], [0.0118946147660\n13212, 0.914194837848557, -5.353835161665349, -4.939926671543258], [0.00465\n384452294309, 0.9136762470772759, -5.249893322511043, -4.776953276823668], \n[0.0058645040311212536, 0.9166690710924666, -5.20639292670556, -4.780932837\n9729665]], tree_statistics = DynamicHMC.TreeStatisticsNUTS[DynamicHMC.TreeS\ntatisticsNUTS(50.56734359829101, 3, turning at positions -2:5, 0.9755240439\n296025, 7, DynamicHMC.Directions(0x60136a7d)), DynamicHMC.TreeStatisticsNUT\nS(53.21141797289948, 4, turning at positions -15:-30, 0.9303977362255577, 3\n1, DynamicHMC.Directions(0xf1231261)), DynamicHMC.TreeStatisticsNUTS(54.360\n60487933965, 4, turning at positions -1:14, 0.9893416328240263, 15, Dynamic\nHMC.Directions(0xe900c27e)), DynamicHMC.TreeStatisticsNUTS(52.0483617779477\n5, 5, turning at positions -21:10, 0.9309817421978657, 31, DynamicHMC.Direc\ntions(0xe9e3438a)), DynamicHMC.TreeStatisticsNUTS(49.87055132316347, 3, tur\nning at positions 11:14, 0.8572610926819243, 15, DynamicHMC.Directions(0x29\n4e978e)), DynamicHMC.TreeStatisticsNUTS(49.19262263342683, 2, turning at po\nsitions -2:1, 0.9759539124756529, 3, DynamicHMC.Directions(0xdbea4a09)), Dy\nnamicHMC.TreeStatisticsNUTS(48.43198128487201, 3, turning at positions -7:0\n, 0.981239057221168, 7, DynamicHMC.Directions(0x6fcc3a70)), DynamicHMC.Tree\nStatisticsNUTS(47.63166261616587, 2, turning at positions -3:0, 0.995085735\n1314513, 3, DynamicHMC.Directions(0xe54734a8)), DynamicHMC.TreeStatisticsNU\nTS(46.56863924159915, 3, turning at positions -5:-12, 0.905437436880739, 15\n, DynamicHMC.Directions(0xea3a9733)), DynamicHMC.TreeStatisticsNUTS(49.6833\n97905049375, 1, turning at positions -1:0, 1.0, 1, DynamicHMC.Directions(0x\n1fab498e))  …  DynamicHMC.TreeStatisticsNUTS(51.65316234412242, 4, turning \nat positions 3:18, 0.9415872806438115, 31, DynamicHMC.Directions(0xa9468a12\n)), DynamicHMC.TreeStatisticsNUTS(51.711606238318794, 3, turning at positio\nns -1:6, 0.8623986191786585, 7, DynamicHMC.Directions(0x51644e36)), Dynamic\nHMC.TreeStatisticsNUTS(51.919656641254015, 4, turning at positions -8:-23, \n0.9084259271209352, 31, DynamicHMC.Directions(0x3319ca68)), DynamicHMC.Tree\nStatisticsNUTS(53.202536402977834, 3, turning at positions 6:13, 0.96705305\n01687453, 15, DynamicHMC.Directions(0x5012713d)), DynamicHMC.TreeStatistics\nNUTS(52.73931670212959, 3, turning at positions -4:-11, 0.9929665212170776,\n 15, DynamicHMC.Directions(0x6329d9e4)), DynamicHMC.TreeStatisticsNUTS(54.1\n31036067725944, 3, turning at positions -4:-11, 0.9888188927167221, 15, Dyn\namicHMC.Directions(0x8b23b0b4)), DynamicHMC.TreeStatisticsNUTS(51.488325981\n24062, 4, turning at positions 0:15, 0.6147719493975838, 15, DynamicHMC.Dir\nections(0xfc3d19af)), DynamicHMC.TreeStatisticsNUTS(49.47067467051124, 4, t\nurning at positions -13:2, 0.9105644910181027, 15, DynamicHMC.Directions(0x\ncd45ce02)), DynamicHMC.TreeStatisticsNUTS(48.9855447707631, 3, turning at p\nositions -2:5, 0.5761761677703705, 7, DynamicHMC.Directions(0xd968714d)), D\nynamicHMC.TreeStatisticsNUTS(54.41136057897444, 3, turning at positions -3:\n4, 0.9945976434248669, 7, DynamicHMC.Directions(0x77185434))], κ = Gaussian\n kinetic energy (Diagonal), √diag(M⁻¹): [0.022077917058954552, 0.0202796088\n43069858, 0.2918638996850573, 0.24966858752333757], ϵ = 0.17395099027012478\n)","category":"page"},{"location":"model_inference/02-monte_carlo_parameter_estim/#Monte-Carlo-Parameter-Estimation-From-Data","page":"Monte Carlo Parameter Estimation From Data","title":"Monte Carlo Parameter Estimation From Data","text":"","category":"section"},{"location":"model_inference/02-monte_carlo_parameter_estim/","page":"Monte Carlo Parameter Estimation From Data","title":"Monte Carlo Parameter Estimation From Data","text":"First you want to create a problem which solves multiple problems at the same time. This is the Monte Carlo Problem. When the parameter estimation tools say it will take any DEProblem, it really means ANY DEProblem!","category":"page"},{"location":"model_inference/02-monte_carlo_parameter_estim/","page":"Monte Carlo Parameter Estimation From Data","title":"Monte Carlo Parameter Estimation From Data","text":"So, let's get a Monte Carlo problem setup that solves with 10 different initial conditions.","category":"page"},{"location":"model_inference/02-monte_carlo_parameter_estim/","page":"Monte Carlo Parameter Estimation From Data","title":"Monte Carlo Parameter Estimation From Data","text":"\nusing DifferentialEquations, DiffEqParamEstim, Plots, Optim\n\n# Monte Carlo Problem Set Up for solving set of ODEs with different initial conditions\n\n# Set up Lotka-Volterra system\nfunction pf_func(du,u,p,t)\n  du[1] = p[1] * u[1] - p[2] * u[1]*u[2]\n  du[2] = -3 * u[2] + u[1]*u[2]\nend\np = [1.5,1.0]\nprob = ODEProblem(pf_func,[1.0,1.0],(0.0,10.0),p)","category":"page"},{"location":"model_inference/02-monte_carlo_parameter_estim/","page":"Monte Carlo Parameter Estimation From Data","title":"Monte Carlo Parameter Estimation From Data","text":"ODEProblem with uType Array{Float64,1} and tType Float64. In-place: true\ntimespan: (0.0, 10.0)\nu0: [1.0, 1.0]","category":"page"},{"location":"model_inference/02-monte_carlo_parameter_estim/","page":"Monte Carlo Parameter Estimation From Data","title":"Monte Carlo Parameter Estimation From Data","text":"Now for a MonteCarloProblem we have to take this problem and tell it what to do N times via the prob_func. So let's generate N=10 different initial conditions, and tell it to run the same problem but with these 10 different initial conditions each time:","category":"page"},{"location":"model_inference/02-monte_carlo_parameter_estim/","page":"Monte Carlo Parameter Estimation From Data","title":"Monte Carlo Parameter Estimation From Data","text":"\n# Setting up to solve the problem N times (for the N different initial conditions)\nN = 10;\ninitial_conditions = [[1.0,1.0], [1.0,1.5], [1.5,1.0], [1.5,1.5], [0.5,1.0], [1.0,0.5], [0.5,0.5], [2.0,1.0], [1.0,2.0], [2.0,2.0]]\nfunction prob_func(prob,i,repeat)\n  ODEProblem(prob.f,initial_conditions[i],prob.tspan,prob.p)\nend\nmonte_prob = MonteCarloProblem(prob,prob_func=prob_func)","category":"page"},{"location":"model_inference/02-monte_carlo_parameter_estim/","page":"Monte Carlo Parameter Estimation From Data","title":"Monte Carlo Parameter Estimation From Data","text":"EnsembleProblem with problem ODEProblem","category":"page"},{"location":"model_inference/02-monte_carlo_parameter_estim/","page":"Monte Carlo Parameter Estimation From Data","title":"Monte Carlo Parameter Estimation From Data","text":"We can check this does what we want by solving it:","category":"page"},{"location":"model_inference/02-monte_carlo_parameter_estim/","page":"Monte Carlo Parameter Estimation From Data","title":"Monte Carlo Parameter Estimation From Data","text":"\n# Check above does what we want\nsim = solve(monte_prob,Tsit5(),num_monte=N)\nplot(sim)","category":"page"},{"location":"model_inference/02-monte_carlo_parameter_estim/","page":"Monte Carlo Parameter Estimation From Data","title":"Monte Carlo Parameter Estimation From Data","text":"(Image: )","category":"page"},{"location":"model_inference/02-monte_carlo_parameter_estim/","page":"Monte Carlo Parameter Estimation From Data","title":"Monte Carlo Parameter Estimation From Data","text":"nummonte=N means \"run N times\", and each time it runs the problem returned by the probfunc, which is always the same problem but with the ith initial condition.","category":"page"},{"location":"model_inference/02-monte_carlo_parameter_estim/","page":"Monte Carlo Parameter Estimation From Data","title":"Monte Carlo Parameter Estimation From Data","text":"Now let's generate a dataset from that. Let's get data points at every t=0.1 using saveat, and then convert the solution into an array.","category":"page"},{"location":"model_inference/02-monte_carlo_parameter_estim/","page":"Monte Carlo Parameter Estimation From Data","title":"Monte Carlo Parameter Estimation From Data","text":"\n# Generate a dataset from these runs\ndata_times = 0.0:0.1:10.0\nsim = solve(monte_prob,Tsit5(),num_monte=N,saveat=data_times)\ndata = Array(sim)","category":"page"},{"location":"model_inference/02-monte_carlo_parameter_estim/","page":"Monte Carlo Parameter Estimation From Data","title":"Monte Carlo Parameter Estimation From Data","text":"2×101×10 Array{Float64,3}:\n[:, :, 1] =\n 1.0  1.06108   1.14403   1.24917   1.37764   …  0.956979  0.983561  1.0337\n6\n 1.0  0.821084  0.679053  0.566893  0.478813     1.35559   1.10629   0.9063\n7\n\n[:, :, 2] =\n 1.0  1.01413  1.05394  1.11711   …  1.05324  1.01309  1.00811  1.03162\n 1.5  1.22868  1.00919  0.833191     2.08023  1.70818  1.39972  1.14802\n\n[:, :, 3] =\n 1.5  1.58801   1.70188   1.84193   2.00901   …  2.0153    2.21084   2.4358\n9\n 1.0  0.864317  0.754624  0.667265  0.599149     0.600943  0.549793  0.5136\n8\n\n[:, :, 4] =\n 1.5  1.51612  1.5621   1.63555   1.73531   …  1.83822   1.98545   2.15958\n 1.5  1.29176  1.11592  0.969809  0.850159     0.771088  0.691421  0.630025\n\n[:, :, 5] =\n 0.5  0.531705  0.576474  0.634384  0.706139  …  9.05366   9.4006   8.8391\n 1.0  0.77995   0.610654  0.480565  0.380645     0.809383  1.51708  2.82619\n\n[:, :, 6] =\n 1.0  1.11027   1.24238   1.39866   1.58195   …  0.753107  0.748814  0.7682\n84\n 0.5  0.411557  0.342883  0.289812  0.249142     1.73879   1.38829   1.1093\n2\n\n[:, :, 7] =\n 0.5  0.555757  0.623692  0.705084  0.80158   …  8.11213   9.10669   9.9216\n9\n 0.5  0.390449  0.30679   0.24286   0.193966     0.261294  0.455928  0.8787\n92\n\n[:, :, 8] =\n 2.0  2.11239   2.24921   2.41003   2.59433   …  3.22292   3.47356   3.7301\n1\n 1.0  0.909749  0.838025  0.783532  0.745339     0.739406  0.765524  0.8130\n04\n\n[:, :, 9] =\n 1.0  0.969326  0.971358  1.00017  …  1.25065  1.1012   1.01733  0.979304\n 2.0  1.63445   1.33389   1.09031     3.02672  2.52063  2.07503  1.69808\n\n[:, :, 10] =\n 2.0  1.92148  1.88215  1.87711  1.90264  …  2.15079  2.27937   2.43105\n 2.0  1.80195  1.61405  1.4426   1.2907      0.95722  0.884825  0.829478","category":"page"},{"location":"model_inference/02-monte_carlo_parameter_estim/","page":"Monte Carlo Parameter Estimation From Data","title":"Monte Carlo Parameter Estimation From Data","text":"Here, data[i,j,k] is the same as sim[i,j,k] which is the same as sim[k]i,j. So data[i,j,k] is the jth timepoint of the ith variable in the kth trajectory.","category":"page"},{"location":"model_inference/02-monte_carlo_parameter_estim/","page":"Monte Carlo Parameter Estimation From Data","title":"Monte Carlo Parameter Estimation From Data","text":"Now let's build a loss function. A loss function is some loss(sol) that spits out a scalar for how far from optimal we are. In the documentation I show that we normally do loss = L2Loss(t,data), but we can bootstrap off of this. Instead lets build an array of N loss functions, each one with the correct piece of data.","category":"page"},{"location":"model_inference/02-monte_carlo_parameter_estim/","page":"Monte Carlo Parameter Estimation From Data","title":"Monte Carlo Parameter Estimation From Data","text":"\n# Building a loss function\nlosses = [L2Loss(data_times,data[:,:,i]) for i in 1:N]","category":"page"},{"location":"model_inference/02-monte_carlo_parameter_estim/","page":"Monte Carlo Parameter Estimation From Data","title":"Monte Carlo Parameter Estimation From Data","text":"10-element Array{DiffEqParamEstim.L2Loss{StepRangeLen{Float64,Base.TwicePre\ncision{Float64},Base.TwicePrecision{Float64}},Array{Float64,2},Nothing,Noth\ning,Nothing},1}:\n DiffEqParamEstim.L2Loss{StepRangeLen{Float64,Base.TwicePrecision{Float64},\nBase.TwicePrecision{Float64}},Array{Float64,2},Nothing,Nothing,Nothing}(0.0\n:0.1:10.0, [1.0 1.0610780673356452 … 0.9835609175876878 1.03375813933372; 1\n.0 0.821084277588617 … 1.1062868012281115 0.9063703701433561], nothing, not\nhing, nothing, nothing)\n DiffEqParamEstim.L2Loss{StepRangeLen{Float64,Base.TwicePrecision{Float64},\nBase.TwicePrecision{Float64}},Array{Float64,2},Nothing,Nothing,Nothing}(0.0\n:0.1:10.0, [1.0 1.0141312263418634 … 1.0081060199159142 1.0316172446513838;\n 1.5 1.228683152066521 … 1.399724197709348 1.1480244766323144], nothing, no\nthing, nothing, nothing)\n DiffEqParamEstim.L2Loss{StepRangeLen{Float64,Base.TwicePrecision{Float64},\nBase.TwicePrecision{Float64}},Array{Float64,2},Nothing,Nothing,Nothing}(0.0\n:0.1:10.0, [1.5 1.5880106683980333 … 2.2108390928827633 2.4358900204179257;\n 1.0 0.8643172923598123 … 0.5497934554116727 0.5136795231383728], nothing, \nnothing, nothing, nothing)\n DiffEqParamEstim.L2Loss{StepRangeLen{Float64,Base.TwicePrecision{Float64},\nBase.TwicePrecision{Float64}},Array{Float64,2},Nothing,Nothing,Nothing}(0.0\n:0.1:10.0, [1.5 1.5161205353418132 … 1.98544815023441 2.159582376155923; 1.\n5 1.291763682858893 … 0.6914210407725863 0.6300249062168604], nothing, noth\ning, nothing, nothing)\n DiffEqParamEstim.L2Loss{StepRangeLen{Float64,Base.TwicePrecision{Float64},\nBase.TwicePrecision{Float64}},Array{Float64,2},Nothing,Nothing,Nothing}(0.0\n:0.1:10.0, [0.5 0.5317050732862075 … 9.40059681475263 8.839104135554038; 1.\n0 0.7799498910330318 … 1.5170828246557035 2.8261900619627034], nothing, not\nhing, nothing, nothing)\n DiffEqParamEstim.L2Loss{StepRangeLen{Float64,Base.TwicePrecision{Float64},\nBase.TwicePrecision{Float64}},Array{Float64,2},Nothing,Nothing,Nothing}(0.0\n:0.1:10.0, [1.0 1.1102743524476706 … 0.7488135727436903 0.7682835552381805;\n 0.5 0.41155721428049064 … 1.3882945275734764 1.1093238617250127], nothing,\n nothing, nothing, nothing)\n DiffEqParamEstim.L2Loss{StepRangeLen{Float64,Base.TwicePrecision{Float64},\nBase.TwicePrecision{Float64}},Array{Float64,2},Nothing,Nothing,Nothing}(0.0\n:0.1:10.0, [0.5 0.5557572700553828 … 9.106689672020078 9.92168798092248; 0.\n5 0.390449424650402 … 0.4559279494700062 0.8787916230455673], nothing, noth\ning, nothing, nothing)\n DiffEqParamEstim.L2Loss{StepRangeLen{Float64,Base.TwicePrecision{Float64},\nBase.TwicePrecision{Float64}},Array{Float64,2},Nothing,Nothing,Nothing}(0.0\n:0.1:10.0, [2.0 2.112390154025954 … 3.47356127269175 3.7301053632038483; 1.\n0 0.9097494017873065 … 0.7655239702477202 0.8130037985322804], nothing, not\nhing, nothing, nothing)\n DiffEqParamEstim.L2Loss{StepRangeLen{Float64,Base.TwicePrecision{Float64},\nBase.TwicePrecision{Float64}},Array{Float64,2},Nothing,Nothing,Nothing}(0.0\n:0.1:10.0, [1.0 0.9693256296130462 … 1.0173287701631242 0.9793042434753583;\n 2.0 1.634450182452438 … 2.075029652563485 1.6980752053964283], nothing, no\nthing, nothing, nothing)\n DiffEqParamEstim.L2Loss{StepRangeLen{Float64,Base.TwicePrecision{Float64},\nBase.TwicePrecision{Float64}},Array{Float64,2},Nothing,Nothing,Nothing}(0.0\n:0.1:10.0, [2.0 1.9214830168796073 … 2.279371218479859 2.4310471044470905; \n2.0 1.8019540594630474 … 0.8848252408869255 0.8294783000181652], nothing, n\nothing, nothing, nothing)","category":"page"},{"location":"model_inference/02-monte_carlo_parameter_estim/","page":"Monte Carlo Parameter Estimation From Data","title":"Monte Carlo Parameter Estimation From Data","text":"So losses[i] is a function which computes the loss of a solution against the data of the ith trajectory. So to build our true loss function, we sum the losses:","category":"page"},{"location":"model_inference/02-monte_carlo_parameter_estim/","page":"Monte Carlo Parameter Estimation From Data","title":"Monte Carlo Parameter Estimation From Data","text":"\nloss(sim) = sum(losses[i](sim[i]) for i in 1:N)","category":"page"},{"location":"model_inference/02-monte_carlo_parameter_estim/","page":"Monte Carlo Parameter Estimation From Data","title":"Monte Carlo Parameter Estimation From Data","text":"loss (generic function with 1 method)","category":"page"},{"location":"model_inference/02-monte_carlo_parameter_estim/","page":"Monte Carlo Parameter Estimation From Data","title":"Monte Carlo Parameter Estimation From Data","text":"As a double check, make sure that loss(sim) outputs zero (since we generated the data from sim). Now we generate data with other parameters:","category":"page"},{"location":"model_inference/02-monte_carlo_parameter_estim/","page":"Monte Carlo Parameter Estimation From Data","title":"Monte Carlo Parameter Estimation From Data","text":"\nprob = ODEProblem(pf_func,[1.0,1.0],(0.0,10.0),[1.2,0.8])\nfunction prob_func(prob,i,repeat)\n  ODEProblem(prob.f,initial_conditions[i],prob.tspan,prob.p)\nend\nmonte_prob = MonteCarloProblem(prob,prob_func=prob_func)\nsim = solve(monte_prob,Tsit5(),num_monte=N,saveat=data_times)\nloss(sim)","category":"page"},{"location":"model_inference/02-monte_carlo_parameter_estim/","page":"Monte Carlo Parameter Estimation From Data","title":"Monte Carlo Parameter Estimation From Data","text":"10108.69418531734","category":"page"},{"location":"model_inference/02-monte_carlo_parameter_estim/","page":"Monte Carlo Parameter Estimation From Data","title":"Monte Carlo Parameter Estimation From Data","text":"and get a non-zero loss. So we now have our problem, our data, and our loss function... we have what we need.","category":"page"},{"location":"model_inference/02-monte_carlo_parameter_estim/","page":"Monte Carlo Parameter Estimation From Data","title":"Monte Carlo Parameter Estimation From Data","text":"Put this into buildlossobjective.","category":"page"},{"location":"model_inference/02-monte_carlo_parameter_estim/","page":"Monte Carlo Parameter Estimation From Data","title":"Monte Carlo Parameter Estimation From Data","text":"\nobj = build_loss_objective(monte_prob,Tsit5(),loss,num_monte=N,\n                           saveat=data_times)","category":"page"},{"location":"model_inference/02-monte_carlo_parameter_estim/","page":"Monte Carlo Parameter Estimation From Data","title":"Monte Carlo Parameter Estimation From Data","text":"(::DiffEqParamEstim.DiffEqObjective{DiffEqParamEstim.var\"#43#48\"{Nothing,Bo\nol,Int64,typeof(DiffEqParamEstim.STANDARD_PROB_GENERATOR),Base.Iterators.Pa\nirs{Symbol,Any,Tuple{Symbol,Symbol},NamedTuple{(:num_monte, :saveat),Tuple{\nInt64,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision\n{Float64}}}}},DiffEqBase.EnsembleProblem{DiffEqBase.ODEProblem{Array{Float6\n4,1},Tuple{Float64,Float64},true,Array{Float64,1},DiffEqBase.ODEFunction{tr\nue,typeof(Main.##WeaveSandBox#293.pf_func),LinearAlgebra.UniformScaling{Boo\nl},Nothing,Nothing,Nothing,Nothing,Nothing,Nothing,Nothing,Nothing,Nothing,\nNothing,Nothing,Nothing},Base.Iterators.Pairs{Union{},Union{},Tuple{},Named\nTuple{(),Tuple{}}},DiffEqBase.StandardODEProblem},typeof(Main.##WeaveSandBo\nx#293.prob_func),typeof(DiffEqBase.DEFAULT_OUTPUT_FUNC),typeof(DiffEqBase.D\nEFAULT_REDUCTION),Nothing},OrdinaryDiffEq.Tsit5,typeof(Main.##WeaveSandBox#\n293.loss),Nothing,Tuple{}},DiffEqParamEstim.var\"#47#53\"{DiffEqParamEstim.va\nr\"#43#48\"{Nothing,Bool,Int64,typeof(DiffEqParamEstim.STANDARD_PROB_GENERATO\nR),Base.Iterators.Pairs{Symbol,Any,Tuple{Symbol,Symbol},NamedTuple{(:num_mo\nnte, :saveat),Tuple{Int64,StepRangeLen{Float64,Base.TwicePrecision{Float64}\n,Base.TwicePrecision{Float64}}}}},DiffEqBase.EnsembleProblem{DiffEqBase.ODE\nProblem{Array{Float64,1},Tuple{Float64,Float64},true,Array{Float64,1},DiffE\nqBase.ODEFunction{true,typeof(Main.##WeaveSandBox#293.pf_func),LinearAlgebr\na.UniformScaling{Bool},Nothing,Nothing,Nothing,Nothing,Nothing,Nothing,Noth\ning,Nothing,Nothing,Nothing,Nothing,Nothing},Base.Iterators.Pairs{Union{},U\nnion{},Tuple{},NamedTuple{(),Tuple{}}},DiffEqBase.StandardODEProblem},typeo\nf(Main.##WeaveSandBox#293.prob_func),typeof(DiffEqBase.DEFAULT_OUTPUT_FUNC)\n,typeof(DiffEqBase.DEFAULT_REDUCTION),Nothing},OrdinaryDiffEq.Tsit5,typeof(\nMain.##WeaveSandBox#293.loss),Nothing,Tuple{}}}}) (generic function with 2 \nmethods)","category":"page"},{"location":"model_inference/02-monte_carlo_parameter_estim/","page":"Monte Carlo Parameter Estimation From Data","title":"Monte Carlo Parameter Estimation From Data","text":"Notice that I added the kwargs for solve into this. They get passed to an internal solve command, so then the loss is computed on N trajectories at data_times.","category":"page"},{"location":"model_inference/02-monte_carlo_parameter_estim/","page":"Monte Carlo Parameter Estimation From Data","title":"Monte Carlo Parameter Estimation From Data","text":"Thus we take this objective function over to any optimization package. I like to do quick things in Optim.jl. Here, since the Lotka-Volterra equation requires positive parameters, I use Fminbox to make sure the parameters stay positive. I start the optimization with [1.3,0.9], and Optim spits out that the true parameters are:","category":"page"},{"location":"model_inference/02-monte_carlo_parameter_estim/","page":"Monte Carlo Parameter Estimation From Data","title":"Monte Carlo Parameter Estimation From Data","text":"\nlower = zeros(2)\nupper = fill(2.0,2)\nresult = optimize(obj, lower, upper, [1.3,0.9], Fminbox(BFGS()))","category":"page"},{"location":"model_inference/02-monte_carlo_parameter_estim/","page":"Monte Carlo Parameter Estimation From Data","title":"Monte Carlo Parameter Estimation From Data","text":"* Status: success\n\n * Candidate solution\n    Final objective value:     3.530023e-13\n\n * Found with\n    Algorithm:     Fminbox with BFGS\n\n * Convergence measures\n    |x - x'|               = 0.00e+00 ≤ 0.0e+00\n    |x - x'|/|x'|          = 0.00e+00 ≤ 0.0e+00\n    |f(x) - f(x')|         = 0.00e+00 ≤ 0.0e+00\n    |f(x) - f(x')|/|f(x')| = 0.00e+00 ≤ 0.0e+00\n    |g(x)|                 = 1.09e-05 ≰ 1.0e-08\n\n * Work counters\n    Seconds run:   61  (vs limit Inf)\n    Iterations:    9\n    f(x) calls:    46080\n    ∇f(x) calls:   46080","category":"page"},{"location":"model_inference/02-monte_carlo_parameter_estim/","page":"Monte Carlo Parameter Estimation From Data","title":"Monte Carlo Parameter Estimation From Data","text":"\nresult","category":"page"},{"location":"model_inference/02-monte_carlo_parameter_estim/","page":"Monte Carlo Parameter Estimation From Data","title":"Monte Carlo Parameter Estimation From Data","text":"* Status: success\n\n * Candidate solution\n    Final objective value:     3.530023e-13\n\n * Found with\n    Algorithm:     Fminbox with BFGS\n\n * Convergence measures\n    |x - x'|               = 0.00e+00 ≤ 0.0e+00\n    |x - x'|/|x'|          = 0.00e+00 ≤ 0.0e+00\n    |f(x) - f(x')|         = 0.00e+00 ≤ 0.0e+00\n    |f(x) - f(x')|/|f(x')| = 0.00e+00 ≤ 0.0e+00\n    |g(x)|                 = 1.09e-05 ≰ 1.0e-08\n\n * Work counters\n    Seconds run:   61  (vs limit Inf)\n    Iterations:    9\n    f(x) calls:    46080\n    ∇f(x) calls:   46080","category":"page"},{"location":"model_inference/02-monte_carlo_parameter_estim/","page":"Monte Carlo Parameter Estimation From Data","title":"Monte Carlo Parameter Estimation From Data","text":"Optim finds one but not the other parameter.","category":"page"},{"location":"model_inference/02-monte_carlo_parameter_estim/","page":"Monte Carlo Parameter Estimation From Data","title":"Monte Carlo Parameter Estimation From Data","text":"I would run a test on synthetic data for your problem before using it on real data. Maybe play around with different optimization packages, or add regularization. You may also want to decrease the tolerance of the ODE solvers via","category":"page"},{"location":"model_inference/02-monte_carlo_parameter_estim/","page":"Monte Carlo Parameter Estimation From Data","title":"Monte Carlo Parameter Estimation From Data","text":"\nobj = build_loss_objective(monte_prob,Tsit5(),loss,num_monte=N,\n                           abstol=1e-8,reltol=1e-8,\n                           saveat=data_times)\nresult = optimize(obj, lower, upper, [1.3,0.9], Fminbox(BFGS()))","category":"page"},{"location":"model_inference/02-monte_carlo_parameter_estim/","page":"Monte Carlo Parameter Estimation From Data","title":"Monte Carlo Parameter Estimation From Data","text":"* Status: success\n\n * Candidate solution\n    Final objective value:     4.155346e-02\n\n * Found with\n    Algorithm:     Fminbox with BFGS\n\n * Convergence measures\n    |x - x'|               = 3.84e-14 ≰ 0.0e+00\n    |x - x'|/|x'|          = 2.13e-14 ≰ 0.0e+00\n    |f(x) - f(x')|         = 0.00e+00 ≤ 0.0e+00\n    |f(x) - f(x')|/|f(x')| = 0.00e+00 ≤ 0.0e+00\n    |g(x)|                 = 2.92e-09 ≤ 1.0e-08\n\n * Work counters\n    Seconds run:   1  (vs limit Inf)\n    Iterations:    5\n    f(x) calls:    46\n    ∇f(x) calls:   46","category":"page"},{"location":"model_inference/02-monte_carlo_parameter_estim/","page":"Monte Carlo Parameter Estimation From Data","title":"Monte Carlo Parameter Estimation From Data","text":"\nresult","category":"page"},{"location":"model_inference/02-monte_carlo_parameter_estim/","page":"Monte Carlo Parameter Estimation From Data","title":"Monte Carlo Parameter Estimation From Data","text":"* Status: success\n\n * Candidate solution\n    Final objective value:     4.155346e-02\n\n * Found with\n    Algorithm:     Fminbox with BFGS\n\n * Convergence measures\n    |x - x'|               = 3.84e-14 ≰ 0.0e+00\n    |x - x'|/|x'|          = 2.13e-14 ≰ 0.0e+00\n    |f(x) - f(x')|         = 0.00e+00 ≤ 0.0e+00\n    |f(x) - f(x')|/|f(x')| = 0.00e+00 ≤ 0.0e+00\n    |g(x)|                 = 2.92e-09 ≤ 1.0e-08\n\n * Work counters\n    Seconds run:   1  (vs limit Inf)\n    Iterations:    5\n    f(x) calls:    46\n    ∇f(x) calls:   46","category":"page"},{"location":"model_inference/02-monte_carlo_parameter_estim/","page":"Monte Carlo Parameter Estimation From Data","title":"Monte Carlo Parameter Estimation From Data","text":"if you suspect error is the problem. However, if you're having problems it's most likely not the ODE solver tolerance and mostly because parameter inference is a very hard optimization problem.","category":"page"},{"location":"model_inference/02-monte_carlo_parameter_estim/#Appendix","page":"Monte Carlo Parameter Estimation From Data","title":"Appendix","text":"","category":"section"},{"location":"model_inference/02-monte_carlo_parameter_estim/","page":"Monte Carlo Parameter Estimation From Data","title":"Monte Carlo Parameter Estimation From Data","text":"This tutorial is part of the SciMLTutorials.jl repository, found at: https://github.com/SciML/SciMLTutorials.jl.  For more information on doing scientific machine learning (SciML) with open source software, check out https://sciml.ai/.","category":"page"},{"location":"model_inference/02-monte_carlo_parameter_estim/","page":"Monte Carlo Parameter Estimation From Data","title":"Monte Carlo Parameter Estimation From Data","text":"To locally run this tutorial, do the following commands:","category":"page"},{"location":"model_inference/02-monte_carlo_parameter_estim/","page":"Monte Carlo Parameter Estimation From Data","title":"Monte Carlo Parameter Estimation From Data","text":"using SciMLTutorials\nSciMLTutorials.weave_file(\"model_inference\",\"02-monte_carlo_parameter_estim.jmd\")","category":"page"},{"location":"model_inference/02-monte_carlo_parameter_estim/","page":"Monte Carlo Parameter Estimation From Data","title":"Monte Carlo Parameter Estimation From Data","text":"Computer Information:","category":"page"},{"location":"model_inference/02-monte_carlo_parameter_estim/","page":"Monte Carlo Parameter Estimation From Data","title":"Monte Carlo Parameter Estimation From Data","text":"Julia Version 1.4.2\nCommit 44fa15b150* (2020-05-23 18:35 UTC)\nPlatform Info:\n  OS: Linux (x86_64-pc-linux-gnu)\n  CPU: Intel(R) Core(TM) i7-9700K CPU @ 3.60GHz\n  WORD_SIZE: 64\n  LIBM: libopenlibm\n  LLVM: libLLVM-8.0.1 (ORCJIT, skylake)\nEnvironment:\n  JULIA_LOAD_PATH = /builds/JuliaGPU/DiffEqTutorials.jl:\n  JULIA_DEPOT_PATH = /builds/JuliaGPU/DiffEqTutorials.jl/.julia\n  JULIA_CUDA_MEMORY_LIMIT = 2147483648\n  JULIA_NUM_THREADS = 8\n","category":"page"},{"location":"model_inference/02-monte_carlo_parameter_estim/","page":"Monte Carlo Parameter Estimation From Data","title":"Monte Carlo Parameter Estimation From Data","text":"Package Information:","category":"page"},{"location":"model_inference/02-monte_carlo_parameter_estim/","page":"Monte Carlo Parameter Estimation From Data","title":"Monte Carlo Parameter Estimation From Data","text":"Status `/builds/JuliaGPU/DiffEqTutorials.jl/tutorials/model_inference/Project.toml`\n[6e4b80f9-dd63-53aa-95a3-0cdb28fa8baf] BenchmarkTools 0.5.0\n[593b3428-ca2f-500c-ae53-031589ec8ddd] CmdStan 6.0.8\n[ebbdde9d-f333-5424-9be2-dbf1e9acfb5e] DiffEqBayes 2.17.0\n[1130ab10-4a5a-5621-a13d-e4788d82bd4c] DiffEqParamEstim 1.17.0\n[0c46a032-eb83-5123-abaf-570d42b7fbaa] DifferentialEquations 6.15.0\n[31c24e10-a181-5473-b8eb-7969acd0382f] Distributions 0.23.12\n[bbc10e6e-7c05-544b-b16e-64fede858acb] DynamicHMC 2.2.0\n[429524aa-4258-5aef-a3af-852621145aeb] Optim 1.2.0\n[1dea7af3-3e70-54e6-95c3-0bf5283fa5ed] OrdinaryDiffEq 5.42.8\n[91a5bcdd-55d7-5caf-9e0b-520d859cae80] Plots 1.6.5\n[731186ca-8d62-57ce-b412-fbd966d074cd] RecursiveArrayTools 2.7.0\n[f3b207a7-027a-5e70-b257-86293d7955fd] StatsPlots 0.14.13\n[84d833dd-6860-57f9-a1a7-6da5db126cff] TransformVariables 0.3.10","category":"page"},{"location":"models/02-conditional_dosing/#Conditional-Dosing-Pharmacometric-Example","page":"Conditional Dosing Pharmacometric Example","title":"Conditional Dosing Pharmacometric Example","text":"","category":"section"},{"location":"models/02-conditional_dosing/","page":"Conditional Dosing Pharmacometric Example","title":"Conditional Dosing Pharmacometric Example","text":"In this example we will show how to model a conditional dosing using the DiscreteCallbacks. The problem is as follows. The patient has a drug A(t) in their system. The concentration of the drug is given as C(t)=A(t)/V for some volume constant V. At t=4, the patient goes to the clinic and is checked. If the concentration of the drug in their body is below 4, then they will receive a new dose.","category":"page"},{"location":"models/02-conditional_dosing/","page":"Conditional Dosing Pharmacometric Example","title":"Conditional Dosing Pharmacometric Example","text":"For our model, we will use the simple decay equation. We will write this in the in-place form to make it easy to extend to more complicated examples:","category":"page"},{"location":"models/02-conditional_dosing/","page":"Conditional Dosing Pharmacometric Example","title":"Conditional Dosing Pharmacometric Example","text":"using DifferentialEquations\nfunction f(du,u,p,t)\n    du[1] = -u[1]\nend\nu0 = [10.0]\nconst V = 1\nprob = ODEProblem(f,u0,(0.0,10.0))","category":"page"},{"location":"models/02-conditional_dosing/","page":"Conditional Dosing Pharmacometric Example","title":"Conditional Dosing Pharmacometric Example","text":"ODEProblem with uType Vector{Float64} and tType Float64. In-place: true\ntimespan: (0.0, 10.0)\nu0: 1-element Vector{Float64}:\n 10.0","category":"page"},{"location":"models/02-conditional_dosing/","page":"Conditional Dosing Pharmacometric Example","title":"Conditional Dosing Pharmacometric Example","text":"Let's see what the solution looks like without any events.","category":"page"},{"location":"models/02-conditional_dosing/","page":"Conditional Dosing Pharmacometric Example","title":"Conditional Dosing Pharmacometric Example","text":"sol = solve(prob,Tsit5())\nusing Plots; gr()\nplot(sol)","category":"page"},{"location":"models/02-conditional_dosing/","page":"Conditional Dosing Pharmacometric Example","title":"Conditional Dosing Pharmacometric Example","text":"(Image: )","category":"page"},{"location":"models/02-conditional_dosing/","page":"Conditional Dosing Pharmacometric Example","title":"Conditional Dosing Pharmacometric Example","text":"We see that at time t=4, the patient should receive a dose. Let's code up that event. We need to check at t=4 if the concentration u[1]/4 is <4, and if so, add 10 to u[1]. We do this with the following:","category":"page"},{"location":"models/02-conditional_dosing/","page":"Conditional Dosing Pharmacometric Example","title":"Conditional Dosing Pharmacometric Example","text":"condition(u,t,integrator) = t==4 && u[1]/V<4\naffect!(integrator) = integrator.u[1] += 10\ncb = DiscreteCallback(condition,affect!)","category":"page"},{"location":"models/02-conditional_dosing/","page":"Conditional Dosing Pharmacometric Example","title":"Conditional Dosing Pharmacometric Example","text":"SciMLBase.DiscreteCallback{typeof(Main.var\"##WeaveSandBox#686\".condition), \ntypeof(Main.var\"##WeaveSandBox#686\".affect!), typeof(SciMLBase.INITIALIZE_D\nEFAULT), typeof(SciMLBase.FINALIZE_DEFAULT)}(Main.var\"##WeaveSandBox#686\".c\nondition, Main.var\"##WeaveSandBox#686\".affect!, SciMLBase.INITIALIZE_DEFAUL\nT, SciMLBase.FINALIZE_DEFAULT, Bool[1, 1])","category":"page"},{"location":"models/02-conditional_dosing/","page":"Conditional Dosing Pharmacometric Example","title":"Conditional Dosing Pharmacometric Example","text":"Now we will give this callback to the solver, and tell it to stop at t=4 so that way the condition can be checked:","category":"page"},{"location":"models/02-conditional_dosing/","page":"Conditional Dosing Pharmacometric Example","title":"Conditional Dosing Pharmacometric Example","text":"sol = solve(prob,Tsit5(),tstops=[4.0],callback=cb)\nusing Plots; gr()\nplot(sol)","category":"page"},{"location":"models/02-conditional_dosing/","page":"Conditional Dosing Pharmacometric Example","title":"Conditional Dosing Pharmacometric Example","text":"(Image: )","category":"page"},{"location":"models/02-conditional_dosing/","page":"Conditional Dosing Pharmacometric Example","title":"Conditional Dosing Pharmacometric Example","text":"Let's show that it actually added 10 instead of setting the value to 10. We could have set the value using affect!(integrator) = integrator.u[1] = 10","category":"page"},{"location":"models/02-conditional_dosing/","page":"Conditional Dosing Pharmacometric Example","title":"Conditional Dosing Pharmacometric Example","text":"println(sol(4.00000))\nprintln(sol(4.000000000001))","category":"page"},{"location":"models/02-conditional_dosing/","page":"Conditional Dosing Pharmacometric Example","title":"Conditional Dosing Pharmacometric Example","text":"[0.18316389221855156]\n[10.183163892208368]","category":"page"},{"location":"models/02-conditional_dosing/","page":"Conditional Dosing Pharmacometric Example","title":"Conditional Dosing Pharmacometric Example","text":"Now let's model a patient whose decay rate for the drug is lower:","category":"page"},{"location":"models/02-conditional_dosing/","page":"Conditional Dosing Pharmacometric Example","title":"Conditional Dosing Pharmacometric Example","text":"function f(du,u,p,t)\n    du[1] = -u[1]/6\nend\nu0 = [10.0]\nconst V = 1\nprob = ODEProblem(f,u0,(0.0,10.0))","category":"page"},{"location":"models/02-conditional_dosing/","page":"Conditional Dosing Pharmacometric Example","title":"Conditional Dosing Pharmacometric Example","text":"ODEProblem with uType Vector{Float64} and tType Float64. In-place: true\ntimespan: (0.0, 10.0)\nu0: 1-element Vector{Float64}:\n 10.0","category":"page"},{"location":"models/02-conditional_dosing/","page":"Conditional Dosing Pharmacometric Example","title":"Conditional Dosing Pharmacometric Example","text":"sol = solve(prob,Tsit5())\nusing Plots; gr()\nplot(sol)","category":"page"},{"location":"models/02-conditional_dosing/","page":"Conditional Dosing Pharmacometric Example","title":"Conditional Dosing Pharmacometric Example","text":"(Image: )","category":"page"},{"location":"models/02-conditional_dosing/","page":"Conditional Dosing Pharmacometric Example","title":"Conditional Dosing Pharmacometric Example","text":"Under the same criteria, with the same event, this patient will not receive a second dose:","category":"page"},{"location":"models/02-conditional_dosing/","page":"Conditional Dosing Pharmacometric Example","title":"Conditional Dosing Pharmacometric Example","text":"sol = solve(prob,Tsit5(),tstops=[4.0],callback=cb)\nusing Plots; gr()\nplot(sol)","category":"page"},{"location":"models/02-conditional_dosing/","page":"Conditional Dosing Pharmacometric Example","title":"Conditional Dosing Pharmacometric Example","text":"(Image: )","category":"page"},{"location":"models/02-conditional_dosing/#Appendix","page":"Conditional Dosing Pharmacometric Example","title":"Appendix","text":"","category":"section"},{"location":"models/02-conditional_dosing/","page":"Conditional Dosing Pharmacometric Example","title":"Conditional Dosing Pharmacometric Example","text":"These tutorials are a part of the SciMLTutorials.jl repository, found at: https://github.com/SciML/SciMLTutorials.jl. For more information on high-performance scientific machine learning, check out the SciML Open Source Software Organization https://sciml.ai.","category":"page"},{"location":"models/02-conditional_dosing/","page":"Conditional Dosing Pharmacometric Example","title":"Conditional Dosing Pharmacometric Example","text":"To locally run this tutorial, do the following commands:","category":"page"},{"location":"models/02-conditional_dosing/","page":"Conditional Dosing Pharmacometric Example","title":"Conditional Dosing Pharmacometric Example","text":"using SciMLTutorials\nSciMLTutorials.weave_file(\"tutorials/models\",\"02-conditional_dosing.jmd\")","category":"page"},{"location":"models/02-conditional_dosing/","page":"Conditional Dosing Pharmacometric Example","title":"Conditional Dosing Pharmacometric Example","text":"Computer Information:","category":"page"},{"location":"models/02-conditional_dosing/","page":"Conditional Dosing Pharmacometric Example","title":"Conditional Dosing Pharmacometric Example","text":"Julia Version 1.8.0\nCommit 5544a0fab76 (2022-08-17 13:38 UTC)\nPlatform Info:\n  OS: Linux (x86_64-linux-gnu)\n  CPU: 128 × AMD EPYC 7502 32-Core Processor\n  WORD_SIZE: 64\n  LIBM: libopenlibm\n  LLVM: libLLVM-13.0.1 (ORCJIT, znver2)\n  Threads: 1 on 128 virtual cores\nEnvironment:\n  JULIA_CPU_THREADS = 128\n  JULIA_DEPOT_PATH = /cache/julia-buildkite-plugin/depots/a6029d3a-f78b-41ea-bc97-28aa57c6c6ea\n","category":"page"},{"location":"models/02-conditional_dosing/","page":"Conditional Dosing Pharmacometric Example","title":"Conditional Dosing Pharmacometric Example","text":"Package Information:","category":"page"},{"location":"models/02-conditional_dosing/","page":"Conditional Dosing Pharmacometric Example","title":"Conditional Dosing Pharmacometric Example","text":"Status `/cache/build/exclusive-amdci1-0/julialang/scimltutorials-dot-jl/tutorials/models/Project.toml`\n  [479239e8] Catalyst v12.2.1\n  [459566f4] DiffEqCallbacks v2.24.1\n  [f3b72e0c] DiffEqDevTools v2.31.2\n  [055956cb] DiffEqPhysics v3.9.0\n  [0c46a032] DifferentialEquations v7.3.0\n  [31c24e10] Distributions v0.25.70\n  [587475ba] Flux v0.13.5\n  [f6369f11] ForwardDiff v0.10.32\n  [23fbe1c1] Latexify v0.15.16\n  [961ee093] ModelingToolkit v8.21.0\n  [2774e3e8] NLsolve v4.5.1\n⌅ [315f7962] NeuralPDE v4.11.0\n  [429524aa] Optim v1.7.2\n  [1dea7af3] OrdinaryDiffEq v6.26.2\n  [91a5bcdd] Plots v1.32.0\n  [731186ca] RecursiveArrayTools v2.32.0\n  [30cb0354] SciMLTutorials v1.0.0\n  [789caeaf] StochasticDiffEq v6.53.0\n  [37e2e46d] LinearAlgebra\n  [2f01184e] SparseArrays\nInfo Packages marked with ⌅ have new versions available but cannot be upgraded. To see why use `status --outdated`","category":"page"},{"location":"models/02-conditional_dosing/","page":"Conditional Dosing Pharmacometric Example","title":"Conditional Dosing Pharmacometric Example","text":"And the full manifest:","category":"page"},{"location":"models/02-conditional_dosing/","page":"Conditional Dosing Pharmacometric Example","title":"Conditional Dosing Pharmacometric Example","text":"Status `/cache/build/exclusive-amdci1-0/julialang/scimltutorials-dot-jl/tutorials/models/Manifest.toml`\n  [c3fe647b] AbstractAlgebra v0.27.4\n  [621f4979] AbstractFFTs v1.2.1\n  [1520ce14] AbstractTrees v0.4.2\n  [7d9f7c33] Accessors v0.1.20\n  [79e6a3ab] Adapt v3.4.0\n  [dce04be8] ArgCheck v2.3.0\n  [ec485272] ArnoldiMethod v0.2.0\n  [4fba245c] ArrayInterface v6.0.23\n  [30b0a656] ArrayInterfaceCore v0.1.20\n  [6ba088a2] ArrayInterfaceGPUArrays v0.2.1\n  [015c0d05] ArrayInterfaceOffsetArrays v0.1.6\n  [b0d46f97] ArrayInterfaceStaticArrays v0.1.4\n  [dd5226c6] ArrayInterfaceStaticArraysCore v0.1.0\n  [a2b0951a] ArrayInterfaceTracker v0.1.1\n  [4c555306] ArrayLayouts v0.8.11\n  [15f4f7f2] AutoHashEquals v0.2.0\n  [ab4f0b2a] BFloat16s v0.2.0\n  [aae01518] BandedMatrices v0.17.6\n  [198e06fe] BangBang v0.3.36\n  [9718e550] Baselet v0.1.1\n  [e2ed5e7c] Bijections v0.1.4\n  [62783981] BitTwiddlingConvenienceFunctions v0.1.4\n  [8e7c35d0] BlockArrays v0.16.20\n  [ffab5731] BlockBandedMatrices v0.11.9\n  [764a87c0] BoundaryValueDiffEq v2.9.0\n  [fa961155] CEnum v0.4.2\n  [2a0fbf3d] CPUSummary v0.1.25\n  [00ebfdb7] CSTParser v3.3.6\n  [052768ef] CUDA v3.12.0\n  [49dc2e85] Calculus v0.5.1\n  [7057c7e9] Cassette v0.3.10\n  [479239e8] Catalyst v12.2.1\n  [082447d4] ChainRules v1.44.6\n  [d360d2e6] ChainRulesCore v1.15.4\n  [9e997f8a] ChangesOfVariables v0.1.4\n  [fb6a15b2] CloseOpenIntervals v0.1.10\n  [944b1d66] CodecZlib v0.7.0\n  [35d6a980] ColorSchemes v3.19.0\n  [3da002f7] ColorTypes v0.11.4\n  [c3611d14] ColorVectorSpace v0.9.9\n  [5ae59095] Colors v0.12.8\n  [861a8166] Combinatorics v1.0.2\n  [a80b9123] CommonMark v0.8.6\n  [38540f10] CommonSolve v0.2.1\n  [bbf7d656] CommonSubexpressions v0.3.0\n⌅ [34da2185] Compat v3.46.0\n  [b0b7db55] ComponentArrays v0.13.2\n  [b152e2b5] CompositeTypes v0.1.2\n  [a33af91c] CompositionsBase v0.1.1\n  [8f4d0f93] Conda v1.7.0\n  [88cd18e8] ConsoleProgressMonitor v0.1.2\n  [187b0558] ConstructionBase v1.4.1\n  [6add18c4] ContextVariablesX v0.1.2\n  [d38c429a] Contour v0.6.2\n  [adafc99b] CpuId v0.3.1\n  [a8cc5b0e] Crayons v4.1.1\n  [8a292aeb] Cuba v2.2.0\n  [667455a9] Cubature v1.5.1\n  [9a962f9c] DataAPI v1.10.0\n  [82cc6244] DataInterpolations v3.10.1\n  [864edb3b] DataStructures v0.18.13\n  [e2d170a0] DataValueInterfaces v1.0.0\n  [244e2a9f] DefineSingletons v0.1.2\n  [bcd4f6db] DelayDiffEq v5.37.1\n  [b429d917] DensityInterface v0.4.0\n  [2b5f629d] DiffEqBase v6.100.0\n  [459566f4] DiffEqCallbacks v2.24.1\n  [f3b72e0c] DiffEqDevTools v2.31.2\n  [aae7a2af] DiffEqFlux v1.52.0\n  [77a26b50] DiffEqNoiseProcess v5.12.3\n  [9fdde737] DiffEqOperators v4.43.1\n  [055956cb] DiffEqPhysics v3.9.0\n  [41bf760c] DiffEqSensitivity v6.79.0\n  [163ba53b] DiffResults v1.0.3\n  [b552c78f] DiffRules v1.11.1\n  [0c46a032] DifferentialEquations v7.3.0\n  [b4f34e82] Distances v0.10.7\n  [31c24e10] Distributions v0.25.70\n  [ced4e74d] DistributionsAD v0.6.42\n⌅ [ffbed154] DocStringExtensions v0.8.6\n  [5b8099bc] DomainSets v0.5.13\n  [fa6b7ba4] DualNumbers v0.6.8\n  [7c1d4256] DynamicPolynomials v0.4.5\n  [da5c29d0] EllipsisNotation v1.6.0\n  [7da242da] Enzyme v0.10.4\n  [d4d017d3] ExponentialUtilities v1.18.0\n  [e2ba6199] ExprTools v0.1.8\n  [411431e0] Extents v0.1.1\n  [c87230d0] FFMPEG v0.4.1\n  [cc61a311] FLoops v0.2.0\n  [b9860ae5] FLoopsBase v0.1.1\n  [7034ab61] FastBroadcast v0.2.1\n  [9aa1b823] FastClosures v0.3.2\n  [29a986be] FastLapackInterface v1.2.6\n  [1a297f60] FillArrays v0.13.4\n⌃ [6a86dc24] FiniteDiff v2.13.1\n  [53c48c17] FixedPointNumbers v0.8.4\n  [587475ba] Flux v0.13.5\n  [9c68100b] FoldsThreads v0.1.1\n  [59287772] Formatting v0.4.2\n  [f6369f11] ForwardDiff v0.10.32\n  [069b7b12] FunctionWrappers v1.1.2\n  [77dc65aa] FunctionWrappersWrappers v0.1.1\n  [d9f16b24] Functors v0.3.0\n  [0c68f7d7] GPUArrays v8.5.0\n  [46192b85] GPUArraysCore v0.1.2\n  [61eb1bfa] GPUCompiler v0.16.3\n  [28b8d3ca] GR v0.66.2\n  [c145ed77] GenericSchur v0.5.3\n  [cf35fbd7] GeoInterface v1.0.1\n  [5c1252a2] GeometryBasics v0.4.3\n  [86223c79] Graphs v1.7.2\n  [42e2da0e] Grisu v1.0.2\n  [0b43b601] Groebner v0.2.10\n  [d5909c97] GroupsCore v0.4.0\n  [19dc6840] HCubature v1.5.0\n  [cd3eb016] HTTP v1.3.3\n⌅ [eafb193a] Highlights v0.4.5\n  [3e5b6fbb] HostCPUFeatures v0.1.8\n  [34004b35] HypergeometricFunctions v0.3.11\n  [7073ff75] IJulia v1.23.3\n  [7869d1d1] IRTools v0.4.6\n  [615f187c] IfElse v0.1.1\n  [d25df0c9] Inflate v0.1.3\n  [83e8ac13] IniFile v0.5.1\n  [22cec73e] InitialValues v0.3.1\n  [18e54dd8] IntegerMathUtils v0.1.0\n  [8197267c] IntervalSets v0.7.2\n  [3587e190] InverseFunctions v0.1.7\n  [92d709cd] IrrationalConstants v0.1.1\n  [c8e1da08] IterTools v1.4.0\n  [42fd0dbc] IterativeSolvers v0.9.2\n  [82899510] IteratorInterfaceExtensions v1.0.0\n  [692b3bcd] JLLWrappers v1.4.1\n  [682c06a0] JSON v0.21.3\n  [98e50ef6] JuliaFormatter v1.0.9\n  [b14d175d] JuliaVariables v0.2.4\n  [ccbc3e58] JumpProcesses v9.2.0\n  [ef3ab10e] KLU v0.3.0\n  [ba0b0d4f] Krylov v0.8.3\n  [0b1a1467] KrylovKit v0.5.4\n  [929cbde3] LLVM v4.14.0\n  [b964fa9f] LaTeXStrings v1.3.0\n  [2ee39098] LabelledArrays v1.12.0\n  [23fbe1c1] Latexify v0.15.16\n  [a5e1c1ea] LatinHypercubeSampling v1.8.0\n  [73f95e8e] LatticeRules v0.0.1\n  [10f19ff3] LayoutPointers v0.1.10\n  [50d2b5c4] Lazy v0.15.1\n  [5078a376] LazyArrays v0.22.11\n⌅ [d7e5e226] LazyBandedMatrices v0.7.17\n  [0fc2ff8b] LeastSquaresOptim v0.8.3\n  [1d6d02ad] LeftChildRightSiblingTrees v0.2.0\n  [2d8b4e74] LevyArea v1.0.0\n  [d3d80556] LineSearches v7.2.0\n  [7ed4a6bd] LinearSolve v1.26.0\n  [2ab3a3ac] LogExpFunctions v0.3.18\n  [e6f89c97] LoggingExtras v0.4.9\n  [bdcacae8] LoopVectorization v0.12.125\n  [b2108857] Lux v0.4.21\n  [d8e11817] MLStyle v0.4.13\n  [f1d291b0] MLUtils v0.2.10\n  [1914dd2f] MacroTools v0.5.9\n  [d125e4d3] ManualMemory v0.1.8\n  [a3b82374] MatrixFactorizations v0.9.2\n  [739be429] MbedTLS v1.1.5\n  [442fdcdd] Measures v0.3.1\n  [c03570c3] Memoize v0.4.4\n  [e9d8d322] Metatheory v1.3.4\n  [128add7d] MicroCollections v0.1.2\n  [e1d29d7a] Missings v1.0.2\n  [961ee093] ModelingToolkit v8.21.0\n⌅ [4886b29c] MonteCarloIntegration v0.0.3\n  [46d2c3a1] MuladdMacro v0.2.2\n  [102ac46a] MultivariatePolynomials v0.4.6\n  [ffc61752] Mustache v1.0.14\n  [d8a4904e] MutableArithmetics v1.0.4\n  [d41bc354] NLSolversBase v7.8.2\n  [2774e3e8] NLsolve v4.5.1\n  [872c559c] NNlib v0.8.9\n  [a00861dc] NNlibCUDA v0.2.4\n  [77ba4419] NaNMath v1.0.1\n  [71a1bf82] NameResolution v0.1.5\n⌅ [315f7962] NeuralPDE v4.11.0\n  [8913a72c] NonlinearSolve v0.3.22\n  [d8793406] ObjectFile v0.3.7\n  [6fe1bfb0] OffsetArrays v1.12.7\n  [429524aa] Optim v1.7.2\n  [3bd65402] Optimisers v0.2.9\n  [7f7a1694] Optimization v3.8.2\n  [253f991c] OptimizationFlux v0.1.0\n  [36348300] OptimizationOptimJL v0.1.2\n  [42dfb2eb] OptimizationOptimisers v0.1.0\n  [500b13db] OptimizationPolyalgorithms v0.1.0\n  [bac558e1] OrderedCollections v1.4.1\n  [1dea7af3] OrdinaryDiffEq v6.26.2\n  [90014a1f] PDMats v0.11.16\n  [d96e819e] Parameters v0.12.3\n  [69de0a69] Parsers v2.4.0\n  [ccf2f8ad] PlotThemes v3.0.0\n  [995b91a9] PlotUtils v1.3.0\n  [91a5bcdd] Plots v1.32.0\n  [e409e4f3] PoissonRandom v0.4.1\n  [f517fe37] Polyester v0.6.15\n  [1d0040c9] PolyesterWeave v0.1.9\n  [85a6dd25] PositiveFactorizations v0.2.4\n  [d236fae5] PreallocationTools v0.4.2\n  [21216c6a] Preferences v1.3.0\n  [8162dcfd] PrettyPrint v0.2.0\n  [27ebfcd6] Primes v0.5.3\n  [33c8b6b6] ProgressLogging v0.1.4\n  [92933f4c] ProgressMeter v1.7.2\n  [1fd47b50] QuadGK v2.5.0\n  [67601950] Quadrature v2.1.0\n  [e0ec9b62] QuadratureCubature v0.1.1\n  [8a4e6c94] QuasiMonteCarlo v0.2.9\n  [74087812] Random123 v1.6.0\n  [fb686558] RandomExtensions v0.4.3\n  [e6cf234a] RandomNumbers v1.5.3\n  [c1ae055f] RealDot v0.1.0\n  [3cdcf5f2] RecipesBase v1.2.1\n  [01d81517] RecipesPipeline v0.6.3\n  [731186ca] RecursiveArrayTools v2.32.0\n  [f2c3362d] RecursiveFactorization v0.2.12\n  [189a3867] Reexport v1.2.2\n  [42d2dcc6] Referenceables v0.1.2\n  [29dad682] RegularizationTools v0.6.0\n⌅ [05181044] RelocatableFolders v0.3.0\n  [ae029012] Requires v1.3.0\n  [ae5879a3] ResettableStacks v1.1.1\n  [37e2e3b7] ReverseDiff v1.14.1\n  [79098fc4] Rmath v0.7.0\n  [47965b36] RootedTrees v2.13.0\n  [7e49a35a] RuntimeGeneratedFunctions v0.5.3\n  [3cdde19b] SIMDDualNumbers v0.1.1\n  [94e857df] SIMDTypes v0.1.0\n  [476501e8] SLEEFPirates v0.6.35\n  [0bca4576] SciMLBase v1.53.2\n  [1ed8b502] SciMLSensitivity v7.7.0\n  [30cb0354] SciMLTutorials v1.0.0\n  [6c6a2e73] Scratch v1.1.1\n⌅ [efcf1570] Setfield v0.8.2\n  [605ecd9f] ShowCases v0.1.0\n  [992d4aef] Showoff v1.0.3\n  [777ac1f9] SimpleBufferStream v1.1.0\n  [699a6c99] SimpleTraits v0.9.4\n  [66db9d55] SnoopPrecompile v1.0.1\n  [ed01d8cd] Sobol v1.5.0\n  [b85f4697] SoftGlobalScope v1.1.0\n  [a2af1166] SortingAlgorithms v1.0.1\n  [47a9eef4] SparseDiffTools v1.26.2\n  [276daf66] SpecialFunctions v2.1.7\n  [171d559e] SplittablesBase v0.1.14\n  [860ef19b] StableRNGs v1.0.0\n  [aedffcd0] Static v0.7.6\n  [90137ffa] StaticArrays v1.5.6\n  [1e83bf80] StaticArraysCore v1.3.0\n  [82ae8749] StatsAPI v1.5.0\n  [2913bbd2] StatsBase v0.33.21\n  [4c63d2b9] StatsFuns v1.0.1\n  [9672c7b4] SteadyStateDiffEq v1.9.0\n  [789caeaf] StochasticDiffEq v6.53.0\n  [7792a7ef] StrideArraysCore v0.3.15\n  [69024149] StringEncodings v0.3.5\n  [09ab397b] StructArrays v0.6.12\n  [53d494c1] StructIO v0.3.0\n  [c3572dad] Sundials v4.10.1\n  [d1185830] SymbolicUtils v0.19.11\n  [0c5d862f] Symbolics v4.10.4\n  [3783bdb8] TableTraits v1.0.1\n  [bd369af6] Tables v1.7.0\n  [62fd8b95] TensorCore v0.1.1\n⌅ [8ea1fca8] TermInterface v0.2.3\n  [5d786b92] TerminalLoggers v0.1.6\n  [8290d209] ThreadingUtilities v0.5.0\n  [ac1d9e8a] ThreadsX v0.1.10\n  [a759f4b9] TimerOutputs v0.5.21\n  [0796e94c] Tokenize v0.5.24\n  [9f7883ad] Tracker v0.2.21\n  [3bb67fe8] TranscodingStreams v0.9.9\n  [28d57a85] Transducers v0.4.73\n  [a2a6695c] TreeViews v0.3.0\n  [d5829a12] TriangularSolve v0.1.13\n  [410a4b4d] Tricks v0.1.6\n  [5c2747f8] URIs v1.4.0\n  [3a884ed6] UnPack v1.0.2\n  [d9a01c3f] Underscores v3.0.0\n  [1cfade01] UnicodeFun v0.4.1\n  [1986cc42] Unitful v1.11.0\n  [41fe7b60] Unzip v0.2.0\n  [3d5dd08c] VectorizationBase v0.21.47\n  [81def892] VersionParsing v1.3.0\n  [19fa3120] VertexSafeGraphs v0.2.0\n⌃ [44d3d7a6] Weave v0.10.9\n  [ddb6d928] YAML v0.4.7\n  [c2297ded] ZMQ v1.2.1\n  [e88e6eb3] Zygote v0.6.47\n  [700de1a5] ZygoteRules v0.2.2\n  [6e34b625] Bzip2_jll v1.0.8+0\n  [83423d85] Cairo_jll v1.16.1+1\n  [3bed1096] Cuba_jll v4.2.2+1\n  [7bc98958] Cubature_jll v1.0.5+0\n  [5ae413db] EarCut_jll v2.2.3+0\n⌅ [7cc45869] Enzyme_jll v0.0.33+0\n  [2e619515] Expat_jll v2.4.8+0\n  [b22a6f82] FFMPEG_jll v4.4.2+0\n  [a3f928ae] Fontconfig_jll v2.13.93+0\n  [d7e528f0] FreeType2_jll v2.10.4+0\n  [559328eb] FriBidi_jll v1.0.10+0\n  [0656b61e] GLFW_jll v3.3.8+0\n  [d2c73de3] GR_jll v0.66.2+0\n  [78b55507] Gettext_jll v0.21.0+0\n  [7746bdde] Glib_jll v2.68.3+2\n  [3b182d85] Graphite2_jll v1.3.14+0\n  [2e76f6c2] HarfBuzz_jll v2.8.1+1\n  [aacddb02] JpegTurbo_jll v2.1.2+0\n  [c1c5ebd0] LAME_jll v3.100.1+0\n  [88015f11] LERC_jll v3.0.0+1\n  [dad2f222] LLVMExtra_jll v0.0.16+0\n  [dd4b983a] LZO_jll v2.10.1+0\n  [e9f186c6] Libffi_jll v3.2.2+1\n  [d4300ac3] Libgcrypt_jll v1.8.7+0\n  [7e76a0d4] Libglvnd_jll v1.3.0+3\n  [7add5ba3] Libgpg_error_jll v1.42.0+0\n  [94ce4f54] Libiconv_jll v1.16.1+1\n  [4b2f31a3] Libmount_jll v2.35.0+0\n  [89763e89] Libtiff_jll v4.4.0+0\n  [38a345b3] Libuuid_jll v2.36.0+0\n  [e7412a2a] Ogg_jll v1.3.5+1\n  [458c3c95] OpenSSL_jll v1.1.17+0\n  [efe28fd5] OpenSpecFun_jll v0.5.5+0\n  [91d4177d] Opus_jll v1.3.2+0\n  [2f80f16e] PCRE_jll v8.44.0+0\n  [30392449] Pixman_jll v0.40.1+0\n  [ea2cea3b] Qt5Base_jll v5.15.3+1\n  [f50d1b31] Rmath_jll v0.3.0+0\n  [fb77eaff] Sundials_jll v5.2.1+0\n  [a2964d1f] Wayland_jll v1.19.0+0\n  [2381bf8a] Wayland_protocols_jll v1.25.0+0\n  [02c8fc9c] XML2_jll v2.9.14+0\n  [aed1982a] XSLT_jll v1.1.34+0\n  [4f6342f7] Xorg_libX11_jll v1.6.9+4\n  [0c0b7dd1] Xorg_libXau_jll v1.0.9+4\n  [935fb764] Xorg_libXcursor_jll v1.2.0+4\n  [a3789734] Xorg_libXdmcp_jll v1.1.3+4\n  [1082639a] Xorg_libXext_jll v1.3.4+4\n  [d091e8ba] Xorg_libXfixes_jll v5.0.3+4\n  [a51aa0fd] Xorg_libXi_jll v1.7.10+4\n  [d1454406] Xorg_libXinerama_jll v1.1.4+4\n  [ec84b674] Xorg_libXrandr_jll v1.5.2+4\n  [ea2f1a96] Xorg_libXrender_jll v0.9.10+4\n  [14d82f49] Xorg_libpthread_stubs_jll v0.1.0+3\n  [c7cfdc94] Xorg_libxcb_jll v1.13.0+3\n  [cc61e674] Xorg_libxkbfile_jll v1.1.0+4\n  [12413925] Xorg_xcb_util_image_jll v0.4.0+1\n  [2def613f] Xorg_xcb_util_jll v0.4.0+1\n  [975044d2] Xorg_xcb_util_keysyms_jll v0.4.0+1\n  [0d47668e] Xorg_xcb_util_renderutil_jll v0.3.9+1\n  [c22f9ab0] Xorg_xcb_util_wm_jll v0.4.1+1\n  [35661453] Xorg_xkbcomp_jll v1.4.2+4\n  [33bec58e] Xorg_xkeyboard_config_jll v2.27.0+4\n  [c5fb5394] Xorg_xtrans_jll v1.4.0+3\n  [8f1865be] ZeroMQ_jll v4.3.4+0\n  [3161d3a3] Zstd_jll v1.5.2+0\n  [a4ae2306] libaom_jll v3.4.0+0\n  [0ac62f75] libass_jll v0.15.1+0\n  [f638f0a6] libfdk_aac_jll v2.0.2+0\n  [b53b4c65] libpng_jll v1.6.38+0\n  [a9144af2] libsodium_jll v1.0.20+0\n  [f27f6e37] libvorbis_jll v1.3.7+1\n  [1270edf5] x264_jll v2021.5.5+0\n  [dfaa095f] x265_jll v3.5.0+0\n  [d8fb68d0] xkbcommon_jll v1.4.1+0\n  [0dad84c5] ArgTools v1.1.1\n  [56f22d72] Artifacts\n  [2a0f44e3] Base64\n  [ade2ca70] Dates\n  [8bb1440f] DelimitedFiles\n  [8ba89e20] Distributed\n  [f43a241f] Downloads v1.6.0\n  [7b1f6079] FileWatching\n  [9fa8497b] Future\n  [b77e0a4c] InteractiveUtils\n  [4af54fe1] LazyArtifacts\n  [b27032c2] LibCURL v0.6.3\n  [76f85450] LibGit2\n  [8f399da3] Libdl\n  [37e2e46d] LinearAlgebra\n  [56ddb016] Logging\n  [d6f4376e] Markdown\n  [a63ad114] Mmap\n  [ca575930] NetworkOptions v1.2.0\n  [44cfe95a] Pkg v1.8.0\n  [de0858da] Printf\n  [3fa0cd96] REPL\n  [9a3f8284] Random\n  [ea8e919c] SHA v0.7.0\n  [9e88b42a] Serialization\n  [1a1011a3] SharedArrays\n  [6462fe0b] Sockets\n  [2f01184e] SparseArrays\n  [10745b16] Statistics\n  [4607b0f0] SuiteSparse\n  [fa267f1f] TOML v1.0.0\n  [a4e569a6] Tar v1.10.0\n  [8dfed614] Test\n  [cf7118a7] UUIDs\n  [4ec0a83e] Unicode\n  [e66e0078] CompilerSupportLibraries_jll v0.5.2+0\n  [deac9b47] LibCURL_jll v7.84.0+0\n  [29816b5a] LibSSH2_jll v1.10.2+0\n  [c8ffd9c3] MbedTLS_jll v2.28.0+0\n  [14a3606d] MozillaCACerts_jll v2022.2.1\n  [4536629a] OpenBLAS_jll v0.3.20+0\n  [05823500] OpenLibm_jll v0.8.1+0\n  [bea87d4a] SuiteSparse_jll v5.10.1+0\n  [83775a58] Zlib_jll v1.2.12+3\n  [8e850b90] libblastrampoline_jll v5.1.1+0\n  [8e850ede] nghttp2_jll v1.48.0+0\n  [3f19e933] p7zip_jll v17.4.0+0\nInfo Packages marked with ⌃ and ⌅ have new versions available, but those with ⌅ cannot be upgraded. To see why use `status --outdated -m`","category":"page"},{"location":"models/05-outer_solar_system/#The-Outer-Solar-System","page":"The Outer Solar System","title":"The Outer Solar System","text":"","category":"section"},{"location":"models/05-outer_solar_system/#Data","page":"The Outer Solar System","title":"Data","text":"","category":"section"},{"location":"models/05-outer_solar_system/","page":"The Outer Solar System","title":"The Outer Solar System","text":"The chosen units are: masses relative to the sun, so that the sun has mass 1. We have taken m_0 = 100000597682 to take account of the inner planets. Distances are in astronomical units , times in earth days, and the gravitational constant is thus G = 295912208286 cdot 10^-4.","category":"page"},{"location":"models/05-outer_solar_system/","page":"The Outer Solar System","title":"The Outer Solar System","text":"planet mass initial position initial velocity\nJupiter m_1 = 0000954786104043 <ul><li>-3.5023653</li><li>-3.8169847</li><li>-1.5507963</li></ul> <ul><li>0.00565429</li><li>-0.00412490</li><li>-0.00190589</li></ul>\nSaturn m_2 = 0000285583733151 <ul><li>9.0755314</li><li>-3.0458353</li><li>-1.6483708</li></ul> <ul><li>0.00168318</li><li>0.00483525</li><li>0.00192462</li></ul>\nUranus m_3 = 00000437273164546 <ul><li>8.3101420</li><li>-16.2901086</li><li>-7.2521278</li></ul> <ul><li>0.00354178</li><li>0.00137102</li><li>0.00055029</li></ul>\nNeptune m_4 = 00000517759138449 <ul><li>11.4707666</li><li>-25.7294829</li><li>-10.8169456</li></ul> <ul><li>0.00288930</li><li>0.00114527</li><li>0.00039677</li></ul>\nPluto $ m_5 = 1/(1.3 \\cdot 10^8 )$ <ul><li>-15.5387357</li><li>-25.2225594</li><li>-3.1902382</li></ul> <ul><li>0.00276725</li><li>-0.00170702</li><li>-0.00136504</li></ul>","category":"page"},{"location":"models/05-outer_solar_system/","page":"The Outer Solar System","title":"The Outer Solar System","text":"The data is taken from the book \"Geometric Numerical Integration\" by E. Hairer, C. Lubich and G. Wanner.","category":"page"},{"location":"models/05-outer_solar_system/","page":"The Outer Solar System","title":"The Outer Solar System","text":"using Plots, OrdinaryDiffEq, ModelingToolkit\ngr()\n\nG = 2.95912208286e-4\nM = [1.00000597682, 0.000954786104043, 0.000285583733151, 0.0000437273164546, 0.0000517759138449, 1/1.3e8]\nplanets = [\"Sun\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\", \"Pluto\"]\n\npos =  [0.0  -3.5023653   9.0755314    8.310142    11.4707666  -15.5387357\n        0.0  -3.8169847  -3.0458353  -16.2901086  -25.7294829  -25.2225594\n        0.0  -1.5507963  -1.6483708   -7.2521278  -10.8169456   -3.1902382]\nvel = [0.0   0.00565429  0.00168318  0.00354178  0.0028893    0.00276725\n       0.0  -0.0041249   0.00483525  0.00137102  0.00114527  -0.00170702\n       0.0  -0.00190589  0.00192462  0.00055029  0.00039677  -0.00136504]\ntspan = (0.0, 200_000.0)","category":"page"},{"location":"models/05-outer_solar_system/","page":"The Outer Solar System","title":"The Outer Solar System","text":"(0.0, 200000.0)","category":"page"},{"location":"models/05-outer_solar_system/","page":"The Outer Solar System","title":"The Outer Solar System","text":"The N-body problem's Hamiltonian is","category":"page"},{"location":"models/05-outer_solar_system/","page":"The Outer Solar System","title":"The Outer Solar System","text":"H(pq) = frac12sum_i=0^Nfracp_i^Tp_im_i - Gsum_i=1^Nsum_j=0^i-1fracm_im_jleftlVert q_i-q_j rightrVert","category":"page"},{"location":"models/05-outer_solar_system/","page":"The Outer Solar System","title":"The Outer Solar System","text":"Here, we want to solve for the motion of the five outer planets relative to the sun, namely, Jupiter, Saturn, Uranus, Neptune and Pluto.","category":"page"},{"location":"models/05-outer_solar_system/","page":"The Outer Solar System","title":"The Outer Solar System","text":"const ∑ = sum\nconst N = 6\n@variables t u(t)[1:3, 1:N]\nu = collect(u)\nD = Differential(t)\npotential = -G*∑(i->∑(j->(M[i]*M[j])/√(∑(k->(u[k, i]-u[k, j])^2, 1:3)), 1:i-1), 2:N)","category":"page"},{"location":"models/05-outer_solar_system/","page":"The Outer Solar System","title":"The Outer Solar System","text":"-2.8253455313622585e-7 / sqrt(((u(t))[1, 2] - (u(t))[1, 1])^2 + ((u(t))[2, \n2] - (u(t))[2, 1])^2 + ((u(t))[3, 2] - (u(t))[3, 1])^2) + -8.45082182146621\n2e-8 / sqrt(((u(t))[1, 3] - (u(t))[1, 1])^2 + ((u(t))[2, 3] - (u(t))[2, 1])\n^2 + ((u(t))[3, 3] - (u(t))[3, 1])^2) + -1.2939524111245703e-8 / sqrt(((u(t\n))[1, 4] - (u(t))[1, 1])^2 + ((u(t))[2, 4] - (u(t))[2, 1])^2 + ((u(t))[3, 4\n] - (u(t))[3, 1])^2) + -8.068679017837167e-11 / sqrt(((u(t))[1, 3] - (u(t))\n[1, 2])^2 + ((u(t))[2, 3] - (u(t))[2, 2])^2 + ((u(t))[3, 3] - (u(t))[3, 2])\n^2) + -1.2354403974297985e-11 / sqrt(((u(t))[1, 4] - (u(t))[1, 2])^2 + ((u(\nt))[2, 4] - (u(t))[2, 2])^2 + ((u(t))[3, 4] - (u(t))[3, 2])^2) + -1.5321216\n573476373e-8 / sqrt(((u(t))[1, 5] - (u(t))[1, 1])^2 + ((u(t))[2, 5] - (u(t)\n)[2, 1])^2 + ((u(t))[3, 5] - (u(t))[3, 1])^2) + -2.2762613607692674e-12 / s\nqrt(((u(t))[1, 6] - (u(t))[1, 1])^2 + ((u(t))[2, 6] - (u(t))[2, 1])^2 + ((u\n(t))[3, 6] - (u(t))[3, 1])^2) + -1.4628397250091296e-11 / sqrt(((u(t))[1, 5\n] - (u(t))[1, 2])^2 + ((u(t))[2, 5] - (u(t))[2, 2])^2 + ((u(t))[3, 5] - (u(\nt))[3, 2])^2) + -2.1733297268319285e-15 / sqrt(((u(t))[1, 6] - (u(t))[1, 2]\n)^2 + ((u(t))[2, 6] - (u(t))[2, 2])^2 + ((u(t))[3, 6] - (u(t))[3, 2])^2) + \n-3.695295514770784e-12 / sqrt(((u(t))[1, 4] - (u(t))[1, 3])^2 + ((u(t))[2, \n4] - (u(t))[2, 3])^2 + ((u(t))[3, 4] - (u(t))[3, 3])^2) + -4.37546407410716\n75e-12 / sqrt(((u(t))[1, 5] - (u(t))[1, 3])^2 + ((u(t))[2, 5] - (u(t))[2, 3\n])^2 + ((u(t))[3, 5] - (u(t))[3, 3])^2) + -6.500593317482474e-16 / sqrt(((u\n(t))[1, 6] - (u(t))[1, 3])^2 + ((u(t))[2, 6] - (u(t))[2, 3])^2 + ((u(t))[3,\n 6] - (u(t))[3, 3])^2) + -6.699516813972553e-13 / sqrt(((u(t))[1, 5] - (u(t\n))[1, 4])^2 + ((u(t))[2, 5] - (u(t))[2, 4])^2 + ((u(t))[3, 5] - (u(t))[3, 4\n])^2) + -9.953420595770331e-17 / sqrt(((u(t))[1, 6] - (u(t))[1, 4])^2 + ((u\n(t))[2, 6] - (u(t))[2, 4])^2 + ((u(t))[3, 6] - (u(t))[3, 4])^2) + -1.178548\n077066926e-16 / sqrt(((u(t))[1, 6] - (u(t))[1, 5])^2 + ((u(t))[2, 6] - (u(t\n))[2, 5])^2 + ((u(t))[3, 6] - (u(t))[3, 5])^2)","category":"page"},{"location":"models/05-outer_solar_system/#Hamiltonian-System","page":"The Outer Solar System","title":"Hamiltonian System","text":"","category":"section"},{"location":"models/05-outer_solar_system/","page":"The Outer Solar System","title":"The Outer Solar System","text":"NBodyProblem constructs a second order ODE problem under the hood. We know that a Hamiltonian system has the form of","category":"page"},{"location":"models/05-outer_solar_system/","page":"The Outer Solar System","title":"The Outer Solar System","text":"dotp = -H_q(pq)quad dotq=H_p(pq)","category":"page"},{"location":"models/05-outer_solar_system/","page":"The Outer Solar System","title":"The Outer Solar System","text":"For an N-body system, we can symplify this as:","category":"page"},{"location":"models/05-outer_solar_system/","page":"The Outer Solar System","title":"The Outer Solar System","text":"dotp = -nablaV(q)quad dotq=M^-1p","category":"page"},{"location":"models/05-outer_solar_system/","page":"The Outer Solar System","title":"The Outer Solar System","text":"Thus dotq is defined by the masses. We only need to define dotp, and this is done internally by taking the gradient of V. Therefore, we only need to pass the potential function and the rest is taken care of.","category":"page"},{"location":"models/05-outer_solar_system/","page":"The Outer Solar System","title":"The Outer Solar System","text":"eqs = vec(@. D(D(u))) .~ .- ModelingToolkit.gradient(potential, vec(u)) ./ repeat(M, inner=3)\n@named sys = ODESystem(eqs, t)\nss = structural_simplify(sys)\nprob = ODEProblem(ss, [vec(u .=> pos); vec(D.(u) .=> vel)], tspan)\nsol = solve(prob, Tsit5());","category":"page"},{"location":"models/05-outer_solar_system/","page":"The Outer Solar System","title":"The Outer Solar System","text":"plt = plot()\nfor i in 1:N\n    plot!(plt, sol, idxs=(u[:, i]...,), lab = planets[i])\nend\nplot!(plt; xlab = \"x\", ylab = \"y\", zlab = \"z\", title = \"Outer solar system\")","category":"page"},{"location":"models/05-outer_solar_system/","page":"The Outer Solar System","title":"The Outer Solar System","text":"(Image: )","category":"page"},{"location":"models/05-outer_solar_system/#Appendix","page":"The Outer Solar System","title":"Appendix","text":"","category":"section"},{"location":"models/05-outer_solar_system/","page":"The Outer Solar System","title":"The Outer Solar System","text":"These tutorials are a part of the SciMLTutorials.jl repository, found at: https://github.com/SciML/SciMLTutorials.jl. For more information on high-performance scientific machine learning, check out the SciML Open Source Software Organization https://sciml.ai.","category":"page"},{"location":"models/05-outer_solar_system/","page":"The Outer Solar System","title":"The Outer Solar System","text":"To locally run this tutorial, do the following commands:","category":"page"},{"location":"models/05-outer_solar_system/","page":"The Outer Solar System","title":"The Outer Solar System","text":"using SciMLTutorials\nSciMLTutorials.weave_file(\"tutorials/models\",\"05-outer_solar_system.jmd\")","category":"page"},{"location":"models/05-outer_solar_system/","page":"The Outer Solar System","title":"The Outer Solar System","text":"Computer Information:","category":"page"},{"location":"models/05-outer_solar_system/","page":"The Outer Solar System","title":"The Outer Solar System","text":"Julia Version 1.8.0\nCommit 5544a0fab76 (2022-08-17 13:38 UTC)\nPlatform Info:\n  OS: Linux (x86_64-linux-gnu)\n  CPU: 128 × AMD EPYC 7502 32-Core Processor\n  WORD_SIZE: 64\n  LIBM: libopenlibm\n  LLVM: libLLVM-13.0.1 (ORCJIT, znver2)\n  Threads: 1 on 128 virtual cores\nEnvironment:\n  JULIA_CPU_THREADS = 128\n  JULIA_DEPOT_PATH = /cache/julia-buildkite-plugin/depots/a6029d3a-f78b-41ea-bc97-28aa57c6c6ea\n","category":"page"},{"location":"models/05-outer_solar_system/","page":"The Outer Solar System","title":"The Outer Solar System","text":"Package Information:","category":"page"},{"location":"models/05-outer_solar_system/","page":"The Outer Solar System","title":"The Outer Solar System","text":"Status `/cache/build/exclusive-amdci1-0/julialang/scimltutorials-dot-jl/tutorials/models/Project.toml`\n  [479239e8] Catalyst v12.2.1\n  [459566f4] DiffEqCallbacks v2.24.1\n  [f3b72e0c] DiffEqDevTools v2.31.2\n  [055956cb] DiffEqPhysics v3.9.0\n  [0c46a032] DifferentialEquations v7.3.0\n  [31c24e10] Distributions v0.25.70\n  [587475ba] Flux v0.13.5\n  [f6369f11] ForwardDiff v0.10.32\n  [23fbe1c1] Latexify v0.15.16\n  [961ee093] ModelingToolkit v8.21.0\n  [2774e3e8] NLsolve v4.5.1\n⌅ [315f7962] NeuralPDE v4.11.0\n  [429524aa] Optim v1.7.2\n  [1dea7af3] OrdinaryDiffEq v6.26.2\n  [91a5bcdd] Plots v1.32.0\n  [731186ca] RecursiveArrayTools v2.32.0\n  [30cb0354] SciMLTutorials v1.0.0\n  [789caeaf] StochasticDiffEq v6.53.0\n  [37e2e46d] LinearAlgebra\n  [2f01184e] SparseArrays\nInfo Packages marked with ⌅ have new versions available but cannot be upgraded. To see why use `status --outdated`","category":"page"},{"location":"models/05-outer_solar_system/","page":"The Outer Solar System","title":"The Outer Solar System","text":"And the full manifest:","category":"page"},{"location":"models/05-outer_solar_system/","page":"The Outer Solar System","title":"The Outer Solar System","text":"Status `/cache/build/exclusive-amdci1-0/julialang/scimltutorials-dot-jl/tutorials/models/Manifest.toml`\n  [c3fe647b] AbstractAlgebra v0.27.4\n  [621f4979] AbstractFFTs v1.2.1\n  [1520ce14] AbstractTrees v0.4.2\n  [7d9f7c33] Accessors v0.1.20\n  [79e6a3ab] Adapt v3.4.0\n  [dce04be8] ArgCheck v2.3.0\n  [ec485272] ArnoldiMethod v0.2.0\n  [4fba245c] ArrayInterface v6.0.23\n  [30b0a656] ArrayInterfaceCore v0.1.20\n  [6ba088a2] ArrayInterfaceGPUArrays v0.2.1\n  [015c0d05] ArrayInterfaceOffsetArrays v0.1.6\n  [b0d46f97] ArrayInterfaceStaticArrays v0.1.4\n  [dd5226c6] ArrayInterfaceStaticArraysCore v0.1.0\n  [a2b0951a] ArrayInterfaceTracker v0.1.1\n  [4c555306] ArrayLayouts v0.8.11\n  [15f4f7f2] AutoHashEquals v0.2.0\n  [ab4f0b2a] BFloat16s v0.2.0\n  [aae01518] BandedMatrices v0.17.6\n  [198e06fe] BangBang v0.3.36\n  [9718e550] Baselet v0.1.1\n  [e2ed5e7c] Bijections v0.1.4\n  [62783981] BitTwiddlingConvenienceFunctions v0.1.4\n  [8e7c35d0] BlockArrays v0.16.20\n  [ffab5731] BlockBandedMatrices v0.11.9\n  [764a87c0] BoundaryValueDiffEq v2.9.0\n  [fa961155] CEnum v0.4.2\n  [2a0fbf3d] CPUSummary v0.1.25\n  [00ebfdb7] CSTParser v3.3.6\n  [052768ef] CUDA v3.12.0\n  [49dc2e85] Calculus v0.5.1\n  [7057c7e9] Cassette v0.3.10\n  [479239e8] Catalyst v12.2.1\n  [082447d4] ChainRules v1.44.6\n  [d360d2e6] ChainRulesCore v1.15.4\n  [9e997f8a] ChangesOfVariables v0.1.4\n  [fb6a15b2] CloseOpenIntervals v0.1.10\n  [944b1d66] CodecZlib v0.7.0\n  [35d6a980] ColorSchemes v3.19.0\n  [3da002f7] ColorTypes v0.11.4\n  [c3611d14] ColorVectorSpace v0.9.9\n  [5ae59095] Colors v0.12.8\n  [861a8166] Combinatorics v1.0.2\n  [a80b9123] CommonMark v0.8.6\n  [38540f10] CommonSolve v0.2.1\n  [bbf7d656] CommonSubexpressions v0.3.0\n⌅ [34da2185] Compat v3.46.0\n  [b0b7db55] ComponentArrays v0.13.2\n  [b152e2b5] CompositeTypes v0.1.2\n  [a33af91c] CompositionsBase v0.1.1\n  [8f4d0f93] Conda v1.7.0\n  [88cd18e8] ConsoleProgressMonitor v0.1.2\n  [187b0558] ConstructionBase v1.4.1\n  [6add18c4] ContextVariablesX v0.1.2\n  [d38c429a] Contour v0.6.2\n  [adafc99b] CpuId v0.3.1\n  [a8cc5b0e] Crayons v4.1.1\n  [8a292aeb] Cuba v2.2.0\n  [667455a9] Cubature v1.5.1\n  [9a962f9c] DataAPI v1.10.0\n  [82cc6244] DataInterpolations v3.10.1\n  [864edb3b] DataStructures v0.18.13\n  [e2d170a0] DataValueInterfaces v1.0.0\n  [244e2a9f] DefineSingletons v0.1.2\n  [bcd4f6db] DelayDiffEq v5.37.1\n  [b429d917] DensityInterface v0.4.0\n  [2b5f629d] DiffEqBase v6.100.0\n  [459566f4] DiffEqCallbacks v2.24.1\n  [f3b72e0c] DiffEqDevTools v2.31.2\n  [aae7a2af] DiffEqFlux v1.52.0\n  [77a26b50] DiffEqNoiseProcess v5.12.3\n  [9fdde737] DiffEqOperators v4.43.1\n  [055956cb] DiffEqPhysics v3.9.0\n  [41bf760c] DiffEqSensitivity v6.79.0\n  [163ba53b] DiffResults v1.0.3\n  [b552c78f] DiffRules v1.11.1\n  [0c46a032] DifferentialEquations v7.3.0\n  [b4f34e82] Distances v0.10.7\n  [31c24e10] Distributions v0.25.70\n  [ced4e74d] DistributionsAD v0.6.42\n⌅ [ffbed154] DocStringExtensions v0.8.6\n  [5b8099bc] DomainSets v0.5.13\n  [fa6b7ba4] DualNumbers v0.6.8\n  [7c1d4256] DynamicPolynomials v0.4.5\n  [da5c29d0] EllipsisNotation v1.6.0\n  [7da242da] Enzyme v0.10.4\n  [d4d017d3] ExponentialUtilities v1.18.0\n  [e2ba6199] ExprTools v0.1.8\n  [411431e0] Extents v0.1.1\n  [c87230d0] FFMPEG v0.4.1\n  [cc61a311] FLoops v0.2.0\n  [b9860ae5] FLoopsBase v0.1.1\n  [7034ab61] FastBroadcast v0.2.1\n  [9aa1b823] FastClosures v0.3.2\n  [29a986be] FastLapackInterface v1.2.6\n  [1a297f60] FillArrays v0.13.4\n⌃ [6a86dc24] FiniteDiff v2.13.1\n  [53c48c17] FixedPointNumbers v0.8.4\n  [587475ba] Flux v0.13.5\n  [9c68100b] FoldsThreads v0.1.1\n  [59287772] Formatting v0.4.2\n  [f6369f11] ForwardDiff v0.10.32\n  [069b7b12] FunctionWrappers v1.1.2\n  [77dc65aa] FunctionWrappersWrappers v0.1.1\n  [d9f16b24] Functors v0.3.0\n  [0c68f7d7] GPUArrays v8.5.0\n  [46192b85] GPUArraysCore v0.1.2\n  [61eb1bfa] GPUCompiler v0.16.3\n  [28b8d3ca] GR v0.66.2\n  [c145ed77] GenericSchur v0.5.3\n  [cf35fbd7] GeoInterface v1.0.1\n  [5c1252a2] GeometryBasics v0.4.3\n  [86223c79] Graphs v1.7.2\n  [42e2da0e] Grisu v1.0.2\n  [0b43b601] Groebner v0.2.10\n  [d5909c97] GroupsCore v0.4.0\n  [19dc6840] HCubature v1.5.0\n  [cd3eb016] HTTP v1.3.3\n⌅ [eafb193a] Highlights v0.4.5\n  [3e5b6fbb] HostCPUFeatures v0.1.8\n  [34004b35] HypergeometricFunctions v0.3.11\n  [7073ff75] IJulia v1.23.3\n  [7869d1d1] IRTools v0.4.6\n  [615f187c] IfElse v0.1.1\n  [d25df0c9] Inflate v0.1.3\n  [83e8ac13] IniFile v0.5.1\n  [22cec73e] InitialValues v0.3.1\n  [18e54dd8] IntegerMathUtils v0.1.0\n  [8197267c] IntervalSets v0.7.2\n  [3587e190] InverseFunctions v0.1.7\n  [92d709cd] IrrationalConstants v0.1.1\n  [c8e1da08] IterTools v1.4.0\n  [42fd0dbc] IterativeSolvers v0.9.2\n  [82899510] IteratorInterfaceExtensions v1.0.0\n  [692b3bcd] JLLWrappers v1.4.1\n  [682c06a0] JSON v0.21.3\n  [98e50ef6] JuliaFormatter v1.0.9\n  [b14d175d] JuliaVariables v0.2.4\n  [ccbc3e58] JumpProcesses v9.2.0\n  [ef3ab10e] KLU v0.3.0\n  [ba0b0d4f] Krylov v0.8.3\n  [0b1a1467] KrylovKit v0.5.4\n  [929cbde3] LLVM v4.14.0\n  [b964fa9f] LaTeXStrings v1.3.0\n  [2ee39098] LabelledArrays v1.12.0\n  [23fbe1c1] Latexify v0.15.16\n  [a5e1c1ea] LatinHypercubeSampling v1.8.0\n  [73f95e8e] LatticeRules v0.0.1\n  [10f19ff3] LayoutPointers v0.1.10\n  [50d2b5c4] Lazy v0.15.1\n  [5078a376] LazyArrays v0.22.11\n⌅ [d7e5e226] LazyBandedMatrices v0.7.17\n  [0fc2ff8b] LeastSquaresOptim v0.8.3\n  [1d6d02ad] LeftChildRightSiblingTrees v0.2.0\n  [2d8b4e74] LevyArea v1.0.0\n  [d3d80556] LineSearches v7.2.0\n  [7ed4a6bd] LinearSolve v1.26.0\n  [2ab3a3ac] LogExpFunctions v0.3.18\n  [e6f89c97] LoggingExtras v0.4.9\n  [bdcacae8] LoopVectorization v0.12.125\n  [b2108857] Lux v0.4.21\n  [d8e11817] MLStyle v0.4.13\n  [f1d291b0] MLUtils v0.2.10\n  [1914dd2f] MacroTools v0.5.9\n  [d125e4d3] ManualMemory v0.1.8\n  [a3b82374] MatrixFactorizations v0.9.2\n  [739be429] MbedTLS v1.1.5\n  [442fdcdd] Measures v0.3.1\n  [c03570c3] Memoize v0.4.4\n  [e9d8d322] Metatheory v1.3.4\n  [128add7d] MicroCollections v0.1.2\n  [e1d29d7a] Missings v1.0.2\n  [961ee093] ModelingToolkit v8.21.0\n⌅ [4886b29c] MonteCarloIntegration v0.0.3\n  [46d2c3a1] MuladdMacro v0.2.2\n  [102ac46a] MultivariatePolynomials v0.4.6\n  [ffc61752] Mustache v1.0.14\n  [d8a4904e] MutableArithmetics v1.0.4\n  [d41bc354] NLSolversBase v7.8.2\n  [2774e3e8] NLsolve v4.5.1\n  [872c559c] NNlib v0.8.9\n  [a00861dc] NNlibCUDA v0.2.4\n  [77ba4419] NaNMath v1.0.1\n  [71a1bf82] NameResolution v0.1.5\n⌅ [315f7962] NeuralPDE v4.11.0\n  [8913a72c] NonlinearSolve v0.3.22\n  [d8793406] ObjectFile v0.3.7\n  [6fe1bfb0] OffsetArrays v1.12.7\n  [429524aa] Optim v1.7.2\n  [3bd65402] Optimisers v0.2.9\n  [7f7a1694] Optimization v3.8.2\n  [253f991c] OptimizationFlux v0.1.0\n  [36348300] OptimizationOptimJL v0.1.2\n  [42dfb2eb] OptimizationOptimisers v0.1.0\n  [500b13db] OptimizationPolyalgorithms v0.1.0\n  [bac558e1] OrderedCollections v1.4.1\n  [1dea7af3] OrdinaryDiffEq v6.26.2\n  [90014a1f] PDMats v0.11.16\n  [d96e819e] Parameters v0.12.3\n  [69de0a69] Parsers v2.4.0\n  [ccf2f8ad] PlotThemes v3.0.0\n  [995b91a9] PlotUtils v1.3.0\n  [91a5bcdd] Plots v1.32.0\n  [e409e4f3] PoissonRandom v0.4.1\n  [f517fe37] Polyester v0.6.15\n  [1d0040c9] PolyesterWeave v0.1.9\n  [85a6dd25] PositiveFactorizations v0.2.4\n  [d236fae5] PreallocationTools v0.4.2\n  [21216c6a] Preferences v1.3.0\n  [8162dcfd] PrettyPrint v0.2.0\n  [27ebfcd6] Primes v0.5.3\n  [33c8b6b6] ProgressLogging v0.1.4\n  [92933f4c] ProgressMeter v1.7.2\n  [1fd47b50] QuadGK v2.5.0\n  [67601950] Quadrature v2.1.0\n  [e0ec9b62] QuadratureCubature v0.1.1\n  [8a4e6c94] QuasiMonteCarlo v0.2.9\n  [74087812] Random123 v1.6.0\n  [fb686558] RandomExtensions v0.4.3\n  [e6cf234a] RandomNumbers v1.5.3\n  [c1ae055f] RealDot v0.1.0\n  [3cdcf5f2] RecipesBase v1.2.1\n  [01d81517] RecipesPipeline v0.6.3\n  [731186ca] RecursiveArrayTools v2.32.0\n  [f2c3362d] RecursiveFactorization v0.2.12\n  [189a3867] Reexport v1.2.2\n  [42d2dcc6] Referenceables v0.1.2\n  [29dad682] RegularizationTools v0.6.0\n⌅ [05181044] RelocatableFolders v0.3.0\n  [ae029012] Requires v1.3.0\n  [ae5879a3] ResettableStacks v1.1.1\n  [37e2e3b7] ReverseDiff v1.14.1\n  [79098fc4] Rmath v0.7.0\n  [47965b36] RootedTrees v2.13.0\n  [7e49a35a] RuntimeGeneratedFunctions v0.5.3\n  [3cdde19b] SIMDDualNumbers v0.1.1\n  [94e857df] SIMDTypes v0.1.0\n  [476501e8] SLEEFPirates v0.6.35\n  [0bca4576] SciMLBase v1.53.2\n  [1ed8b502] SciMLSensitivity v7.7.0\n  [30cb0354] SciMLTutorials v1.0.0\n  [6c6a2e73] Scratch v1.1.1\n⌅ [efcf1570] Setfield v0.8.2\n  [605ecd9f] ShowCases v0.1.0\n  [992d4aef] Showoff v1.0.3\n  [777ac1f9] SimpleBufferStream v1.1.0\n  [699a6c99] SimpleTraits v0.9.4\n  [66db9d55] SnoopPrecompile v1.0.1\n  [ed01d8cd] Sobol v1.5.0\n  [b85f4697] SoftGlobalScope v1.1.0\n  [a2af1166] SortingAlgorithms v1.0.1\n  [47a9eef4] SparseDiffTools v1.26.2\n  [276daf66] SpecialFunctions v2.1.7\n  [171d559e] SplittablesBase v0.1.14\n  [860ef19b] StableRNGs v1.0.0\n  [aedffcd0] Static v0.7.6\n  [90137ffa] StaticArrays v1.5.6\n  [1e83bf80] StaticArraysCore v1.3.0\n  [82ae8749] StatsAPI v1.5.0\n  [2913bbd2] StatsBase v0.33.21\n  [4c63d2b9] StatsFuns v1.0.1\n  [9672c7b4] SteadyStateDiffEq v1.9.0\n  [789caeaf] StochasticDiffEq v6.53.0\n  [7792a7ef] StrideArraysCore v0.3.15\n  [69024149] StringEncodings v0.3.5\n  [09ab397b] StructArrays v0.6.12\n  [53d494c1] StructIO v0.3.0\n  [c3572dad] Sundials v4.10.1\n  [d1185830] SymbolicUtils v0.19.11\n  [0c5d862f] Symbolics v4.10.4\n  [3783bdb8] TableTraits v1.0.1\n  [bd369af6] Tables v1.7.0\n  [62fd8b95] TensorCore v0.1.1\n⌅ [8ea1fca8] TermInterface v0.2.3\n  [5d786b92] TerminalLoggers v0.1.6\n  [8290d209] ThreadingUtilities v0.5.0\n  [ac1d9e8a] ThreadsX v0.1.10\n  [a759f4b9] TimerOutputs v0.5.21\n  [0796e94c] Tokenize v0.5.24\n  [9f7883ad] Tracker v0.2.21\n  [3bb67fe8] TranscodingStreams v0.9.9\n  [28d57a85] Transducers v0.4.73\n  [a2a6695c] TreeViews v0.3.0\n  [d5829a12] TriangularSolve v0.1.13\n  [410a4b4d] Tricks v0.1.6\n  [5c2747f8] URIs v1.4.0\n  [3a884ed6] UnPack v1.0.2\n  [d9a01c3f] Underscores v3.0.0\n  [1cfade01] UnicodeFun v0.4.1\n  [1986cc42] Unitful v1.11.0\n  [41fe7b60] Unzip v0.2.0\n  [3d5dd08c] VectorizationBase v0.21.47\n  [81def892] VersionParsing v1.3.0\n  [19fa3120] VertexSafeGraphs v0.2.0\n⌃ [44d3d7a6] Weave v0.10.9\n  [ddb6d928] YAML v0.4.7\n  [c2297ded] ZMQ v1.2.1\n  [e88e6eb3] Zygote v0.6.47\n  [700de1a5] ZygoteRules v0.2.2\n  [6e34b625] Bzip2_jll v1.0.8+0\n  [83423d85] Cairo_jll v1.16.1+1\n  [3bed1096] Cuba_jll v4.2.2+1\n  [7bc98958] Cubature_jll v1.0.5+0\n  [5ae413db] EarCut_jll v2.2.3+0\n⌅ [7cc45869] Enzyme_jll v0.0.33+0\n  [2e619515] Expat_jll v2.4.8+0\n  [b22a6f82] FFMPEG_jll v4.4.2+0\n  [a3f928ae] Fontconfig_jll v2.13.93+0\n  [d7e528f0] FreeType2_jll v2.10.4+0\n  [559328eb] FriBidi_jll v1.0.10+0\n  [0656b61e] GLFW_jll v3.3.8+0\n  [d2c73de3] GR_jll v0.66.2+0\n  [78b55507] Gettext_jll v0.21.0+0\n  [7746bdde] Glib_jll v2.68.3+2\n  [3b182d85] Graphite2_jll v1.3.14+0\n  [2e76f6c2] HarfBuzz_jll v2.8.1+1\n  [aacddb02] JpegTurbo_jll v2.1.2+0\n  [c1c5ebd0] LAME_jll v3.100.1+0\n  [88015f11] LERC_jll v3.0.0+1\n  [dad2f222] LLVMExtra_jll v0.0.16+0\n  [dd4b983a] LZO_jll v2.10.1+0\n  [e9f186c6] Libffi_jll v3.2.2+1\n  [d4300ac3] Libgcrypt_jll v1.8.7+0\n  [7e76a0d4] Libglvnd_jll v1.3.0+3\n  [7add5ba3] Libgpg_error_jll v1.42.0+0\n  [94ce4f54] Libiconv_jll v1.16.1+1\n  [4b2f31a3] Libmount_jll v2.35.0+0\n  [89763e89] Libtiff_jll v4.4.0+0\n  [38a345b3] Libuuid_jll v2.36.0+0\n  [e7412a2a] Ogg_jll v1.3.5+1\n  [458c3c95] OpenSSL_jll v1.1.17+0\n  [efe28fd5] OpenSpecFun_jll v0.5.5+0\n  [91d4177d] Opus_jll v1.3.2+0\n  [2f80f16e] PCRE_jll v8.44.0+0\n  [30392449] Pixman_jll v0.40.1+0\n  [ea2cea3b] Qt5Base_jll v5.15.3+1\n  [f50d1b31] Rmath_jll v0.3.0+0\n  [fb77eaff] Sundials_jll v5.2.1+0\n  [a2964d1f] Wayland_jll v1.19.0+0\n  [2381bf8a] Wayland_protocols_jll v1.25.0+0\n  [02c8fc9c] XML2_jll v2.9.14+0\n  [aed1982a] XSLT_jll v1.1.34+0\n  [4f6342f7] Xorg_libX11_jll v1.6.9+4\n  [0c0b7dd1] Xorg_libXau_jll v1.0.9+4\n  [935fb764] Xorg_libXcursor_jll v1.2.0+4\n  [a3789734] Xorg_libXdmcp_jll v1.1.3+4\n  [1082639a] Xorg_libXext_jll v1.3.4+4\n  [d091e8ba] Xorg_libXfixes_jll v5.0.3+4\n  [a51aa0fd] Xorg_libXi_jll v1.7.10+4\n  [d1454406] Xorg_libXinerama_jll v1.1.4+4\n  [ec84b674] Xorg_libXrandr_jll v1.5.2+4\n  [ea2f1a96] Xorg_libXrender_jll v0.9.10+4\n  [14d82f49] Xorg_libpthread_stubs_jll v0.1.0+3\n  [c7cfdc94] Xorg_libxcb_jll v1.13.0+3\n  [cc61e674] Xorg_libxkbfile_jll v1.1.0+4\n  [12413925] Xorg_xcb_util_image_jll v0.4.0+1\n  [2def613f] Xorg_xcb_util_jll v0.4.0+1\n  [975044d2] Xorg_xcb_util_keysyms_jll v0.4.0+1\n  [0d47668e] Xorg_xcb_util_renderutil_jll v0.3.9+1\n  [c22f9ab0] Xorg_xcb_util_wm_jll v0.4.1+1\n  [35661453] Xorg_xkbcomp_jll v1.4.2+4\n  [33bec58e] Xorg_xkeyboard_config_jll v2.27.0+4\n  [c5fb5394] Xorg_xtrans_jll v1.4.0+3\n  [8f1865be] ZeroMQ_jll v4.3.4+0\n  [3161d3a3] Zstd_jll v1.5.2+0\n  [a4ae2306] libaom_jll v3.4.0+0\n  [0ac62f75] libass_jll v0.15.1+0\n  [f638f0a6] libfdk_aac_jll v2.0.2+0\n  [b53b4c65] libpng_jll v1.6.38+0\n  [a9144af2] libsodium_jll v1.0.20+0\n  [f27f6e37] libvorbis_jll v1.3.7+1\n  [1270edf5] x264_jll v2021.5.5+0\n  [dfaa095f] x265_jll v3.5.0+0\n  [d8fb68d0] xkbcommon_jll v1.4.1+0\n  [0dad84c5] ArgTools v1.1.1\n  [56f22d72] Artifacts\n  [2a0f44e3] Base64\n  [ade2ca70] Dates\n  [8bb1440f] DelimitedFiles\n  [8ba89e20] Distributed\n  [f43a241f] Downloads v1.6.0\n  [7b1f6079] FileWatching\n  [9fa8497b] Future\n  [b77e0a4c] InteractiveUtils\n  [4af54fe1] LazyArtifacts\n  [b27032c2] LibCURL v0.6.3\n  [76f85450] LibGit2\n  [8f399da3] Libdl\n  [37e2e46d] LinearAlgebra\n  [56ddb016] Logging\n  [d6f4376e] Markdown\n  [a63ad114] Mmap\n  [ca575930] NetworkOptions v1.2.0\n  [44cfe95a] Pkg v1.8.0\n  [de0858da] Printf\n  [3fa0cd96] REPL\n  [9a3f8284] Random\n  [ea8e919c] SHA v0.7.0\n  [9e88b42a] Serialization\n  [1a1011a3] SharedArrays\n  [6462fe0b] Sockets\n  [2f01184e] SparseArrays\n  [10745b16] Statistics\n  [4607b0f0] SuiteSparse\n  [fa267f1f] TOML v1.0.0\n  [a4e569a6] Tar v1.10.0\n  [8dfed614] Test\n  [cf7118a7] UUIDs\n  [4ec0a83e] Unicode\n  [e66e0078] CompilerSupportLibraries_jll v0.5.2+0\n  [deac9b47] LibCURL_jll v7.84.0+0\n  [29816b5a] LibSSH2_jll v1.10.2+0\n  [c8ffd9c3] MbedTLS_jll v2.28.0+0\n  [14a3606d] MozillaCACerts_jll v2022.2.1\n  [4536629a] OpenBLAS_jll v0.3.20+0\n  [05823500] OpenLibm_jll v0.8.1+0\n  [bea87d4a] SuiteSparse_jll v5.10.1+0\n  [83775a58] Zlib_jll v1.2.12+3\n  [8e850b90] libblastrampoline_jll v5.1.1+0\n  [8e850ede] nghttp2_jll v1.48.0+0\n  [3f19e933] p7zip_jll v17.4.0+0\nInfo Packages marked with ⌃ and ⌅ have new versions available, but those with ⌅ cannot be upgraded. To see why use `status --outdated -m`","category":"page"},{"location":"perturbation/02-perturbation_differential/#Mixed-Symbolic/Numerical-Methods-for-Perturbation-Theory-Differential-Equations","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","text":"","category":"section"},{"location":"perturbation/02-perturbation_differential/#Prelims","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","title":"Prelims","text":"","category":"section"},{"location":"perturbation/02-perturbation_differential/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","text":"In the previous tutorial, Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations, we discussed how to solve algebraic equations using Symbolics.jl. Here, our goal is to extend the method to differential equations. First, we import the following helper functions that were introduced in Mixed Symbolic/Numerical Methods for Perturbation Theory - Algebraic Equations.","category":"page"},{"location":"perturbation/02-perturbation_differential/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","text":"using Symbolics, SymbolicUtils\n\ndef_taylor(x, ps) = sum([a*x^i for (i,a) in enumerate(ps)])\ndef_taylor(x, ps, p₀) = p₀ + def_taylor(x, ps)\n\nfunction collect_powers(eq, x, ns; max_power=100)\n    eq = substitute(expand(eq), Dict(x^j => 0 for j=last(ns)+1:max_power))\n\n    eqs = []\n    for i in ns\n        powers = Dict(x^j => (i==j ? 1 : 0) for j=1:last(ns))\n        push!(eqs, substitute(eq, powers))\n    end\n    eqs\nend\n\nfunction solve_coef(eqs, ps)\n    vals = Dict()\n\n    for i = 1:length(ps)\n        eq = substitute(eqs[i], vals)\n        vals[ps[i]] = Symbolics.solve_for(eq ~ 0, ps[i])\n    end\n    vals\nend","category":"page"},{"location":"perturbation/02-perturbation_differential/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","text":"solve_coef (generic function with 1 method)","category":"page"},{"location":"perturbation/02-perturbation_differential/#The-Trajectory-of-a-Ball!","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","title":"The Trajectory of a Ball!","text":"","category":"section"},{"location":"perturbation/02-perturbation_differential/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","text":"In the first two examples, we applied the perturbation method to algebraic problems. However, the main power of the perturbation method is to solve differential equations (usually ODEs, but also occasionally PDEs). Surprisingly, the main procedure developed to solve algebraic problems works well for differential equations. In fact, we will use the same two helper functions, collect_powers and solve_coef. The main difference is in the way we expand the dependent variables. For algebraic problems, the coefficients of epsilon are constants; whereas, for differential equations, they are functions of the dependent variable (usually time).","category":"page"},{"location":"perturbation/02-perturbation_differential/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","text":"As the first ODE example, we have chosen a simple and well-behaved problem, which is a variation of a standard first-year physics problem: what is the trajectory of an object (say, a ball or a rocket) thrown vertically at velocity v from the surface of a planet? Assuming a constant acceleration of gravity, g, every burgeoning physicist knows the answer: x(t) = x(0) + vt - frac12gt^2. However, what happens if g is not constant? Specifically, g is inversely proportional to the distant from the center of the planet. If v is large and the projectile travels a large fraction of the radius of the planet, the assumption of constant gravity does not hold anymore. However, unless v is large compared to the escape velocity, the correction is usually small. After simplifications and change of variables to dimensionless, the problem becomes","category":"page"},{"location":"perturbation/02-perturbation_differential/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","text":"$","category":"page"},{"location":"perturbation/02-perturbation_differential/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","text":"\\ddot{x}(t) = -\\frac{1}{(1 + \\epsilon x(t))^2}   \\,, $","category":"page"},{"location":"perturbation/02-perturbation_differential/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","text":"with the initial conditions x(0) = 0, and dotx(0) = 1. Note that for epsilon = 0, this equation transforms back to the standard one. Let's start with defining the variables","category":"page"},{"location":"perturbation/02-perturbation_differential/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","text":"n = 2\n@variables ϵ t y[0:n](t) ∂∂y[0:n]","category":"page"},{"location":"perturbation/02-perturbation_differential/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","text":"4-element Vector{Any}:\n ϵ\n t\n  Symbolics.Num[y₀(t), y₁(t), y₂(t)]\n  Symbolics.Num[∂∂y₀, ∂∂y₁, ∂∂y₂]","category":"page"},{"location":"perturbation/02-perturbation_differential/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","text":"Next, we define x.","category":"page"},{"location":"perturbation/02-perturbation_differential/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","text":"x = def_taylor(ϵ, y[2:end], y[1])","category":"page"},{"location":"perturbation/02-perturbation_differential/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","text":"y₀(t) + ϵ*y₁(t) + y₂(t)*(ϵ^2)","category":"page"},{"location":"perturbation/02-perturbation_differential/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","text":"We need the second derivative of x. It may seem that we can do this using Differential(t); however, this operation needs to wait for a few steps because we need to manipulate the differentials as separate variables. Instead, we define dummy variables ∂∂y as the placeholder for the second derivatives and define","category":"page"},{"location":"perturbation/02-perturbation_differential/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","text":"∂∂x = def_taylor(ϵ, ∂∂y[2:end], ∂∂y[1])","category":"page"},{"location":"perturbation/02-perturbation_differential/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","text":"∂∂y₀ + ϵ*∂∂y₁ + ∂∂y₂*(ϵ^2)","category":"page"},{"location":"perturbation/02-perturbation_differential/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","text":"as the second derivative of x. After rearrangement, our governing equation is ddotx(t)(1 + epsilon x(t))^-2 + 1 = 0, or","category":"page"},{"location":"perturbation/02-perturbation_differential/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","text":"eq = ∂∂x * (1 + ϵ*x)^2 + 1","category":"page"},{"location":"perturbation/02-perturbation_differential/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","text":"1 + (∂∂y₀ + ϵ*∂∂y₁ + ∂∂y₂*(ϵ^2))*((1 + ϵ*(y₀(t) + ϵ*y₁(t) + y₂(t)*(ϵ^2)))^2\n)","category":"page"},{"location":"perturbation/02-perturbation_differential/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","text":"The next two steps are the same as the ones for algebraic equations (note that we pass 0:n to collect_powers because the zeroth order term is needed here)","category":"page"},{"location":"perturbation/02-perturbation_differential/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","text":"eqs = collect_powers(eq, ϵ, 0:n)","category":"page"},{"location":"perturbation/02-perturbation_differential/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","text":"3-element Vector{Any}:\n                                                     1 + ∂∂y₀\n                                1 + ∂∂y₀ + ∂∂y₁ + 2∂∂y₀*y₀(t)\n 1 + ∂∂y₀ + ∂∂y₂ + ∂∂y₀*(y₀(t)^2) + 2∂∂y₀*y₁(t) + 2∂∂y₁*y₀(t)","category":"page"},{"location":"perturbation/02-perturbation_differential/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","text":"and,","category":"page"},{"location":"perturbation/02-perturbation_differential/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","text":"vals = solve_coef(eqs, ∂∂y)","category":"page"},{"location":"perturbation/02-perturbation_differential/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","text":"Dict{Any, Any} with 3 entries:\n  ∂∂y₁ => 2.0y₀(t)\n  ∂∂y₂ => 2.0y₁(t) - (3.0(y₀(t)^2))\n  ∂∂y₀ => -1.0","category":"page"},{"location":"perturbation/02-perturbation_differential/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","text":"Our system of ODEs is forming. Now is the time to convert ∂∂s to the correct Symbolics.jl form by substitution:","category":"page"},{"location":"perturbation/02-perturbation_differential/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","text":"D = Differential(t)\nsubs = Dict(∂∂y[i] => D(D(y[i])) for i in eachindex(y))\neqs = [substitute(first(v), subs) ~ substitute(last(v), subs) for v in vals]","category":"page"},{"location":"perturbation/02-perturbation_differential/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","text":"3-element Vector{Symbolics.Equation}:\n Differential(t)(Differential(t)(y₁(t))) ~ 2.0y₀(t)\n Differential(t)(Differential(t)(y₂(t))) ~ 2.0y₁(t) - (3.0(y₀(t)^2))\n Differential(t)(Differential(t)(y₀(t))) ~ -1.0","category":"page"},{"location":"perturbation/02-perturbation_differential/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","text":"We are nearly there! From this point on, the rest is standard ODE solving procedures. Potentially we can use a symbolic ODE solver to find a closed form solution to this problem. However, Symbolics.jl currently does not support this functionality. Instead, we solve the problem numerically. We form an ODESystem, lower the order (convert second derivatives to first), generate an ODEProblem (after passing the correct initial conditions), and, finally, solve it.","category":"page"},{"location":"perturbation/02-perturbation_differential/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","text":"using ModelingToolkit, DifferentialEquations\n\nsys = ODESystem(eqs, t)\nsys = ode_order_lowering(sys)\nstates(sys)","category":"page"},{"location":"perturbation/02-perturbation_differential/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","text":"6-element Vector{Any}:\n y₁ˍt(t)\n y₂ˍt(t)\n y₀ˍt(t)\n y₁(t)\n y₂(t)\n y₀(t)","category":"page"},{"location":"perturbation/02-perturbation_differential/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","text":"# the initial conditions\n# everything is zero except the initial velocity\nu0 = zeros(2n+2)\nu0[3] = 1.0   # y₀ˍt\n\nprob = ODEProblem(sys, u0, (0, 3.0))\nsol = solve(prob; dtmax=0.01)","category":"page"},{"location":"perturbation/02-perturbation_differential/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","text":"retcode: Success\nInterpolation: automatic order switching interpolation\nt: 302-element Vector{Float64}:\n 0.0\n 0.0009990005004983772\n 0.010989005505482149\n 0.020989005505482147\n 0.03098900550548215\n 0.04098900550548215\n 0.05098900550548215\n 0.060989005505482155\n 0.07098900550548215\n 0.08098900550548215\n ⋮\n 2.920989005505464\n 2.930989005505464\n 2.9409890055054637\n 2.9509890055054635\n 2.9609890055054633\n 2.970989005505463\n 2.980989005505463\n 2.9909890055054627\n 3.0\nu: 302-element Vector{Vector{Float64}}:\n [0.0, 0.0, 1.0, 0.0, 0.0, 0.0]\n [9.976696651635089e-7, -9.96091672587352e-10, 0.9990009994995016, 3.322518\n3183212947e-10, -2.488196097577267e-13, 0.0009985014994983792]\n [0.00012031590433746151, -1.313675024660254e-6, 0.9890109944945178, 4.4112\n24493041101e-7, -3.6163136458534604e-9, 0.010928626384482389]\n [0.00043745619814322776, -9.069307488622044e-6, 0.9790109944945178, 3.0659\n81129291793e-6, -4.777432914805544e-8, 0.02076873632942756]\n [0.0009503986908478969, -2.891919290301644e-5, 0.9690109944945178, 9.84292\n0408498354e-6, -2.253405719858556e-7, 0.030508846274372736]\n [0.0016571433824514696, -6.62992778592017e-5, 0.9590109944945178, 2.271996\n227591275e-5, -6.846158733026939e-7, 0.04014895621931791]\n [0.0025556902729539453, -0.0001264323265297471, 0.9490109944945178, 4.3625\n12872052407e-5, -1.6271927847283168e-6, 0.04968906616426308]\n [0.0036440393623553254, -0.0002143301206684335, 0.9390109944945177, 7.4466\n44173132131e-5, -3.3058347541908906e-6, 0.05912917610920825]\n [0.004920190650655609, -0.0003347956596102526, 0.9290109944945177, 0.00011\n713192329729352, -6.022377301729108e-6, 0.06846928605415342]\n [0.006382144137854795, -0.0004924253602714071, 0.9190109944945177, 0.00017\n348959540742975, -1.0125651195304294e-5, 0.0777093959990986]\n ⋮\n [0.22471192394104525, 2.8247253103418704, -1.9209890055054843, 2.240961476\n3951557, 1.8060647625748494, -1.3450993796364734]\n [0.1976175041144319, 2.814507114834879, -1.9309890055054844, 2.24307344453\n3601, 1.8342621940922712, -1.3643592696915283]\n [0.17013688648671746, 2.8027476697776446, -1.9409890055054844, 2.244912539\n151441, 1.8623497674202474, -1.3837191597465832]\n [0.14226807105790193, 2.789410746307444, -1.9509890055054844, 2.2464748882\n70665, 1.8903118892738933, -1.403179049801638]\n [0.11400905782798529, 2.7744596885439723, -1.9609890055054844, 2.247756599\n913262, 1.9181326019464422, -1.422738939856693]\n [0.08535784679696758, 2.757857411389343, -1.9709890055054844, 2.2487537621\n01221, 1.94579557902807, -1.4423988299117478]\n [0.05631243796484875, 2.7395663983280887, -1.9809890055054844, 2.249462442\n856531, 1.9732841211027194, -1.4621587199668027]\n [0.026870831331628833, 2.7195486992271602, -1.9909890055054844, 2.24987869\n0201181, 2.000581151422923, -1.4820186100218575]\n [-6.521976042861373e-14, 2.6999999999999384, -2.0000000000000218, 2.249999\n999999993, 2.024999999999945, -1.5000000000000422]","category":"page"},{"location":"perturbation/02-perturbation_differential/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","text":"Finally, we calculate the solution to the problem as a function of ϵ by substituting the solution to the ODE system back into the defining equation for x. Note that 𝜀 is a number, compared to ϵ, which is a symbolic variable.","category":"page"},{"location":"perturbation/02-perturbation_differential/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","text":"X = 𝜀 -> sum([𝜀^(i-1) * sol[y[i]] for i in eachindex(y)])","category":"page"},{"location":"perturbation/02-perturbation_differential/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","text":"#16 (generic function with 1 method)","category":"page"},{"location":"perturbation/02-perturbation_differential/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","text":"Using X, we can plot the trajectory for a range of 𝜀s.","category":"page"},{"location":"perturbation/02-perturbation_differential/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","text":"using Plots\n\nplot(sol.t, hcat([X(𝜀) for 𝜀 = 0.0:0.1:0.5]...))","category":"page"},{"location":"perturbation/02-perturbation_differential/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","text":"(Image: )","category":"page"},{"location":"perturbation/02-perturbation_differential/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","text":"As expected, as 𝜀 becomes larger (meaning the gravity is less with altitude), the object goes higher and stays up for a longer duration. Of course, we could have solved the problem directly using as ODE solver. One of the benefits of the perturbation method is that we need to run the ODE solver only once and then can just calculate the answer for different values of 𝜀; whereas, if we had used the direct method, we would need to run the solver once for each value of 𝜀.","category":"page"},{"location":"perturbation/02-perturbation_differential/#A-Weakly-Nonlinear-Oscillator","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","title":"A Weakly Nonlinear Oscillator","text":"","category":"section"},{"location":"perturbation/02-perturbation_differential/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","text":"For the next example, we have chosen a simple example from a very important class of problems, the nonlinear oscillators. As we will see, perturbation theory has difficulty providing a good solution to this problem, but the process is instructive. This example closely follows the chapter 7.6 of Nonlinear Dynamics and Chaos by Steven Strogatz.","category":"page"},{"location":"perturbation/02-perturbation_differential/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","text":"The goal is to solve ddotx + 2epsilondotx + x = 0, where the dot signifies time-derivatives and the initial conditions are x(0) = 0 and dotx(0) = 1. If epsilon = 0, the problem reduces to the simple linear harmonic oscillator with the exact solution x(t) = sin(t). We follow the same steps as the previous example.","category":"page"},{"location":"perturbation/02-perturbation_differential/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","text":"n = 2\n@variables ϵ t y[0:n](t) ∂y[0:n] ∂∂y[0:n]\nx = def_taylor(ϵ, y[2:end], y[1])\n∂x = def_taylor(ϵ, ∂y[2:end], ∂y[1])\n∂∂x = def_taylor(ϵ, ∂∂y[2:end], ∂∂y[1])","category":"page"},{"location":"perturbation/02-perturbation_differential/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","text":"∂∂y₀ + ϵ*∂∂y₁ + ∂∂y₂*(ϵ^2)","category":"page"},{"location":"perturbation/02-perturbation_differential/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","text":"This time we also need the first derivative terms. Continuing,","category":"page"},{"location":"perturbation/02-perturbation_differential/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","text":"eq = ∂∂x + 2*ϵ*∂x + x\neqs = collect_powers(eq, ϵ, 0:n)\nvals = solve_coef(eqs, ∂∂y)","category":"page"},{"location":"perturbation/02-perturbation_differential/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","text":"Dict{Any, Any} with 3 entries:\n  ∂∂y₁ => -2.0∂y₀ - y₁(t)\n  ∂∂y₂ => -2.0∂y₁ - y₂(t)\n  ∂∂y₀ => -y₀(t)","category":"page"},{"location":"perturbation/02-perturbation_differential/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","text":"Next, we need to replace ∂s and ∂∂s with their Symbolics.jl counterparts:","category":"page"},{"location":"perturbation/02-perturbation_differential/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","text":"D = Differential(t)\nsubs1 = Dict(∂y[i] => D(y[i]) for i in eachindex(y))\nsubs2 = Dict(∂∂y[i] => D(D(y[i])) for i in eachindex(y))\nsubs = subs1 ∪ subs2\neqs = [substitute(first(v), subs) ~ substitute(last(v), subs) for v in vals]","category":"page"},{"location":"perturbation/02-perturbation_differential/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","text":"3-element Vector{Symbolics.Equation}:\n Differential(t)(Differential(t)(y₁(t))) ~ -y₁(t) - (2.0Differential(t)(y₀(\nt)))\n Differential(t)(Differential(t)(y₂(t))) ~ -y₂(t) - (2.0Differential(t)(y₁(\nt)))\n Differential(t)(Differential(t)(y₀(t))) ~ -y₀(t)","category":"page"},{"location":"perturbation/02-perturbation_differential/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","text":"We continue with converting 'eqs' to an ODEProblem, solving it, and finally plot the results against the exact solution to the original problem, which is x(t epsilon) = (1 - epsilon)^-12 e^-epsilon t sin((1- epsilon^2)^12t),","category":"page"},{"location":"perturbation/02-perturbation_differential/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","text":"sys = ODESystem(eqs, t)\nsys = ode_order_lowering(sys)","category":"page"},{"location":"perturbation/02-perturbation_differential/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","text":"Model ##ODESystem#8559 with 6 equations\nStates (6):\n  y₁ˍt(t)\n  y₂ˍt(t)\n  y₀ˍt(t)\n  y₁(t)\n⋮\nParameters (0):","category":"page"},{"location":"perturbation/02-perturbation_differential/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","text":"# the initial conditions\nu0 = zeros(2n+2)\nu0[3] = 1.0   # y₀ˍt\n\nprob = ODEProblem(sys, u0, (0, 50.0))\nsol = solve(prob; dtmax=0.01)\n\nX = 𝜀 -> sum([𝜀^(i-1) * sol[y[i]] for i in eachindex(y)])\nT = sol.t\nY = 𝜀 -> exp.(-𝜀*T) .* sin.(sqrt(1 - 𝜀^2)*T) / sqrt(1 - 𝜀^2)    # exact solution\n\nplot(sol.t, [Y(0.1), X(0.1)])","category":"page"},{"location":"perturbation/02-perturbation_differential/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","text":"(Image: )","category":"page"},{"location":"perturbation/02-perturbation_differential/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","text":"The figure is similar to Figure 7.6.2 in Nonlinear Dynamics and Chaos. The two curves fit well for the first couple of cycles, but then the perturbation method curve diverges from the true solution. The main reason is that the problem has two or more time-scales that introduce secular terms in the solution. One solution is to explicitly account for the two time scales and use an analytic method called two-timing.","category":"page"},{"location":"perturbation/02-perturbation_differential/#Appendix","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","title":"Appendix","text":"","category":"section"},{"location":"perturbation/02-perturbation_differential/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","text":"These tutorials are a part of the SciMLTutorials.jl repository, found at: https://github.com/SciML/SciMLTutorials.jl. For more information on high-performance scientific machine learning, check out the SciML Open Source Software Organization https://sciml.ai.","category":"page"},{"location":"perturbation/02-perturbation_differential/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","text":"To locally run this tutorial, do the following commands:","category":"page"},{"location":"perturbation/02-perturbation_differential/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","text":"using SciMLTutorials\nSciMLTutorials.weave_file(\"tutorials/perturbation\",\"02-perturbation_differential.jmd\")","category":"page"},{"location":"perturbation/02-perturbation_differential/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","text":"Computer Information:","category":"page"},{"location":"perturbation/02-perturbation_differential/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","text":"Julia Version 1.6.2\nCommit 1b93d53fc4 (2021-07-14 15:36 UTC)\nPlatform Info:\n  OS: Linux (x86_64-pc-linux-gnu)\n  CPU: AMD EPYC 7502 32-Core Processor\n  WORD_SIZE: 64\n  LIBM: libopenlibm\n  LLVM: libLLVM-11.0.1 (ORCJIT, znver2)\nEnvironment:\n  JULIA_DEPOT_PATH = /root/.cache/julia-buildkite-plugin/depots/a6029d3a-f78b-41ea-bc97-28aa57c6c6ea\n  JULIA_NUM_THREADS = 16\n","category":"page"},{"location":"perturbation/02-perturbation_differential/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","text":"Package Information:","category":"page"},{"location":"perturbation/02-perturbation_differential/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","text":"      Status `/var/lib/buildkite-agent/builds/2-amdci4-julia-csail-mit-edu/julialang/scimltutorials-dot-jl/tutorials/perturbation/Project.toml`\n  [0c46a032] DifferentialEquations v6.17.1\n  [961ee093] ModelingToolkit v5.17.3\n  [91a5bcdd] Plots v1.15.2\n  [30cb0354] SciMLTutorials v0.9.0\n  [d1185830] SymbolicUtils v0.11.2\n  [0c5d862f] Symbolics v0.1.25","category":"page"},{"location":"perturbation/02-perturbation_differential/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","text":"And the full manifest:","category":"page"},{"location":"perturbation/02-perturbation_differential/","page":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","title":"Mixed Symbolic/Numerical Methods for Perturbation Theory - Differential Equations","text":"      Status `/var/lib/buildkite-agent/builds/2-amdci4-julia-csail-mit-edu/julialang/scimltutorials-dot-jl/tutorials/perturbation/Manifest.toml`\n  [c3fe647b] AbstractAlgebra v0.16.0\n  [1520ce14] AbstractTrees v0.3.4\n  [79e6a3ab] Adapt v3.3.0\n  [ec485272] ArnoldiMethod v0.1.0\n  [4fba245c] ArrayInterface v3.1.15\n  [4c555306] ArrayLayouts v0.7.0\n  [aae01518] BandedMatrices v0.16.9\n  [764a87c0] BoundaryValueDiffEq v2.7.1\n  [fa961155] CEnum v0.4.1\n  [00ebfdb7] CSTParser v2.5.0\n  [d360d2e6] ChainRulesCore v0.9.44\n  [b630d9fa] CheapThreads v0.2.5\n  [35d6a980] ColorSchemes v3.12.1\n  [3da002f7] ColorTypes v0.11.0\n  [5ae59095] Colors v0.12.8\n  [861a8166] Combinatorics v1.0.2\n  [a80b9123] CommonMark v0.8.1\n  [38540f10] CommonSolve v0.2.0\n  [bbf7d656] CommonSubexpressions v0.3.0\n  [34da2185] Compat v3.30.0\n  [8f4d0f93] Conda v1.5.2\n  [187b0558] ConstructionBase v1.2.1\n  [d38c429a] Contour v0.5.7\n  [a8cc5b0e] Crayons v4.0.4\n  [9a962f9c] DataAPI v1.6.0\n  [864edb3b] DataStructures v0.18.9\n  [e2d170a0] DataValueInterfaces v1.0.0\n  [bcd4f6db] DelayDiffEq v5.31.0\n  [2b5f629d] DiffEqBase v6.62.2\n  [459566f4] DiffEqCallbacks v2.16.1\n  [5a0ffddc] DiffEqFinancial v2.4.0\n  [c894b116] DiffEqJump v6.14.2\n  [77a26b50] DiffEqNoiseProcess v5.7.3\n  [055956cb] DiffEqPhysics v3.9.0\n  [163ba53b] DiffResults v1.0.3\n  [b552c78f] DiffRules v1.0.2\n  [0c46a032] DifferentialEquations v6.17.1\n  [c619ae07] DimensionalPlotRecipes v1.2.0\n  [b4f34e82] Distances v0.10.3\n  [31c24e10] Distributions v0.24.18\n  [ffbed154] DocStringExtensions v0.8.4\n  [e30172f5] Documenter v0.26.3\n  [d4d017d3] ExponentialUtilities v1.8.4\n  [e2ba6199] ExprTools v0.1.3\n  [c87230d0] FFMPEG v0.4.0\n  [7034ab61] FastBroadcast v0.1.8\n  [9aa1b823] FastClosures v0.3.2\n  [1a297f60] FillArrays v0.11.7\n  [6a86dc24] FiniteDiff v2.8.0\n  [53c48c17] FixedPointNumbers v0.8.4\n  [59287772] Formatting v0.4.2\n  [f6369f11] ForwardDiff v0.10.18\n  [069b7b12] FunctionWrappers v1.1.2\n  [28b8d3ca] GR v0.57.4\n  [5c1252a2] GeometryBasics v0.3.12\n  [42e2da0e] Grisu v1.0.2\n  [cd3eb016] HTTP v0.9.9\n  [eafb193a] Highlights v0.4.5\n  [0e44f5e4] Hwloc v2.0.0\n  [7073ff75] IJulia v1.23.2\n  [b5f81e59] IOCapture v0.1.1\n  [615f187c] IfElse v0.1.0\n  [d25df0c9] Inflate v0.1.2\n  [83e8ac13] IniFile v0.5.0\n  [c8e1da08] IterTools v1.3.0\n  [42fd0dbc] IterativeSolvers v0.9.1\n  [82899510] IteratorInterfaceExtensions v1.0.0\n  [692b3bcd] JLLWrappers v1.3.0\n  [682c06a0] JSON v0.21.1\n  [98e50ef6] JuliaFormatter v0.13.7\n  [b964fa9f] LaTeXStrings v1.2.1\n  [2ee39098] LabelledArrays v1.6.1\n  [23fbe1c1] Latexify v0.15.5\n  [093fc24a] LightGraphs v1.3.5\n  [d3d80556] LineSearches v7.1.1\n  [2ab3a3ac] LogExpFunctions v0.2.4\n  [bdcacae8] LoopVectorization v0.12.23\n  [1914dd2f] MacroTools v0.5.6\n  [739be429] MbedTLS v1.0.3\n  [442fdcdd] Measures v0.3.1\n  [e1d29d7a] Missings v1.0.0\n  [961ee093] ModelingToolkit v5.17.3\n  [46d2c3a1] MuladdMacro v0.2.2\n  [f9640e96] MultiScaleArrays v1.8.1\n  [ffc61752] Mustache v1.0.10\n  [d41bc354] NLSolversBase v7.8.0\n  [2774e3e8] NLsolve v4.5.1\n  [77ba4419] NaNMath v0.3.5\n  [8913a72c] NonlinearSolve v0.3.8\n  [6fe1bfb0] OffsetArrays v1.9.0\n  [429524aa] Optim v1.3.0\n  [bac558e1] OrderedCollections v1.4.1\n  [1dea7af3] OrdinaryDiffEq v5.56.0\n  [90014a1f] PDMats v0.11.0\n  [65888b18] ParameterizedFunctions v5.10.0\n  [d96e819e] Parameters v0.12.2\n  [69de0a69] Parsers v1.1.0\n  [ccf2f8ad] PlotThemes v2.0.1\n  [995b91a9] PlotUtils v1.0.10\n  [91a5bcdd] Plots v1.15.2\n  [e409e4f3] PoissonRandom v0.4.0\n  [f517fe37] Polyester v0.3.1\n  [85a6dd25] PositiveFactorizations v0.2.4\n  [21216c6a] Preferences v1.2.2\n  [1fd47b50] QuadGK v2.4.1\n  [74087812] Random123 v1.3.1\n  [fb686558] RandomExtensions v0.4.3\n  [e6cf234a] RandomNumbers v1.4.0\n  [3cdcf5f2] RecipesBase v1.1.1\n  [01d81517] RecipesPipeline v0.3.2\n  [731186ca] RecursiveArrayTools v2.11.4\n  [f2c3362d] RecursiveFactorization v0.1.12\n  [189a3867] Reexport v1.0.0\n  [ae029012] Requires v1.1.3\n  [ae5879a3] ResettableStacks v1.1.0\n  [79098fc4] Rmath v0.7.0\n  [7e49a35a] RuntimeGeneratedFunctions v0.5.2\n  [476501e8] SLEEFPirates v0.6.20\n  [1bc83da4] SafeTestsets v0.0.1\n  [0bca4576] SciMLBase v1.13.4\n  [30cb0354] SciMLTutorials v0.9.0\n  [6c6a2e73] Scratch v1.0.3\n  [efcf1570] Setfield v0.7.0\n  [992d4aef] Showoff v1.0.3\n  [699a6c99] SimpleTraits v0.9.3\n  [b85f4697] SoftGlobalScope v1.1.0\n  [a2af1166] SortingAlgorithms v1.0.0\n  [47a9eef4] SparseDiffTools v1.13.2\n  [276daf66] SpecialFunctions v1.4.1\n  [aedffcd0] Static v0.2.4\n  [90137ffa] StaticArrays v1.2.0\n  [82ae8749] StatsAPI v1.0.0\n  [2913bbd2] StatsBase v0.33.8\n  [4c63d2b9] StatsFuns v0.9.8\n  [9672c7b4] SteadyStateDiffEq v1.6.2\n  [789caeaf] StochasticDiffEq v6.34.1\n  [7792a7ef] StrideArraysCore v0.1.11\n  [09ab397b] StructArrays v0.5.1\n  [c3572dad] Sundials v4.4.3\n  [d1185830] SymbolicUtils v0.11.2\n  [0c5d862f] Symbolics v0.1.25\n  [3783bdb8] TableTraits v1.0.1\n  [bd369af6] Tables v1.4.2\n  [8290d209] ThreadingUtilities v0.4.4\n  [a759f4b9] TimerOutputs v0.5.9\n  [0796e94c] Tokenize v0.5.16\n  [a2a6695c] TreeViews v0.3.0\n  [5c2747f8] URIs v1.3.0\n  [3a884ed6] UnPack v1.0.2\n  [1986cc42] Unitful v1.7.0\n  [3d5dd08c] VectorizationBase v0.20.11\n  [81def892] VersionParsing v1.2.0\n  [19fa3120] VertexSafeGraphs v0.1.2\n  [44d3d7a6] Weave v0.10.8\n  [ddb6d928] YAML v0.4.6\n  [c2297ded] ZMQ v1.2.1\n  [700de1a5] ZygoteRules v0.2.1\n  [6e34b625] Bzip2_jll v1.0.6+5\n  [83423d85] Cairo_jll v1.16.0+6\n  [5ae413db] EarCut_jll v2.1.5+1\n  [2e619515] Expat_jll v2.2.10+0\n  [b22a6f82] FFMPEG_jll v4.3.1+4\n  [a3f928ae] Fontconfig_jll v2.13.1+14\n  [d7e528f0] FreeType2_jll v2.10.1+5\n  [559328eb] FriBidi_jll v1.0.5+6\n  [0656b61e] GLFW_jll v3.3.4+0\n  [d2c73de3] GR_jll v0.57.2+0\n  [78b55507] Gettext_jll v0.21.0+0\n  [7746bdde] Glib_jll v2.68.1+0\n  [e33a78d0] Hwloc_jll v2.4.1+0\n  [aacddb02] JpegTurbo_jll v2.0.1+3\n  [c1c5ebd0] LAME_jll v3.100.0+3\n  [dd4b983a] LZO_jll v2.10.1+0\n  [dd192d2f] LibVPX_jll v1.9.0+1\n  [e9f186c6] Libffi_jll v3.2.2+0\n  [d4300ac3] Libgcrypt_jll v1.8.7+0\n  [7e76a0d4] Libglvnd_jll v1.3.0+3\n  [7add5ba3] Libgpg_error_jll v1.42.0+0\n  [94ce4f54] Libiconv_jll v1.16.1+0\n  [4b2f31a3] Libmount_jll v2.35.0+0\n  [89763e89] Libtiff_jll v4.1.0+2\n  [38a345b3] Libuuid_jll v2.36.0+0\n  [e7412a2a] Ogg_jll v1.3.4+2\n  [458c3c95] OpenSSL_jll v1.1.1+6\n  [efe28fd5] OpenSpecFun_jll v0.5.4+0\n  [91d4177d] Opus_jll v1.3.1+3\n  [2f80f16e] PCRE_jll v8.44.0+0\n  [30392449] Pixman_jll v0.40.1+0\n  [ea2cea3b] Qt5Base_jll v5.15.2+0\n  [f50d1b31] Rmath_jll v0.3.0+0\n  [fb77eaff] Sundials_jll v5.2.0+1\n  [a2964d1f] Wayland_jll v1.17.0+4\n  [2381bf8a] Wayland_protocols_jll v1.18.0+4\n  [02c8fc9c] XML2_jll v2.9.12+0\n  [aed1982a] XSLT_jll v1.1.34+0\n  [4f6342f7] Xorg_libX11_jll v1.6.9+4\n  [0c0b7dd1] Xorg_libXau_jll v1.0.9+4\n  [935fb764] Xorg_libXcursor_jll v1.2.0+4\n  [a3789734] Xorg_libXdmcp_jll v1.1.3+4\n  [1082639a] Xorg_libXext_jll v1.3.4+4\n  [d091e8ba] Xorg_libXfixes_jll v5.0.3+4\n  [a51aa0fd] Xorg_libXi_jll v1.7.10+4\n  [d1454406] Xorg_libXinerama_jll v1.1.4+4\n  [ec84b674] Xorg_libXrandr_jll v1.5.2+4\n  [ea2f1a96] Xorg_libXrender_jll v0.9.10+4\n  [14d82f49] Xorg_libpthread_stubs_jll v0.1.0+3\n  [c7cfdc94] Xorg_libxcb_jll v1.13.0+3\n  [cc61e674] Xorg_libxkbfile_jll v1.1.0+4\n  [12413925] Xorg_xcb_util_image_jll v0.4.0+1\n  [2def613f] Xorg_xcb_util_jll v0.4.0+1\n  [975044d2] Xorg_xcb_util_keysyms_jll v0.4.0+1\n  [0d47668e] Xorg_xcb_util_renderutil_jll v0.3.9+1\n  [c22f9ab0] Xorg_xcb_util_wm_jll v0.4.1+1\n  [35661453] Xorg_xkbcomp_jll v1.4.2+4\n  [33bec58e] Xorg_xkeyboard_config_jll v2.27.0+4\n  [c5fb5394] Xorg_xtrans_jll v1.4.0+3\n  [8f1865be] ZeroMQ_jll v4.3.2+6\n  [3161d3a3] Zstd_jll v1.5.0+0\n  [0ac62f75] libass_jll v0.14.0+4\n  [f638f0a6] libfdk_aac_jll v0.1.6+4\n  [b53b4c65] libpng_jll v1.6.38+0\n  [a9144af2] libsodium_jll v1.0.20+0\n  [f27f6e37] libvorbis_jll v1.3.6+6\n  [1270edf5] x264_jll v2020.7.14+2\n  [dfaa095f] x265_jll v3.0.0+3\n  [d8fb68d0] xkbcommon_jll v0.9.1+5\n  [0dad84c5] ArgTools\n  [56f22d72] Artifacts\n  [2a0f44e3] Base64\n  [ade2ca70] Dates\n  [8bb1440f] DelimitedFiles\n  [8ba89e20] Distributed\n  [f43a241f] Downloads\n  [7b1f6079] FileWatching\n  [9fa8497b] Future\n  [b77e0a4c] InteractiveUtils\n  [b27032c2] LibCURL\n  [76f85450] LibGit2\n  [8f399da3] Libdl\n  [37e2e46d] LinearAlgebra\n  [56ddb016] Logging\n  [d6f4376e] Markdown\n  [a63ad114] Mmap\n  [ca575930] NetworkOptions\n  [44cfe95a] Pkg\n  [de0858da] Printf\n  [3fa0cd96] REPL\n  [9a3f8284] Random\n  [ea8e919c] SHA\n  [9e88b42a] Serialization\n  [1a1011a3] SharedArrays\n  [6462fe0b] Sockets\n  [2f01184e] SparseArrays\n  [10745b16] Statistics\n  [4607b0f0] SuiteSparse\n  [fa267f1f] TOML\n  [a4e569a6] Tar\n  [8dfed614] Test\n  [cf7118a7] UUIDs\n  [4ec0a83e] Unicode\n  [e66e0078] CompilerSupportLibraries_jll\n  [deac9b47] LibCURL_jll\n  [29816b5a] LibSSH2_jll\n  [c8ffd9c3] MbedTLS_jll\n  [14a3606d] MozillaCACerts_jll\n  [4536629a] OpenBLAS_jll\n  [bea87d4a] SuiteSparse_jll\n  [83775a58] Zlib_jll\n  [8e850ede] nghttp2_jll\n  [3f19e933] p7zip_jll","category":"page"},{"location":"type_handling/02-uncertainties/#Numbers-with-Uncertainties","page":"Numbers with Uncertainties","title":"Numbers with Uncertainties","text":"","category":"section"},{"location":"type_handling/02-uncertainties/","page":"Numbers with Uncertainties","title":"Numbers with Uncertainties","text":"The result of a measurement should be given as a number with an attached uncertainties, besides the physical unit, and all operations performed involving the result of the measurement should propagate the uncertainty, taking care of correlation between quantities.","category":"page"},{"location":"type_handling/02-uncertainties/","page":"Numbers with Uncertainties","title":"Numbers with Uncertainties","text":"There is a Julia package for dealing with numbers with uncertainties: Measurements.jl.  Thanks to Julia's features, DifferentialEquations.jl easily works together with Measurements.jl out-of-the-box.","category":"page"},{"location":"type_handling/02-uncertainties/","page":"Numbers with Uncertainties","title":"Numbers with Uncertainties","text":"This notebook will cover some of the examples from the tutorial about classical Physics.","category":"page"},{"location":"type_handling/02-uncertainties/#Caveat-about-Measurement-type","page":"Numbers with Uncertainties","title":"Caveat about Measurement type","text":"","category":"section"},{"location":"type_handling/02-uncertainties/","page":"Numbers with Uncertainties","title":"Numbers with Uncertainties","text":"Before going on with the tutorial, we must point up a subtlety of Measurements.jl that you should be aware of:","category":"page"},{"location":"type_handling/02-uncertainties/","page":"Numbers with Uncertainties","title":"Numbers with Uncertainties","text":"\nusing Measurements\n\n5.23 ± 0.14 === 5.23 ± 0.14","category":"page"},{"location":"type_handling/02-uncertainties/","page":"Numbers with Uncertainties","title":"Numbers with Uncertainties","text":"false","category":"page"},{"location":"type_handling/02-uncertainties/","page":"Numbers with Uncertainties","title":"Numbers with Uncertainties","text":"\n(5.23± 0.14) - (5.23 ± 0.14)","category":"page"},{"location":"type_handling/02-uncertainties/","page":"Numbers with Uncertainties","title":"Numbers with Uncertainties","text":"0.0 ± 0.2","category":"page"},{"location":"type_handling/02-uncertainties/","page":"Numbers with Uncertainties","title":"Numbers with Uncertainties","text":"\n(5.23 ± 0.14) / (5.23 ± 0.14)","category":"page"},{"location":"type_handling/02-uncertainties/","page":"Numbers with Uncertainties","title":"Numbers with Uncertainties","text":"1.0 ± 0.038","category":"page"},{"location":"type_handling/02-uncertainties/","page":"Numbers with Uncertainties","title":"Numbers with Uncertainties","text":"The two numbers above, even though have the same nominal value and the same uncertainties, are actually two different measurements that only by chance share the same figures and their difference and their ratio have a non-zero uncertainty.  It is common in physics to get very similar, or even equal, results for a repeated measurement, but the two measurements are not the same thing.","category":"page"},{"location":"type_handling/02-uncertainties/","page":"Numbers with Uncertainties","title":"Numbers with Uncertainties","text":"Instead, if you have one measurement and want to perform some operations involving it, you have to assign it to a variable:","category":"page"},{"location":"type_handling/02-uncertainties/","page":"Numbers with Uncertainties","title":"Numbers with Uncertainties","text":"\nx = 5.23 ± 0.14\nx === x","category":"page"},{"location":"type_handling/02-uncertainties/","page":"Numbers with Uncertainties","title":"Numbers with Uncertainties","text":"true","category":"page"},{"location":"type_handling/02-uncertainties/","page":"Numbers with Uncertainties","title":"Numbers with Uncertainties","text":"\nx - x","category":"page"},{"location":"type_handling/02-uncertainties/","page":"Numbers with Uncertainties","title":"Numbers with Uncertainties","text":"0.0 ± 0.0","category":"page"},{"location":"type_handling/02-uncertainties/","page":"Numbers with Uncertainties","title":"Numbers with Uncertainties","text":"\nx / x","category":"page"},{"location":"type_handling/02-uncertainties/","page":"Numbers with Uncertainties","title":"Numbers with Uncertainties","text":"1.0 ± 0.0","category":"page"},{"location":"type_handling/02-uncertainties/#Radioactive-Decay-of-Carbon-14","page":"Numbers with Uncertainties","title":"Radioactive Decay of Carbon-14","text":"","category":"section"},{"location":"type_handling/02-uncertainties/","page":"Numbers with Uncertainties","title":"Numbers with Uncertainties","text":"The rate of decay of carbon-14 is governed by a first order linear ordinary differential equation","category":"page"},{"location":"type_handling/02-uncertainties/","page":"Numbers with Uncertainties","title":"Numbers with Uncertainties","text":"fracmathrmdu(t)mathrmdt = -fracu(t)tau","category":"page"},{"location":"type_handling/02-uncertainties/","page":"Numbers with Uncertainties","title":"Numbers with Uncertainties","text":"where tau is the mean lifetime of carbon-14, which is related to the half-life t_12 = (5730 pm 40) years by the relation tau = t_12ln(2).","category":"page"},{"location":"type_handling/02-uncertainties/","page":"Numbers with Uncertainties","title":"Numbers with Uncertainties","text":"\nusing DifferentialEquations, Measurements, Plots\n\n# Half-life and mean lifetime of radiocarbon, in years\nt_12 = 5730 ± 40\nτ = t_12 / log(2)\n\n#Setup\nu₀ = 1 ± 0\ntspan = (0.0, 10000.0)\n\n#Define the problem\nradioactivedecay(u,p,t) = - u / τ\n\n#Pass to solver\nprob = ODEProblem(radioactivedecay, u₀, tspan)\nsol = solve(prob, Tsit5(), reltol = 1e-8)\n\n# Analytic solution\nu = exp.(- sol.t / τ)\n\nplot(sol.t, sol.u, label = \"Numerical\", xlabel = \"Years\", ylabel = \"Fraction of Carbon-14\")\nplot!(sol.t, u, label = \"Analytic\")","category":"page"},{"location":"type_handling/02-uncertainties/","page":"Numbers with Uncertainties","title":"Numbers with Uncertainties","text":"(Image: )","category":"page"},{"location":"type_handling/02-uncertainties/","page":"Numbers with Uncertainties","title":"Numbers with Uncertainties","text":"The two curves are perfectly superimposed, indicating that the numerical solution matches the analytic one.  We can check that also the uncertainties are correctly propagated in the numerical solution:","category":"page"},{"location":"type_handling/02-uncertainties/","page":"Numbers with Uncertainties","title":"Numbers with Uncertainties","text":"\nprintln(\"Quantity of carbon-14 after \",  sol.t[11], \" years:\")\nprintln(\"Numerical: \", sol[11])\nprintln(\"Analytic:  \", u[11])","category":"page"},{"location":"type_handling/02-uncertainties/","page":"Numbers with Uncertainties","title":"Numbers with Uncertainties","text":"Quantity of carbon-14 after 5207.541347908455 years:\nNumerical: 0.5326 ± 0.0023\nAnalytic:  0.5326 ± 0.0023","category":"page"},{"location":"type_handling/02-uncertainties/","page":"Numbers with Uncertainties","title":"Numbers with Uncertainties","text":"Both the value of the numerical solution and its uncertainty match the analytic solution within the requested tolerance.  We can also note that close to 5730 years after the beginning of the decay (half-life of the radioisotope), the fraction of carbon-14 that survived is about 0.5.","category":"page"},{"location":"type_handling/02-uncertainties/#Simple-pendulum","page":"Numbers with Uncertainties","title":"Simple pendulum","text":"","category":"section"},{"location":"type_handling/02-uncertainties/#Small-angles-approximation","page":"Numbers with Uncertainties","title":"Small angles approximation","text":"","category":"section"},{"location":"type_handling/02-uncertainties/","page":"Numbers with Uncertainties","title":"Numbers with Uncertainties","text":"The next problem we are going to study is the simple pendulum in the approximation of small angles.  We address this simplified case because there exists an easy analytic solution to compare.","category":"page"},{"location":"type_handling/02-uncertainties/","page":"Numbers with Uncertainties","title":"Numbers with Uncertainties","text":"The differential equation we want to solve is","category":"page"},{"location":"type_handling/02-uncertainties/","page":"Numbers with Uncertainties","title":"Numbers with Uncertainties","text":"ddottheta + fracgL theta = 0","category":"page"},{"location":"type_handling/02-uncertainties/","page":"Numbers with Uncertainties","title":"Numbers with Uncertainties","text":"where g = (979 pm 002)mathrmmmathrms^2 is the gravitational acceleration measured where the experiment is carried out, and L = (100 pm 001)mathrmm is the length of the pendulum.","category":"page"},{"location":"type_handling/02-uncertainties/","page":"Numbers with Uncertainties","title":"Numbers with Uncertainties","text":"When you set up the problem for DifferentialEquations.jl remember to define the measurements as variables, as seen above.","category":"page"},{"location":"type_handling/02-uncertainties/","page":"Numbers with Uncertainties","title":"Numbers with Uncertainties","text":"\nusing DifferentialEquations, Measurements, Plots\n\ng = 9.79 ± 0.02; # Gravitational constants\nL = 1.00 ± 0.01; # Length of the pendulum\n\n#Initial Conditions\nu₀ = [0 ± 0, π / 60 ± 0.01] # Initial speed and initial angle\ntspan = (0.0, 6.3)\n\n#Define the problem\nfunction simplependulum(du,u,p,t)\n    θ  = u[1]\n    dθ = u[2]\n    du[1] = dθ\n    du[2] = -(g/L)*θ\nend\n\n#Pass to solvers\nprob = ODEProblem(simplependulum, u₀, tspan)\nsol = solve(prob, Tsit5(), reltol = 1e-6)\n\n# Analytic solution\nu = u₀[2] .* cos.(sqrt(g / L) .* sol.t)\n\nplot(sol.t, getindex.(sol.u, 2), label = \"Numerical\")\nplot!(sol.t, u, label = \"Analytic\")","category":"page"},{"location":"type_handling/02-uncertainties/","page":"Numbers with Uncertainties","title":"Numbers with Uncertainties","text":"(Image: )","category":"page"},{"location":"type_handling/02-uncertainties/","page":"Numbers with Uncertainties","title":"Numbers with Uncertainties","text":"Also in this case there is a perfect superimposition between the two curves, including their uncertainties.","category":"page"},{"location":"type_handling/02-uncertainties/","page":"Numbers with Uncertainties","title":"Numbers with Uncertainties","text":"We can also have a look at the difference between the two solutions:","category":"page"},{"location":"type_handling/02-uncertainties/","page":"Numbers with Uncertainties","title":"Numbers with Uncertainties","text":"\nplot(sol.t, getindex.(sol.u, 2) .- u, label = \"\")","category":"page"},{"location":"type_handling/02-uncertainties/","page":"Numbers with Uncertainties","title":"Numbers with Uncertainties","text":"(Image: )","category":"page"},{"location":"type_handling/02-uncertainties/#Arbitrary-amplitude","page":"Numbers with Uncertainties","title":"Arbitrary amplitude","text":"","category":"section"},{"location":"type_handling/02-uncertainties/","page":"Numbers with Uncertainties","title":"Numbers with Uncertainties","text":"Now that we know how to solve differential equations involving numbers with uncertainties we can solve the simple pendulum problem without any approximation.  This time the differential equation to solve is the following:","category":"page"},{"location":"type_handling/02-uncertainties/","page":"Numbers with Uncertainties","title":"Numbers with Uncertainties","text":"ddottheta + fracgL sin(theta) = 0","category":"page"},{"location":"type_handling/02-uncertainties/","page":"Numbers with Uncertainties","title":"Numbers with Uncertainties","text":"\ng = 9.79 ± 0.02; # Gravitational constants\nL = 1.00 ± 0.01; # Length of the pendulum\n\n#Initial Conditions\nu₀ = [0 ± 0, π / 3 ± 0.02] # Initial speed and initial angle\ntspan = (0.0, 6.3)\n\n#Define the problem\nfunction simplependulum(du,u,p,t)\n    θ  = u[1]\n    dθ = u[2]\n    du[1] = dθ\n    du[2] = -(g/L) * sin(θ)\nend\n\n#Pass to solvers\nprob = ODEProblem(simplependulum, u₀, tspan)\nsol = solve(prob, Tsit5(), reltol = 1e-6)\n\nplot(sol.t, getindex.(sol.u, 2), label = \"Numerical\")","category":"page"},{"location":"type_handling/02-uncertainties/","page":"Numbers with Uncertainties","title":"Numbers with Uncertainties","text":"(Image: )","category":"page"},{"location":"type_handling/02-uncertainties/","page":"Numbers with Uncertainties","title":"Numbers with Uncertainties","text":"We note that in this case the period of the oscillations is not constant.","category":"page"},{"location":"type_handling/02-uncertainties/#Appendix","page":"Numbers with Uncertainties","title":"Appendix","text":"","category":"section"},{"location":"type_handling/02-uncertainties/","page":"Numbers with Uncertainties","title":"Numbers with Uncertainties","text":"This tutorial is part of the SciMLTutorials.jl repository, found at: https://github.com/SciML/SciMLTutorials.jl.  For more information on doing scientific machine learning (SciML) with open source software, check out https://sciml.ai/.","category":"page"},{"location":"type_handling/02-uncertainties/","page":"Numbers with Uncertainties","title":"Numbers with Uncertainties","text":"To locally run this tutorial, do the following commands:","category":"page"},{"location":"type_handling/02-uncertainties/","page":"Numbers with Uncertainties","title":"Numbers with Uncertainties","text":"using SciMLTutorials\nSciMLTutorials.weave_file(\"type_handling\",\"02-uncertainties.jmd\")","category":"page"},{"location":"type_handling/02-uncertainties/","page":"Numbers with Uncertainties","title":"Numbers with Uncertainties","text":"Computer Information:","category":"page"},{"location":"type_handling/02-uncertainties/","page":"Numbers with Uncertainties","title":"Numbers with Uncertainties","text":"Julia Version 1.4.2\nCommit 44fa15b150* (2020-05-23 18:35 UTC)\nPlatform Info:\n  OS: Linux (x86_64-pc-linux-gnu)\n  CPU: Intel(R) Core(TM) i7-9700K CPU @ 3.60GHz\n  WORD_SIZE: 64\n  LIBM: libopenlibm\n  LLVM: libLLVM-8.0.1 (ORCJIT, skylake)\nEnvironment:\n  JULIA_LOAD_PATH = /builds/JuliaGPU/DiffEqTutorials.jl:\n  JULIA_DEPOT_PATH = /builds/JuliaGPU/DiffEqTutorials.jl/.julia\n  JULIA_CUDA_MEMORY_LIMIT = 2147483648\n  JULIA_NUM_THREADS = 8\n","category":"page"},{"location":"type_handling/02-uncertainties/","page":"Numbers with Uncertainties","title":"Numbers with Uncertainties","text":"Package Information:","category":"page"},{"location":"type_handling/02-uncertainties/","page":"Numbers with Uncertainties","title":"Numbers with Uncertainties","text":"Status `/builds/JuliaGPU/DiffEqTutorials.jl/tutorials/type_handling/Project.toml`\n[7e558dbc-694d-5a72-987c-6f4ebed21442] ArbNumerics 1.2.1\n[55939f99-70c6-5e9b-8bb0-5071ed7d61fd] DecFP 1.0.0\n[abce61dc-4473-55a0-ba07-351d65e31d42] Decimals 0.4.1\n[0c46a032-eb83-5123-abaf-570d42b7fbaa] DifferentialEquations 6.15.0\n[497a8b3b-efae-58df-a0af-a86822472b78] DoubleFloats 1.1.13\n[eff96d63-e80a-5855-80a2-b1b0885c5ab7] Measurements 2.2.1\n[1dea7af3-3e70-54e6-95c3-0bf5283fa5ed] OrdinaryDiffEq 5.42.5\n[91a5bcdd-55d7-5caf-9e0b-520d859cae80] Plots 1.6.1\n[1986cc42-f94f-5a68-af5c-568840ba703d] Unitful 1.4.0","category":"page"},{"location":"models/03-kepler_problem/#Kepler-Problem","page":"Kepler Problem","title":"Kepler Problem","text":"","category":"section"},{"location":"models/03-kepler_problem/","page":"Kepler Problem","title":"Kepler Problem","text":"The Hamiltonian mathcal H and the angular momentum L for the Kepler problem are","category":"page"},{"location":"models/03-kepler_problem/","page":"Kepler Problem","title":"Kepler Problem","text":"mathcal H = frac12(dotq^2_1+dotq^2_2)-frac1sqrtq^2_1+q^2_2quad\nL = q_1dotq_2 - dotq_1q_2","category":"page"},{"location":"models/03-kepler_problem/","page":"Kepler Problem","title":"Kepler Problem","text":"Also, we know that","category":"page"},{"location":"models/03-kepler_problem/","page":"Kepler Problem","title":"Kepler Problem","text":"displaystyle frac mathrm d boldsymbol pmathrm d t=-frac partial mathcal Hpartial boldsymbol qquad quad frac mathrm d boldsymbol qmathrm d t=+frac partial mathcal Hpartial boldsymbol p","category":"page"},{"location":"models/03-kepler_problem/","page":"Kepler Problem","title":"Kepler Problem","text":"using OrdinaryDiffEq, LinearAlgebra, ForwardDiff, Plots; gr()\nH(q,p) = norm(p)^2/2 - inv(norm(q))\nL(q,p) = q[1]*p[2] - p[1]*q[2]\n\npdot(dp,p,q,params,t) = ForwardDiff.gradient!(dp, q->-H(q, p), q)\nqdot(dq,p,q,params,t) = ForwardDiff.gradient!(dq, p-> H(q, p), p)\n\ninitial_position = [.4, 0]\ninitial_velocity = [0., 2.]\ninitial_cond = (initial_position, initial_velocity)\ninitial_first_integrals = (H(initial_cond...), L(initial_cond...))\ntspan = (0,20.)\nprob = DynamicalODEProblem(pdot, qdot, initial_velocity, initial_position, tspan)\nsol = solve(prob, KahanLi6(), dt=1//10);","category":"page"},{"location":"models/03-kepler_problem/","page":"Kepler Problem","title":"Kepler Problem","text":"Let's plot the orbit and check the energy and angular momentum variation. We know that energy and angular momentum should be constant, and they are also called first integrals.","category":"page"},{"location":"models/03-kepler_problem/","page":"Kepler Problem","title":"Kepler Problem","text":"plot_orbit(sol) = plot(sol,vars=(3,4), lab=\"Orbit\", title=\"Kepler Problem Solution\")\n\nfunction plot_first_integrals(sol, H, L)\n    plot(initial_first_integrals[1].-map(u->H(u[2,:], u[1,:]), sol.u), lab=\"Energy variation\", title=\"First Integrals\")\n    plot!(initial_first_integrals[2].-map(u->L(u[2,:], u[1,:]), sol.u), lab=\"Angular momentum variation\")\nend\nanalysis_plot(sol, H, L) = plot(plot_orbit(sol), plot_first_integrals(sol, H, L))","category":"page"},{"location":"models/03-kepler_problem/","page":"Kepler Problem","title":"Kepler Problem","text":"analysis_plot (generic function with 1 method)","category":"page"},{"location":"models/03-kepler_problem/","page":"Kepler Problem","title":"Kepler Problem","text":"analysis_plot(sol, H, L)","category":"page"},{"location":"models/03-kepler_problem/","page":"Kepler Problem","title":"Kepler Problem","text":"(Image: )","category":"page"},{"location":"models/03-kepler_problem/","page":"Kepler Problem","title":"Kepler Problem","text":"Let's try to use a Runge-Kutta-Nyström solver to solve this problem and check the first integrals' variation.","category":"page"},{"location":"models/03-kepler_problem/","page":"Kepler Problem","title":"Kepler Problem","text":"sol2 = solve(prob, DPRKN6())  # dt is not necessary, because unlike symplectic\n                              # integrators DPRKN6 is adaptive\n@show sol2.u |> length\nanalysis_plot(sol2, H, L)","category":"page"},{"location":"models/03-kepler_problem/","page":"Kepler Problem","title":"Kepler Problem","text":"sol2.u |> length = 91","category":"page"},{"location":"models/03-kepler_problem/","page":"Kepler Problem","title":"Kepler Problem","text":"(Image: )","category":"page"},{"location":"models/03-kepler_problem/","page":"Kepler Problem","title":"Kepler Problem","text":"Let's then try to solve the same problem by the ERKN4 solver, which is specialized for sinusoid-like periodic function","category":"page"},{"location":"models/03-kepler_problem/","page":"Kepler Problem","title":"Kepler Problem","text":"sol3 = solve(prob, ERKN4()) # dt is not necessary, because unlike symplectic\n                            # integrators ERKN4 is adaptive\n@show sol3.u |> length\nanalysis_plot(sol3, H, L)","category":"page"},{"location":"models/03-kepler_problem/","page":"Kepler Problem","title":"Kepler Problem","text":"sol3.u |> length = 55","category":"page"},{"location":"models/03-kepler_problem/","page":"Kepler Problem","title":"Kepler Problem","text":"(Image: )","category":"page"},{"location":"models/03-kepler_problem/","page":"Kepler Problem","title":"Kepler Problem","text":"We can see that ERKN4 does a bad job for this problem, because this problem is not sinusoid-like.","category":"page"},{"location":"models/03-kepler_problem/","page":"Kepler Problem","title":"Kepler Problem","text":"One advantage of using DynamicalODEProblem is that it can implicitly convert the second order ODE problem to a normal system of first order ODEs, which is solvable for other ODE solvers. Let's use the Tsit5 solver for the next example.","category":"page"},{"location":"models/03-kepler_problem/","page":"Kepler Problem","title":"Kepler Problem","text":"sol4 = solve(prob, Tsit5())\n@show sol4.u |> length\nanalysis_plot(sol4, H, L)","category":"page"},{"location":"models/03-kepler_problem/","page":"Kepler Problem","title":"Kepler Problem","text":"sol4.u |> length = 57","category":"page"},{"location":"models/03-kepler_problem/","page":"Kepler Problem","title":"Kepler Problem","text":"(Image: )","category":"page"},{"location":"models/03-kepler_problem/#Note","page":"Kepler Problem","title":"Note","text":"","category":"section"},{"location":"models/03-kepler_problem/","page":"Kepler Problem","title":"Kepler Problem","text":"There is drifting for all the solutions, and high order methods are drifting less because they are more accurate.","category":"page"},{"location":"models/03-kepler_problem/#Conclusion","page":"Kepler Problem","title":"Conclusion","text":"","category":"section"},{"location":"models/03-kepler_problem/","page":"Kepler Problem","title":"Kepler Problem","text":"","category":"page"},{"location":"models/03-kepler_problem/","page":"Kepler Problem","title":"Kepler Problem","text":"Symplectic integrator does not conserve the energy completely at all time, but the energy can come back. In order to make sure that the energy fluctuation comes back eventually, symplectic integrator has to have a fixed time step. Despite the energy variation, symplectic integrator conserves the angular momentum perfectly.","category":"page"},{"location":"models/03-kepler_problem/","page":"Kepler Problem","title":"Kepler Problem","text":"Both Runge-Kutta-Nyström and Runge-Kutta integrator do not conserve energy nor the angular momentum, and the first integrals do not tend to come back. An advantage Runge-Kutta-Nyström integrator over symplectic integrator is that RKN integrator can have adaptivity. An advantage Runge-Kutta-Nyström integrator over Runge-Kutta integrator is that RKN integrator has less function evaluation per step. The ERKN4 solver works best for sinusoid-like solutions.","category":"page"},{"location":"models/03-kepler_problem/#Manifold-Projection","page":"Kepler Problem","title":"Manifold Projection","text":"","category":"section"},{"location":"models/03-kepler_problem/","page":"Kepler Problem","title":"Kepler Problem","text":"In this example, we know that energy and angular momentum should be conserved. We can achieve this through mainfold projection. As the name implies, it is a procedure to project the ODE solution to a manifold. Let's start with a base case, where mainfold projection isn't being used.","category":"page"},{"location":"models/03-kepler_problem/","page":"Kepler Problem","title":"Kepler Problem","text":"using DiffEqCallbacks\n\nplot_orbit2(sol) = plot(sol,vars=(1,2), lab=\"Orbit\", title=\"Kepler Problem Solution\")\n\nfunction plot_first_integrals2(sol, H, L)\n    plot(initial_first_integrals[1].-map(u->H(u[1:2],u[3:4]), sol.u), lab=\"Energy variation\", title=\"First Integrals\")\n    plot!(initial_first_integrals[2].-map(u->L(u[1:2],u[3:4]), sol.u), lab=\"Angular momentum variation\")\nend\n\nanalysis_plot2(sol, H, L) = plot(plot_orbit2(sol), plot_first_integrals2(sol, H, L))\n\nfunction hamiltonian(du,u,params,t)\n    q, p = u[1:2], u[3:4]\n    qdot(@view(du[1:2]), p, q, params, t)\n    pdot(@view(du[3:4]), p, q, params, t)\nend\n\nprob2 = ODEProblem(hamiltonian, [initial_position; initial_velocity], tspan)\nsol_ = solve(prob2, RK4(), dt=1//5, adaptive=false)\nanalysis_plot2(sol_, H, L)","category":"page"},{"location":"models/03-kepler_problem/","page":"Kepler Problem","title":"Kepler Problem","text":"(Image: )","category":"page"},{"location":"models/03-kepler_problem/","page":"Kepler Problem","title":"Kepler Problem","text":"There is a significant fluctuation in the first integrals, when there is no mainfold projection.","category":"page"},{"location":"models/03-kepler_problem/","page":"Kepler Problem","title":"Kepler Problem","text":"function first_integrals_manifold(residual,u)\n    residual[1:2] .= initial_first_integrals[1] - H(u[1:2], u[3:4])\n    residual[3:4] .= initial_first_integrals[2] - L(u[1:2], u[3:4])\nend\n\ncb = ManifoldProjection(first_integrals_manifold)\nsol5 = solve(prob2, RK4(), dt=1//5, adaptive=false, callback=cb)\nanalysis_plot2(sol5, H, L)","category":"page"},{"location":"models/03-kepler_problem/","page":"Kepler Problem","title":"Kepler Problem","text":"Error: MethodError: no method matching first_integrals_manifold(::Vector{Fo\nrwardDiff.Dual{ForwardDiff.Tag{DiffEqCallbacks.NonAutonomousFunction{typeof\n(Main.var\"##WeaveSandBox#691\".first_integrals_manifold), false}, Float64}, \nFloat64, 4}}, ::Vector{ForwardDiff.Dual{ForwardDiff.Tag{DiffEqCallbacks.Non\nAutonomousFunction{typeof(Main.var\"##WeaveSandBox#691\".first_integrals_mani\nfold), false}, Float64}, Float64, 4}}, ::SciMLBase.NullParameters, ::Float6\n4)\nClosest candidates are:\n  first_integrals_manifold(::Any, ::Any) at /cache/build/exclusive-amdci1-0\n/julialang/scimltutorials-dot-jl/tutorials/models/03-kepler_problem.jmd:2","category":"page"},{"location":"models/03-kepler_problem/","page":"Kepler Problem","title":"Kepler Problem","text":"We can see that thanks to the manifold projection, the first integrals' variation is very small, although we are using RK4 which is not symplectic. But wait, what if we only project to the energy conservation manifold?","category":"page"},{"location":"models/03-kepler_problem/","page":"Kepler Problem","title":"Kepler Problem","text":"function energy_manifold(residual,u)\n    residual[1:2] .= initial_first_integrals[1] - H(u[1:2], u[3:4])\n    residual[3:4] .= 0\nend\nenergy_cb = ManifoldProjection(energy_manifold)\nsol6 = solve(prob2, RK4(), dt=1//5, adaptive=false, callback=energy_cb)\nanalysis_plot2(sol6, H, L)","category":"page"},{"location":"models/03-kepler_problem/","page":"Kepler Problem","title":"Kepler Problem","text":"Error: MethodError: no method matching energy_manifold(::Vector{ForwardDiff\n.Dual{ForwardDiff.Tag{DiffEqCallbacks.NonAutonomousFunction{typeof(Main.var\n\"##WeaveSandBox#691\".energy_manifold), false}, Float64}, Float64, 4}}, ::Ve\nctor{ForwardDiff.Dual{ForwardDiff.Tag{DiffEqCallbacks.NonAutonomousFunction\n{typeof(Main.var\"##WeaveSandBox#691\".energy_manifold), false}, Float64}, Fl\noat64, 4}}, ::SciMLBase.NullParameters, ::Float64)\nClosest candidates are:\n  energy_manifold(::Any, ::Any) at /cache/build/exclusive-amdci1-0/julialan\ng/scimltutorials-dot-jl/tutorials/models/03-kepler_problem.jmd:2","category":"page"},{"location":"models/03-kepler_problem/","page":"Kepler Problem","title":"Kepler Problem","text":"There is almost no energy variation but angular momentum varies quite bit. How about only project to the angular momentum conservation manifold?","category":"page"},{"location":"models/03-kepler_problem/","page":"Kepler Problem","title":"Kepler Problem","text":"function angular_manifold(residual,u)\n    residual[1:2] .= initial_first_integrals[2] - L(u[1:2], u[3:4])\n    residual[3:4] .= 0\nend\nangular_cb = ManifoldProjection(angular_manifold)\nsol7 = solve(prob2, RK4(), dt=1//5, adaptive=false, callback=angular_cb)\nanalysis_plot2(sol7, H, L)","category":"page"},{"location":"models/03-kepler_problem/","page":"Kepler Problem","title":"Kepler Problem","text":"Error: MethodError: no method matching angular_manifold(::Vector{ForwardDif\nf.Dual{ForwardDiff.Tag{DiffEqCallbacks.NonAutonomousFunction{typeof(Main.va\nr\"##WeaveSandBox#691\".angular_manifold), false}, Float64}, Float64, 4}}, ::\nVector{ForwardDiff.Dual{ForwardDiff.Tag{DiffEqCallbacks.NonAutonomousFuncti\non{typeof(Main.var\"##WeaveSandBox#691\".angular_manifold), false}, Float64},\n Float64, 4}}, ::SciMLBase.NullParameters, ::Float64)\nClosest candidates are:\n  angular_manifold(::Any, ::Any) at /cache/build/exclusive-amdci1-0/juliala\nng/scimltutorials-dot-jl/tutorials/models/03-kepler_problem.jmd:2","category":"page"},{"location":"models/03-kepler_problem/","page":"Kepler Problem","title":"Kepler Problem","text":"Again, we see what we expect.","category":"page"},{"location":"models/03-kepler_problem/#Appendix","page":"Kepler Problem","title":"Appendix","text":"","category":"section"},{"location":"models/03-kepler_problem/","page":"Kepler Problem","title":"Kepler Problem","text":"These tutorials are a part of the SciMLTutorials.jl repository, found at: https://github.com/SciML/SciMLTutorials.jl. For more information on high-performance scientific machine learning, check out the SciML Open Source Software Organization https://sciml.ai.","category":"page"},{"location":"models/03-kepler_problem/","page":"Kepler Problem","title":"Kepler Problem","text":"To locally run this tutorial, do the following commands:","category":"page"},{"location":"models/03-kepler_problem/","page":"Kepler Problem","title":"Kepler Problem","text":"using SciMLTutorials\nSciMLTutorials.weave_file(\"tutorials/models\",\"03-kepler_problem.jmd\")","category":"page"},{"location":"models/03-kepler_problem/","page":"Kepler Problem","title":"Kepler Problem","text":"Computer Information:","category":"page"},{"location":"models/03-kepler_problem/","page":"Kepler Problem","title":"Kepler Problem","text":"Julia Version 1.8.0\nCommit 5544a0fab76 (2022-08-17 13:38 UTC)\nPlatform Info:\n  OS: Linux (x86_64-linux-gnu)\n  CPU: 128 × AMD EPYC 7502 32-Core Processor\n  WORD_SIZE: 64\n  LIBM: libopenlibm\n  LLVM: libLLVM-13.0.1 (ORCJIT, znver2)\n  Threads: 1 on 128 virtual cores\nEnvironment:\n  JULIA_CPU_THREADS = 128\n  JULIA_DEPOT_PATH = /cache/julia-buildkite-plugin/depots/a6029d3a-f78b-41ea-bc97-28aa57c6c6ea\n","category":"page"},{"location":"models/03-kepler_problem/","page":"Kepler Problem","title":"Kepler Problem","text":"Package Information:","category":"page"},{"location":"models/03-kepler_problem/","page":"Kepler Problem","title":"Kepler Problem","text":"Status `/cache/build/exclusive-amdci1-0/julialang/scimltutorials-dot-jl/tutorials/models/Project.toml`\n  [479239e8] Catalyst v12.2.1\n  [459566f4] DiffEqCallbacks v2.24.1\n  [f3b72e0c] DiffEqDevTools v2.31.2\n  [055956cb] DiffEqPhysics v3.9.0\n  [0c46a032] DifferentialEquations v7.3.0\n  [31c24e10] Distributions v0.25.70\n  [587475ba] Flux v0.13.5\n  [f6369f11] ForwardDiff v0.10.32\n  [23fbe1c1] Latexify v0.15.16\n  [961ee093] ModelingToolkit v8.21.0\n  [2774e3e8] NLsolve v4.5.1\n⌅ [315f7962] NeuralPDE v4.11.0\n  [429524aa] Optim v1.7.2\n  [1dea7af3] OrdinaryDiffEq v6.26.2\n  [91a5bcdd] Plots v1.32.0\n  [731186ca] RecursiveArrayTools v2.32.0\n  [30cb0354] SciMLTutorials v1.0.0\n  [789caeaf] StochasticDiffEq v6.53.0\n  [37e2e46d] LinearAlgebra\n  [2f01184e] SparseArrays\nInfo Packages marked with ⌅ have new versions available but cannot be upgraded. To see why use `status --outdated`","category":"page"},{"location":"models/03-kepler_problem/","page":"Kepler Problem","title":"Kepler Problem","text":"And the full manifest:","category":"page"},{"location":"models/03-kepler_problem/","page":"Kepler Problem","title":"Kepler Problem","text":"Status `/cache/build/exclusive-amdci1-0/julialang/scimltutorials-dot-jl/tutorials/models/Manifest.toml`\n  [c3fe647b] AbstractAlgebra v0.27.4\n  [621f4979] AbstractFFTs v1.2.1\n  [1520ce14] AbstractTrees v0.4.2\n  [7d9f7c33] Accessors v0.1.20\n  [79e6a3ab] Adapt v3.4.0\n  [dce04be8] ArgCheck v2.3.0\n  [ec485272] ArnoldiMethod v0.2.0\n  [4fba245c] ArrayInterface v6.0.23\n  [30b0a656] ArrayInterfaceCore v0.1.20\n  [6ba088a2] ArrayInterfaceGPUArrays v0.2.1\n  [015c0d05] ArrayInterfaceOffsetArrays v0.1.6\n  [b0d46f97] ArrayInterfaceStaticArrays v0.1.4\n  [dd5226c6] ArrayInterfaceStaticArraysCore v0.1.0\n  [a2b0951a] ArrayInterfaceTracker v0.1.1\n  [4c555306] ArrayLayouts v0.8.11\n  [15f4f7f2] AutoHashEquals v0.2.0\n  [ab4f0b2a] BFloat16s v0.2.0\n  [aae01518] BandedMatrices v0.17.6\n  [198e06fe] BangBang v0.3.36\n  [9718e550] Baselet v0.1.1\n  [e2ed5e7c] Bijections v0.1.4\n  [62783981] BitTwiddlingConvenienceFunctions v0.1.4\n  [8e7c35d0] BlockArrays v0.16.20\n  [ffab5731] BlockBandedMatrices v0.11.9\n  [764a87c0] BoundaryValueDiffEq v2.9.0\n  [fa961155] CEnum v0.4.2\n  [2a0fbf3d] CPUSummary v0.1.25\n  [00ebfdb7] CSTParser v3.3.6\n  [052768ef] CUDA v3.12.0\n  [49dc2e85] Calculus v0.5.1\n  [7057c7e9] Cassette v0.3.10\n  [479239e8] Catalyst v12.2.1\n  [082447d4] ChainRules v1.44.6\n  [d360d2e6] ChainRulesCore v1.15.4\n  [9e997f8a] ChangesOfVariables v0.1.4\n  [fb6a15b2] CloseOpenIntervals v0.1.10\n  [944b1d66] CodecZlib v0.7.0\n  [35d6a980] ColorSchemes v3.19.0\n  [3da002f7] ColorTypes v0.11.4\n  [c3611d14] ColorVectorSpace v0.9.9\n  [5ae59095] Colors v0.12.8\n  [861a8166] Combinatorics v1.0.2\n  [a80b9123] CommonMark v0.8.6\n  [38540f10] CommonSolve v0.2.1\n  [bbf7d656] CommonSubexpressions v0.3.0\n⌅ [34da2185] Compat v3.46.0\n  [b0b7db55] ComponentArrays v0.13.2\n  [b152e2b5] CompositeTypes v0.1.2\n  [a33af91c] CompositionsBase v0.1.1\n  [8f4d0f93] Conda v1.7.0\n  [88cd18e8] ConsoleProgressMonitor v0.1.2\n  [187b0558] ConstructionBase v1.4.1\n  [6add18c4] ContextVariablesX v0.1.2\n  [d38c429a] Contour v0.6.2\n  [adafc99b] CpuId v0.3.1\n  [a8cc5b0e] Crayons v4.1.1\n  [8a292aeb] Cuba v2.2.0\n  [667455a9] Cubature v1.5.1\n  [9a962f9c] DataAPI v1.10.0\n  [82cc6244] DataInterpolations v3.10.1\n  [864edb3b] DataStructures v0.18.13\n  [e2d170a0] DataValueInterfaces v1.0.0\n  [244e2a9f] DefineSingletons v0.1.2\n  [bcd4f6db] DelayDiffEq v5.37.1\n  [b429d917] DensityInterface v0.4.0\n  [2b5f629d] DiffEqBase v6.100.0\n  [459566f4] DiffEqCallbacks v2.24.1\n  [f3b72e0c] DiffEqDevTools v2.31.2\n  [aae7a2af] DiffEqFlux v1.52.0\n  [77a26b50] DiffEqNoiseProcess v5.12.3\n  [9fdde737] DiffEqOperators v4.43.1\n  [055956cb] DiffEqPhysics v3.9.0\n  [41bf760c] DiffEqSensitivity v6.79.0\n  [163ba53b] DiffResults v1.0.3\n  [b552c78f] DiffRules v1.11.1\n  [0c46a032] DifferentialEquations v7.3.0\n  [b4f34e82] Distances v0.10.7\n  [31c24e10] Distributions v0.25.70\n  [ced4e74d] DistributionsAD v0.6.42\n⌅ [ffbed154] DocStringExtensions v0.8.6\n  [5b8099bc] DomainSets v0.5.13\n  [fa6b7ba4] DualNumbers v0.6.8\n  [7c1d4256] DynamicPolynomials v0.4.5\n  [da5c29d0] EllipsisNotation v1.6.0\n  [7da242da] Enzyme v0.10.4\n  [d4d017d3] ExponentialUtilities v1.18.0\n  [e2ba6199] ExprTools v0.1.8\n  [411431e0] Extents v0.1.1\n  [c87230d0] FFMPEG v0.4.1\n  [cc61a311] FLoops v0.2.0\n  [b9860ae5] FLoopsBase v0.1.1\n  [7034ab61] FastBroadcast v0.2.1\n  [9aa1b823] FastClosures v0.3.2\n  [29a986be] FastLapackInterface v1.2.6\n  [1a297f60] FillArrays v0.13.4\n⌃ [6a86dc24] FiniteDiff v2.13.1\n  [53c48c17] FixedPointNumbers v0.8.4\n  [587475ba] Flux v0.13.5\n  [9c68100b] FoldsThreads v0.1.1\n  [59287772] Formatting v0.4.2\n  [f6369f11] ForwardDiff v0.10.32\n  [069b7b12] FunctionWrappers v1.1.2\n  [77dc65aa] FunctionWrappersWrappers v0.1.1\n  [d9f16b24] Functors v0.3.0\n  [0c68f7d7] GPUArrays v8.5.0\n  [46192b85] GPUArraysCore v0.1.2\n  [61eb1bfa] GPUCompiler v0.16.3\n  [28b8d3ca] GR v0.66.2\n  [c145ed77] GenericSchur v0.5.3\n  [cf35fbd7] GeoInterface v1.0.1\n  [5c1252a2] GeometryBasics v0.4.3\n  [86223c79] Graphs v1.7.2\n  [42e2da0e] Grisu v1.0.2\n  [0b43b601] Groebner v0.2.10\n  [d5909c97] GroupsCore v0.4.0\n  [19dc6840] HCubature v1.5.0\n  [cd3eb016] HTTP v1.3.3\n⌅ [eafb193a] Highlights v0.4.5\n  [3e5b6fbb] HostCPUFeatures v0.1.8\n  [34004b35] HypergeometricFunctions v0.3.11\n  [7073ff75] IJulia v1.23.3\n  [7869d1d1] IRTools v0.4.6\n  [615f187c] IfElse v0.1.1\n  [d25df0c9] Inflate v0.1.3\n  [83e8ac13] IniFile v0.5.1\n  [22cec73e] InitialValues v0.3.1\n  [18e54dd8] IntegerMathUtils v0.1.0\n  [8197267c] IntervalSets v0.7.2\n  [3587e190] InverseFunctions v0.1.7\n  [92d709cd] IrrationalConstants v0.1.1\n  [c8e1da08] IterTools v1.4.0\n  [42fd0dbc] IterativeSolvers v0.9.2\n  [82899510] IteratorInterfaceExtensions v1.0.0\n  [692b3bcd] JLLWrappers v1.4.1\n  [682c06a0] JSON v0.21.3\n  [98e50ef6] JuliaFormatter v1.0.9\n  [b14d175d] JuliaVariables v0.2.4\n  [ccbc3e58] JumpProcesses v9.2.0\n  [ef3ab10e] KLU v0.3.0\n  [ba0b0d4f] Krylov v0.8.3\n  [0b1a1467] KrylovKit v0.5.4\n  [929cbde3] LLVM v4.14.0\n  [b964fa9f] LaTeXStrings v1.3.0\n  [2ee39098] LabelledArrays v1.12.0\n  [23fbe1c1] Latexify v0.15.16\n  [a5e1c1ea] LatinHypercubeSampling v1.8.0\n  [73f95e8e] LatticeRules v0.0.1\n  [10f19ff3] LayoutPointers v0.1.10\n  [50d2b5c4] Lazy v0.15.1\n  [5078a376] LazyArrays v0.22.11\n⌅ [d7e5e226] LazyBandedMatrices v0.7.17\n  [0fc2ff8b] LeastSquaresOptim v0.8.3\n  [1d6d02ad] LeftChildRightSiblingTrees v0.2.0\n  [2d8b4e74] LevyArea v1.0.0\n  [d3d80556] LineSearches v7.2.0\n  [7ed4a6bd] LinearSolve v1.26.0\n  [2ab3a3ac] LogExpFunctions v0.3.18\n  [e6f89c97] LoggingExtras v0.4.9\n  [bdcacae8] LoopVectorization v0.12.125\n  [b2108857] Lux v0.4.21\n  [d8e11817] MLStyle v0.4.13\n  [f1d291b0] MLUtils v0.2.10\n  [1914dd2f] MacroTools v0.5.9\n  [d125e4d3] ManualMemory v0.1.8\n  [a3b82374] MatrixFactorizations v0.9.2\n  [739be429] MbedTLS v1.1.5\n  [442fdcdd] Measures v0.3.1\n  [c03570c3] Memoize v0.4.4\n  [e9d8d322] Metatheory v1.3.4\n  [128add7d] MicroCollections v0.1.2\n  [e1d29d7a] Missings v1.0.2\n  [961ee093] ModelingToolkit v8.21.0\n⌅ [4886b29c] MonteCarloIntegration v0.0.3\n  [46d2c3a1] MuladdMacro v0.2.2\n  [102ac46a] MultivariatePolynomials v0.4.6\n  [ffc61752] Mustache v1.0.14\n  [d8a4904e] MutableArithmetics v1.0.4\n  [d41bc354] NLSolversBase v7.8.2\n  [2774e3e8] NLsolve v4.5.1\n  [872c559c] NNlib v0.8.9\n  [a00861dc] NNlibCUDA v0.2.4\n  [77ba4419] NaNMath v1.0.1\n  [71a1bf82] NameResolution v0.1.5\n⌅ [315f7962] NeuralPDE v4.11.0\n  [8913a72c] NonlinearSolve v0.3.22\n  [d8793406] ObjectFile v0.3.7\n  [6fe1bfb0] OffsetArrays v1.12.7\n  [429524aa] Optim v1.7.2\n  [3bd65402] Optimisers v0.2.9\n  [7f7a1694] Optimization v3.8.2\n  [253f991c] OptimizationFlux v0.1.0\n  [36348300] OptimizationOptimJL v0.1.2\n  [42dfb2eb] OptimizationOptimisers v0.1.0\n  [500b13db] OptimizationPolyalgorithms v0.1.0\n  [bac558e1] OrderedCollections v1.4.1\n  [1dea7af3] OrdinaryDiffEq v6.26.2\n  [90014a1f] PDMats v0.11.16\n  [d96e819e] Parameters v0.12.3\n  [69de0a69] Parsers v2.4.0\n  [ccf2f8ad] PlotThemes v3.0.0\n  [995b91a9] PlotUtils v1.3.0\n  [91a5bcdd] Plots v1.32.0\n  [e409e4f3] PoissonRandom v0.4.1\n  [f517fe37] Polyester v0.6.15\n  [1d0040c9] PolyesterWeave v0.1.9\n  [85a6dd25] PositiveFactorizations v0.2.4\n  [d236fae5] PreallocationTools v0.4.2\n  [21216c6a] Preferences v1.3.0\n  [8162dcfd] PrettyPrint v0.2.0\n  [27ebfcd6] Primes v0.5.3\n  [33c8b6b6] ProgressLogging v0.1.4\n  [92933f4c] ProgressMeter v1.7.2\n  [1fd47b50] QuadGK v2.5.0\n  [67601950] Quadrature v2.1.0\n  [e0ec9b62] QuadratureCubature v0.1.1\n  [8a4e6c94] QuasiMonteCarlo v0.2.9\n  [74087812] Random123 v1.6.0\n  [fb686558] RandomExtensions v0.4.3\n  [e6cf234a] RandomNumbers v1.5.3\n  [c1ae055f] RealDot v0.1.0\n  [3cdcf5f2] RecipesBase v1.2.1\n  [01d81517] RecipesPipeline v0.6.3\n  [731186ca] RecursiveArrayTools v2.32.0\n  [f2c3362d] RecursiveFactorization v0.2.12\n  [189a3867] Reexport v1.2.2\n  [42d2dcc6] Referenceables v0.1.2\n  [29dad682] RegularizationTools v0.6.0\n⌅ [05181044] RelocatableFolders v0.3.0\n  [ae029012] Requires v1.3.0\n  [ae5879a3] ResettableStacks v1.1.1\n  [37e2e3b7] ReverseDiff v1.14.1\n  [79098fc4] Rmath v0.7.0\n  [47965b36] RootedTrees v2.13.0\n  [7e49a35a] RuntimeGeneratedFunctions v0.5.3\n  [3cdde19b] SIMDDualNumbers v0.1.1\n  [94e857df] SIMDTypes v0.1.0\n  [476501e8] SLEEFPirates v0.6.35\n  [0bca4576] SciMLBase v1.53.2\n  [1ed8b502] SciMLSensitivity v7.7.0\n  [30cb0354] SciMLTutorials v1.0.0\n  [6c6a2e73] Scratch v1.1.1\n⌅ [efcf1570] Setfield v0.8.2\n  [605ecd9f] ShowCases v0.1.0\n  [992d4aef] Showoff v1.0.3\n  [777ac1f9] SimpleBufferStream v1.1.0\n  [699a6c99] SimpleTraits v0.9.4\n  [66db9d55] SnoopPrecompile v1.0.1\n  [ed01d8cd] Sobol v1.5.0\n  [b85f4697] SoftGlobalScope v1.1.0\n  [a2af1166] SortingAlgorithms v1.0.1\n  [47a9eef4] SparseDiffTools v1.26.2\n  [276daf66] SpecialFunctions v2.1.7\n  [171d559e] SplittablesBase v0.1.14\n  [860ef19b] StableRNGs v1.0.0\n  [aedffcd0] Static v0.7.6\n  [90137ffa] StaticArrays v1.5.6\n  [1e83bf80] StaticArraysCore v1.3.0\n  [82ae8749] StatsAPI v1.5.0\n  [2913bbd2] StatsBase v0.33.21\n  [4c63d2b9] StatsFuns v1.0.1\n  [9672c7b4] SteadyStateDiffEq v1.9.0\n  [789caeaf] StochasticDiffEq v6.53.0\n  [7792a7ef] StrideArraysCore v0.3.15\n  [69024149] StringEncodings v0.3.5\n  [09ab397b] StructArrays v0.6.12\n  [53d494c1] StructIO v0.3.0\n  [c3572dad] Sundials v4.10.1\n  [d1185830] SymbolicUtils v0.19.11\n  [0c5d862f] Symbolics v4.10.4\n  [3783bdb8] TableTraits v1.0.1\n  [bd369af6] Tables v1.7.0\n  [62fd8b95] TensorCore v0.1.1\n⌅ [8ea1fca8] TermInterface v0.2.3\n  [5d786b92] TerminalLoggers v0.1.6\n  [8290d209] ThreadingUtilities v0.5.0\n  [ac1d9e8a] ThreadsX v0.1.10\n  [a759f4b9] TimerOutputs v0.5.21\n  [0796e94c] Tokenize v0.5.24\n  [9f7883ad] Tracker v0.2.21\n  [3bb67fe8] TranscodingStreams v0.9.9\n  [28d57a85] Transducers v0.4.73\n  [a2a6695c] TreeViews v0.3.0\n  [d5829a12] TriangularSolve v0.1.13\n  [410a4b4d] Tricks v0.1.6\n  [5c2747f8] URIs v1.4.0\n  [3a884ed6] UnPack v1.0.2\n  [d9a01c3f] Underscores v3.0.0\n  [1cfade01] UnicodeFun v0.4.1\n  [1986cc42] Unitful v1.11.0\n  [41fe7b60] Unzip v0.2.0\n  [3d5dd08c] VectorizationBase v0.21.47\n  [81def892] VersionParsing v1.3.0\n  [19fa3120] VertexSafeGraphs v0.2.0\n⌃ [44d3d7a6] Weave v0.10.9\n  [ddb6d928] YAML v0.4.7\n  [c2297ded] ZMQ v1.2.1\n  [e88e6eb3] Zygote v0.6.47\n  [700de1a5] ZygoteRules v0.2.2\n  [6e34b625] Bzip2_jll v1.0.8+0\n  [83423d85] Cairo_jll v1.16.1+1\n  [3bed1096] Cuba_jll v4.2.2+1\n  [7bc98958] Cubature_jll v1.0.5+0\n  [5ae413db] EarCut_jll v2.2.3+0\n⌅ [7cc45869] Enzyme_jll v0.0.33+0\n  [2e619515] Expat_jll v2.4.8+0\n  [b22a6f82] FFMPEG_jll v4.4.2+0\n  [a3f928ae] Fontconfig_jll v2.13.93+0\n  [d7e528f0] FreeType2_jll v2.10.4+0\n  [559328eb] FriBidi_jll v1.0.10+0\n  [0656b61e] GLFW_jll v3.3.8+0\n  [d2c73de3] GR_jll v0.66.2+0\n  [78b55507] Gettext_jll v0.21.0+0\n  [7746bdde] Glib_jll v2.68.3+2\n  [3b182d85] Graphite2_jll v1.3.14+0\n  [2e76f6c2] HarfBuzz_jll v2.8.1+1\n  [aacddb02] JpegTurbo_jll v2.1.2+0\n  [c1c5ebd0] LAME_jll v3.100.1+0\n  [88015f11] LERC_jll v3.0.0+1\n  [dad2f222] LLVMExtra_jll v0.0.16+0\n  [dd4b983a] LZO_jll v2.10.1+0\n  [e9f186c6] Libffi_jll v3.2.2+1\n  [d4300ac3] Libgcrypt_jll v1.8.7+0\n  [7e76a0d4] Libglvnd_jll v1.3.0+3\n  [7add5ba3] Libgpg_error_jll v1.42.0+0\n  [94ce4f54] Libiconv_jll v1.16.1+1\n  [4b2f31a3] Libmount_jll v2.35.0+0\n  [89763e89] Libtiff_jll v4.4.0+0\n  [38a345b3] Libuuid_jll v2.36.0+0\n  [e7412a2a] Ogg_jll v1.3.5+1\n  [458c3c95] OpenSSL_jll v1.1.17+0\n  [efe28fd5] OpenSpecFun_jll v0.5.5+0\n  [91d4177d] Opus_jll v1.3.2+0\n  [2f80f16e] PCRE_jll v8.44.0+0\n  [30392449] Pixman_jll v0.40.1+0\n  [ea2cea3b] Qt5Base_jll v5.15.3+1\n  [f50d1b31] Rmath_jll v0.3.0+0\n  [fb77eaff] Sundials_jll v5.2.1+0\n  [a2964d1f] Wayland_jll v1.19.0+0\n  [2381bf8a] Wayland_protocols_jll v1.25.0+0\n  [02c8fc9c] XML2_jll v2.9.14+0\n  [aed1982a] XSLT_jll v1.1.34+0\n  [4f6342f7] Xorg_libX11_jll v1.6.9+4\n  [0c0b7dd1] Xorg_libXau_jll v1.0.9+4\n  [935fb764] Xorg_libXcursor_jll v1.2.0+4\n  [a3789734] Xorg_libXdmcp_jll v1.1.3+4\n  [1082639a] Xorg_libXext_jll v1.3.4+4\n  [d091e8ba] Xorg_libXfixes_jll v5.0.3+4\n  [a51aa0fd] Xorg_libXi_jll v1.7.10+4\n  [d1454406] Xorg_libXinerama_jll v1.1.4+4\n  [ec84b674] Xorg_libXrandr_jll v1.5.2+4\n  [ea2f1a96] Xorg_libXrender_jll v0.9.10+4\n  [14d82f49] Xorg_libpthread_stubs_jll v0.1.0+3\n  [c7cfdc94] Xorg_libxcb_jll v1.13.0+3\n  [cc61e674] Xorg_libxkbfile_jll v1.1.0+4\n  [12413925] Xorg_xcb_util_image_jll v0.4.0+1\n  [2def613f] Xorg_xcb_util_jll v0.4.0+1\n  [975044d2] Xorg_xcb_util_keysyms_jll v0.4.0+1\n  [0d47668e] Xorg_xcb_util_renderutil_jll v0.3.9+1\n  [c22f9ab0] Xorg_xcb_util_wm_jll v0.4.1+1\n  [35661453] Xorg_xkbcomp_jll v1.4.2+4\n  [33bec58e] Xorg_xkeyboard_config_jll v2.27.0+4\n  [c5fb5394] Xorg_xtrans_jll v1.4.0+3\n  [8f1865be] ZeroMQ_jll v4.3.4+0\n  [3161d3a3] Zstd_jll v1.5.2+0\n  [a4ae2306] libaom_jll v3.4.0+0\n  [0ac62f75] libass_jll v0.15.1+0\n  [f638f0a6] libfdk_aac_jll v2.0.2+0\n  [b53b4c65] libpng_jll v1.6.38+0\n  [a9144af2] libsodium_jll v1.0.20+0\n  [f27f6e37] libvorbis_jll v1.3.7+1\n  [1270edf5] x264_jll v2021.5.5+0\n  [dfaa095f] x265_jll v3.5.0+0\n  [d8fb68d0] xkbcommon_jll v1.4.1+0\n  [0dad84c5] ArgTools v1.1.1\n  [56f22d72] Artifacts\n  [2a0f44e3] Base64\n  [ade2ca70] Dates\n  [8bb1440f] DelimitedFiles\n  [8ba89e20] Distributed\n  [f43a241f] Downloads v1.6.0\n  [7b1f6079] FileWatching\n  [9fa8497b] Future\n  [b77e0a4c] InteractiveUtils\n  [4af54fe1] LazyArtifacts\n  [b27032c2] LibCURL v0.6.3\n  [76f85450] LibGit2\n  [8f399da3] Libdl\n  [37e2e46d] LinearAlgebra\n  [56ddb016] Logging\n  [d6f4376e] Markdown\n  [a63ad114] Mmap\n  [ca575930] NetworkOptions v1.2.0\n  [44cfe95a] Pkg v1.8.0\n  [de0858da] Printf\n  [3fa0cd96] REPL\n  [9a3f8284] Random\n  [ea8e919c] SHA v0.7.0\n  [9e88b42a] Serialization\n  [1a1011a3] SharedArrays\n  [6462fe0b] Sockets\n  [2f01184e] SparseArrays\n  [10745b16] Statistics\n  [4607b0f0] SuiteSparse\n  [fa267f1f] TOML v1.0.0\n  [a4e569a6] Tar v1.10.0\n  [8dfed614] Test\n  [cf7118a7] UUIDs\n  [4ec0a83e] Unicode\n  [e66e0078] CompilerSupportLibraries_jll v0.5.2+0\n  [deac9b47] LibCURL_jll v7.84.0+0\n  [29816b5a] LibSSH2_jll v1.10.2+0\n  [c8ffd9c3] MbedTLS_jll v2.28.0+0\n  [14a3606d] MozillaCACerts_jll v2022.2.1\n  [4536629a] OpenBLAS_jll v0.3.20+0\n  [05823500] OpenLibm_jll v0.8.1+0\n  [bea87d4a] SuiteSparse_jll v5.10.1+0\n  [83775a58] Zlib_jll v1.2.12+3\n  [8e850b90] libblastrampoline_jll v5.1.1+0\n  [8e850ede] nghttp2_jll v1.48.0+0\n  [3f19e933] p7zip_jll v17.4.0+0\nInfo Packages marked with ⌃ and ⌅ have new versions available, but those with ⌅ cannot be upgraded. To see why use `status --outdated -m`","category":"page"},{"location":"#SciMLTutorials.jl:-Tutorials-for-Scientific-Machine-Learning-and-Differential-Equations","page":"SciMLTutorials.jl: Tutorials for Scientific Machine Learning (SciML) and Equation Solvers","title":"SciMLTutorials.jl: Tutorials for Scientific Machine Learning and Differential Equations","text":"","category":"section"},{"location":"","page":"SciMLTutorials.jl: Tutorials for Scientific Machine Learning (SciML) and Equation Solvers","title":"SciMLTutorials.jl: Tutorials for Scientific Machine Learning (SciML) and Equation Solvers","text":"(Image: Join the chat at https://julialang.zulipchat.com #sciml-bridged) (Image: Global Docs)","category":"page"},{"location":"","page":"SciMLTutorials.jl: Tutorials for Scientific Machine Learning (SciML) and Equation Solvers","title":"SciMLTutorials.jl: Tutorials for Scientific Machine Learning (SciML) and Equation Solvers","text":"(Image: Build status)","category":"page"},{"location":"","page":"SciMLTutorials.jl: Tutorials for Scientific Machine Learning (SciML) and Equation Solvers","title":"SciMLTutorials.jl: Tutorials for Scientific Machine Learning (SciML) and Equation Solvers","text":"(Image: ColPrac: Contributor's Guide on Collaborative Practices for Community Packages) (Image: SciML Code Style)","category":"page"},{"location":"","page":"SciMLTutorials.jl: Tutorials for Scientific Machine Learning (SciML) and Equation Solvers","title":"SciMLTutorials.jl: Tutorials for Scientific Machine Learning (SciML) and Equation Solvers","text":"SciMLTutorials.jl holds PDFs, webpages, and interactive Jupyter notebooks showing how to utilize the software in the SciML Scientific Machine Learning ecosystem. This set of tutorials was made to complement the documentation and the devdocs by providing practical examples of the concepts. For more details, please consult the docs.","category":"page"},{"location":"#Results","page":"SciMLTutorials.jl: Tutorials for Scientific Machine Learning (SciML) and Equation Solvers","title":"Results","text":"","category":"section"},{"location":"","page":"SciMLTutorials.jl: Tutorials for Scientific Machine Learning (SciML) and Equation Solvers","title":"SciMLTutorials.jl: Tutorials for Scientific Machine Learning (SciML) and Equation Solvers","text":"To view the SciML Tutorials, go to tutorials.sciml.ai. By default, this will lead to the latest tagged version of the tutorials. To see the in-development version of the tutorials, go to https://tutorials.sciml.ai/dev/.","category":"page"},{"location":"","page":"SciMLTutorials.jl: Tutorials for Scientific Machine Learning (SciML) and Equation Solvers","title":"SciMLTutorials.jl: Tutorials for Scientific Machine Learning (SciML) and Equation Solvers","text":"Static outputs in pdf, markdown, and html reside in SciMLTutorialsOutput.","category":"page"},{"location":"#Video-Tutorial","page":"SciMLTutorials.jl: Tutorials for Scientific Machine Learning (SciML) and Equation Solvers","title":"Video Tutorial","text":"","category":"section"},{"location":"","page":"SciMLTutorials.jl: Tutorials for Scientific Machine Learning (SciML) and Equation Solvers","title":"SciMLTutorials.jl: Tutorials for Scientific Machine Learning (SciML) and Equation Solvers","text":"(Image: Video Tutorial)","category":"page"},{"location":"#Interactive-Notebooks","page":"SciMLTutorials.jl: Tutorials for Scientific Machine Learning (SciML) and Equation Solvers","title":"Interactive Notebooks","text":"","category":"section"},{"location":"","page":"SciMLTutorials.jl: Tutorials for Scientific Machine Learning (SciML) and Equation Solvers","title":"SciMLTutorials.jl: Tutorials for Scientific Machine Learning (SciML) and Equation Solvers","text":"To generate the interactive notebooks, first install the SciMLTutorials, instantiate the environment, and then run SciMLTutorials.open_notebooks(). This looks as follows:","category":"page"},{"location":"","page":"SciMLTutorials.jl: Tutorials for Scientific Machine Learning (SciML) and Equation Solvers","title":"SciMLTutorials.jl: Tutorials for Scientific Machine Learning (SciML) and Equation Solvers","text":"]add SciMLTutorials#master\n]activate SciMLTutorials\n]instantiate\nusing SciMLTutorials\nSciMLTutorials.open_notebooks()","category":"page"},{"location":"","page":"SciMLTutorials.jl: Tutorials for Scientific Machine Learning (SciML) and Equation Solvers","title":"SciMLTutorials.jl: Tutorials for Scientific Machine Learning (SciML) and Equation Solvers","text":"The tutorials will be generated at your pwd() in a folder called generated_notebooks.","category":"page"},{"location":"","page":"SciMLTutorials.jl: Tutorials for Scientific Machine Learning (SciML) and Equation Solvers","title":"SciMLTutorials.jl: Tutorials for Scientific Machine Learning (SciML) and Equation Solvers","text":"Note that when running the tutorials, the packages are not automatically added. Thus you will need to add the packages manually or use the internal Project/Manifest tomls to instantiate the correct packages. This can be done by activating the folder of the tutorials. For example,","category":"page"},{"location":"","page":"SciMLTutorials.jl: Tutorials for Scientific Machine Learning (SciML) and Equation Solvers","title":"SciMLTutorials.jl: Tutorials for Scientific Machine Learning (SciML) and Equation Solvers","text":"using Pkg\nPkg.activate(joinpath(pkgdir(SciMLTutorials),\"tutorials\",\"models\"))\nPkg.instantiate()","category":"page"},{"location":"","page":"SciMLTutorials.jl: Tutorials for Scientific Machine Learning (SciML) and Equation Solvers","title":"SciMLTutorials.jl: Tutorials for Scientific Machine Learning (SciML) and Equation Solvers","text":"will add all of the packages required to run any tutorial in the models folder.","category":"page"},{"location":"#Contributing","page":"SciMLTutorials.jl: Tutorials for Scientific Machine Learning (SciML) and Equation Solvers","title":"Contributing","text":"","category":"section"},{"location":"","page":"SciMLTutorials.jl: Tutorials for Scientific Machine Learning (SciML) and Equation Solvers","title":"SciMLTutorials.jl: Tutorials for Scientific Machine Learning (SciML) and Equation Solvers","text":"All of the files are generated from the Weave.jl files in the tutorials folder. The generation process runs automatically, and thus one does not necessarily need to test the Weave process locally. Instead, simply open a PR that adds/updates a file in the \"tutorials\" folder and the PR will generate the tutorial on demand. Its artifacts can then be inspected in the Buildkite as described below before merging. Note that it will use the Project.toml and Manifest.toml of the subfolder, so any changes to dependencies requires that those are updated.","category":"page"},{"location":"#Reporting-Bugs-and-Issues","page":"SciMLTutorials.jl: Tutorials for Scientific Machine Learning (SciML) and Equation Solvers","title":"Reporting Bugs and Issues","text":"","category":"section"},{"location":"","page":"SciMLTutorials.jl: Tutorials for Scientific Machine Learning (SciML) and Equation Solvers","title":"SciMLTutorials.jl: Tutorials for Scientific Machine Learning (SciML) and Equation Solvers","text":"Report any bugs or issues at the SciMLTutorials repository.","category":"page"},{"location":"#Inspecting-Tutorial-Results","page":"SciMLTutorials.jl: Tutorials for Scientific Machine Learning (SciML) and Equation Solvers","title":"Inspecting Tutorial Results","text":"","category":"section"},{"location":"","page":"SciMLTutorials.jl: Tutorials for Scientific Machine Learning (SciML) and Equation Solvers","title":"SciMLTutorials.jl: Tutorials for Scientific Machine Learning (SciML) and Equation Solvers","text":"To see tutorial results before merging, click into the BuildKite, click onto Artifacts, and then investigate the trained results.","category":"page"},{"location":"","page":"SciMLTutorials.jl: Tutorials for Scientific Machine Learning (SciML) and Equation Solvers","title":"SciMLTutorials.jl: Tutorials for Scientific Machine Learning (SciML) and Equation Solvers","text":"(Image: )","category":"page"},{"location":"#Manually-Generating-Files","page":"SciMLTutorials.jl: Tutorials for Scientific Machine Learning (SciML) and Equation Solvers","title":"Manually Generating Files","text":"","category":"section"},{"location":"","page":"SciMLTutorials.jl: Tutorials for Scientific Machine Learning (SciML) and Equation Solvers","title":"SciMLTutorials.jl: Tutorials for Scientific Machine Learning (SciML) and Equation Solvers","text":"To run the generation process, do for example:","category":"page"},{"location":"","page":"SciMLTutorials.jl: Tutorials for Scientific Machine Learning (SciML) and Equation Solvers","title":"SciMLTutorials.jl: Tutorials for Scientific Machine Learning (SciML) and Equation Solvers","text":"]activate SciMLTutorials # Get all of the packages\nusing SciMLTutorials\nSciMLTutorials.weave_file(joinpath(pkgdir(SciMLTutorials),\"tutorials\",\"models\"),\"01-classical_physics.jmd\")","category":"page"},{"location":"","page":"SciMLTutorials.jl: Tutorials for Scientific Machine Learning (SciML) and Equation Solvers","title":"SciMLTutorials.jl: Tutorials for Scientific Machine Learning (SciML) and Equation Solvers","text":"To generate all of the files in a folder, for example, run:","category":"page"},{"location":"","page":"SciMLTutorials.jl: Tutorials for Scientific Machine Learning (SciML) and Equation Solvers","title":"SciMLTutorials.jl: Tutorials for Scientific Machine Learning (SciML) and Equation Solvers","text":"SciMLTutorials.weave_folder(joinpath(pkgdir(SciMLTutorials),\"tutorials\",\"models\"))","category":"page"},{"location":"","page":"SciMLTutorials.jl: Tutorials for Scientific Machine Learning (SciML) and Equation Solvers","title":"SciMLTutorials.jl: Tutorials for Scientific Machine Learning (SciML) and Equation Solvers","text":"To generate all of the notebooks, do:","category":"page"},{"location":"","page":"SciMLTutorials.jl: Tutorials for Scientific Machine Learning (SciML) and Equation Solvers","title":"SciMLTutorials.jl: Tutorials for Scientific Machine Learning (SciML) and Equation Solvers","text":"SciMLTutorials.weave_all()","category":"page"},{"location":"","page":"SciMLTutorials.jl: Tutorials for Scientific Machine Learning (SciML) and Equation Solvers","title":"SciMLTutorials.jl: Tutorials for Scientific Machine Learning (SciML) and Equation Solvers","text":"Each of the tuturials displays the computer characteristics at the bottom of the benchmark.","category":"page"},{"location":"odes/01-ode_minmax/#Finding-Maxima-and-Minima-of-Ordinary-Differential-Equation-Solutions","page":"Finding Maxima and Minima of Ordinary Differential Equation Solutions","title":"Finding Maxima and Minima of Ordinary Differential Equation Solutions","text":"","category":"section"},{"location":"odes/01-ode_minmax/#Setup","page":"Finding Maxima and Minima of Ordinary Differential Equation Solutions","title":"Setup","text":"","category":"section"},{"location":"odes/01-ode_minmax/","page":"Finding Maxima and Minima of Ordinary Differential Equation Solutions","title":"Finding Maxima and Minima of Ordinary Differential Equation Solutions","text":"In this tutorial we will show how to use Optim.jl to find the maxima and minima of solutions. Let's take a look at the double pendulum:","category":"page"},{"location":"odes/01-ode_minmax/","page":"Finding Maxima and Minima of Ordinary Differential Equation Solutions","title":"Finding Maxima and Minima of Ordinary Differential Equation Solutions","text":"#Constants and setup\nusing OrdinaryDiffEq\ninitial = [0.01, 0.01, 0.01, 0.01]\ntspan = (0.,100.)\n\n#Define the problem\nfunction double_pendulum_hamiltonian(udot,u,p,t)\n    α  = u[1]\n    lα = u[2]\n    β  = u[3]\n    lβ = u[4]\n    udot .=\n    [2(lα-(1+cos(β))lβ)/(3-cos(2β)),\n    -2sin(α) - sin(α+β),\n    2(-(1+cos(β))lα + (3+2cos(β))lβ)/(3-cos(2β)),\n    -sin(α+β) - 2sin(β)*(((lα-lβ)lβ)/(3-cos(2β))) + 2sin(2β)*((lα^2 - 2(1+cos(β))lα*lβ + (3+2cos(β))lβ^2)/(3-cos(2β))^2)]\nend\n\n#Pass to solvers\npoincare = ODEProblem(double_pendulum_hamiltonian, initial, tspan)","category":"page"},{"location":"odes/01-ode_minmax/","page":"Finding Maxima and Minima of Ordinary Differential Equation Solutions","title":"Finding Maxima and Minima of Ordinary Differential Equation Solutions","text":"ODEProblem with uType Vector{Float64} and tType Float64. In-place: true\ntimespan: (0.0, 100.0)\nu0: 4-element Vector{Float64}:\n 0.01\n 0.01\n 0.01\n 0.01","category":"page"},{"location":"odes/01-ode_minmax/","page":"Finding Maxima and Minima of Ordinary Differential Equation Solutions","title":"Finding Maxima and Minima of Ordinary Differential Equation Solutions","text":"sol = solve(poincare, Tsit5())","category":"page"},{"location":"odes/01-ode_minmax/","page":"Finding Maxima and Minima of Ordinary Differential Equation Solutions","title":"Finding Maxima and Minima of Ordinary Differential Equation Solutions","text":"retcode: Success\nInterpolation: specialized 4th order \"free\" interpolation\nt: 193-element Vector{Float64}:\n   0.0\n   0.08332584852065579\n   0.24175300587841853\n   0.4389533535703127\n   0.6797301355043014\n   0.9647629621490508\n   1.3179425637594349\n   1.7031226016307728\n   2.0678503967116617\n   2.4717899847517866\n   ⋮\n  95.8457309586563\n  96.3577910122243\n  96.92913461915474\n  97.44679415429573\n  97.96248479179103\n  98.51183391850897\n  99.0608253308051\n  99.58284388126884\n 100.0\nu: 193-element Vector{Vector{Float64}}:\n [0.01, 0.01, 0.01, 0.01]\n [0.009170687380405334, 0.006669000455384281, 0.012420525490765841, 0.00826\n6408515192909]\n [0.007673275265972504, 0.00037461737897660443, 0.016442590227730397, 0.004\n636827483318277]\n [0.006125974419239289, -0.007305450189721187, 0.019967371084231897, -0.000\n3364979830896869]\n [0.004966110662711131, -0.01630851653373806, 0.021440659476204722, -0.0067\n05037098400474]\n [0.0047955683310194714, -0.026238103489235838, 0.01882432520883759, -0.013\n913364556753736]\n [0.0060546798253553686, -0.03712455187908053, 0.010055702788069564, -0.021\n038127478647375]\n [0.007900784412908646, -0.04667606960847394, -0.002673581831574513, -0.025\n18303627203377]\n [0.008276510489473166, -0.05278433365633976, -0.012731546444725367, -0.025\n25804037623962]\n [0.00552349681674124, -0.05525250414492613, -0.016843881882621835, -0.0218\n98963191274153]\n ⋮\n [-0.014886751154788403, 0.04233275827248491, 0.0136282832580092, 0.0180290\n82291419467]\n [-0.008190258536393156, 0.054422679804409874, 0.009448013826704854, 0.0177\n4006800908217]\n [0.004124711787695587, 0.05674878820505975, -0.00515418739191979, 0.017596\n983103942972]\n [0.013079718118471138, 0.048077043077395416, -0.01377066122508919, 0.01828\n6648610391296]\n [0.015316040241448815, 0.03163095955755212, -0.008956991644884404, 0.01711\n8404049844594]\n [0.011115490017375213, 0.00992901822063005, 0.007297481421219374, 0.010353\n371812537674]\n [0.005713878919291721, -0.011787427051187821, 0.02050806401368854, -0.0023\n10458905852316]\n [0.004211439726126673, -0.029911199361470703, 0.018750446422905413, -0.015\n650712294907165]\n [0.005741239607321043, -0.04165385985159563, 0.007413270184094278, -0.0233\n4897852528026]","category":"page"},{"location":"odes/01-ode_minmax/","page":"Finding Maxima and Minima of Ordinary Differential Equation Solutions","title":"Finding Maxima and Minima of Ordinary Differential Equation Solutions","text":"In time, the solution looks like:","category":"page"},{"location":"odes/01-ode_minmax/","page":"Finding Maxima and Minima of Ordinary Differential Equation Solutions","title":"Finding Maxima and Minima of Ordinary Differential Equation Solutions","text":"using Plots; gr()\nplot(sol, vars=[(0,3),(0,4)], leg=false, plotdensity=10000)","category":"page"},{"location":"odes/01-ode_minmax/","page":"Finding Maxima and Minima of Ordinary Differential Equation Solutions","title":"Finding Maxima and Minima of Ordinary Differential Equation Solutions","text":"(Image: )","category":"page"},{"location":"odes/01-ode_minmax/","page":"Finding Maxima and Minima of Ordinary Differential Equation Solutions","title":"Finding Maxima and Minima of Ordinary Differential Equation Solutions","text":"while it has the well-known phase-space plot:","category":"page"},{"location":"odes/01-ode_minmax/","page":"Finding Maxima and Minima of Ordinary Differential Equation Solutions","title":"Finding Maxima and Minima of Ordinary Differential Equation Solutions","text":"plot(sol, vars=(3,4), leg=false)","category":"page"},{"location":"odes/01-ode_minmax/","page":"Finding Maxima and Minima of Ordinary Differential Equation Solutions","title":"Finding Maxima and Minima of Ordinary Differential Equation Solutions","text":"(Image: )","category":"page"},{"location":"odes/01-ode_minmax/#Local-Optimization","page":"Finding Maxima and Minima of Ordinary Differential Equation Solutions","title":"Local Optimization","text":"","category":"section"},{"location":"odes/01-ode_minmax/","page":"Finding Maxima and Minima of Ordinary Differential Equation Solutions","title":"Finding Maxima and Minima of Ordinary Differential Equation Solutions","text":"Let's fine out what some of the local maxima and minima are. Optim.jl can be used to minimize functions, and the solution type has a continuous interpolation which can be used. Let's look for the local optima for the 4th variable around t=20. Thus our optimization function is:","category":"page"},{"location":"odes/01-ode_minmax/","page":"Finding Maxima and Minima of Ordinary Differential Equation Solutions","title":"Finding Maxima and Minima of Ordinary Differential Equation Solutions","text":"f = (t) -> sol(t,idxs=4)","category":"page"},{"location":"odes/01-ode_minmax/","page":"Finding Maxima and Minima of Ordinary Differential Equation Solutions","title":"Finding Maxima and Minima of Ordinary Differential Equation Solutions","text":"#1 (generic function with 1 method)","category":"page"},{"location":"odes/01-ode_minmax/","page":"Finding Maxima and Minima of Ordinary Differential Equation Solutions","title":"Finding Maxima and Minima of Ordinary Differential Equation Solutions","text":"first(t) is the same as t[1] which transforms the array of size 1 into a number. idxs=4 is the same as sol(first(t))[4] but does the calculation without a temporary array and thus is faster. To find a local minima, we can simply call Optim on this function. Let's find a local minimum:","category":"page"},{"location":"odes/01-ode_minmax/","page":"Finding Maxima and Minima of Ordinary Differential Equation Solutions","title":"Finding Maxima and Minima of Ordinary Differential Equation Solutions","text":"using Optim\nopt = optimize(f,18.0,22.0)","category":"page"},{"location":"odes/01-ode_minmax/","page":"Finding Maxima and Minima of Ordinary Differential Equation Solutions","title":"Finding Maxima and Minima of Ordinary Differential Equation Solutions","text":"Results of Optimization Algorithm\n * Algorithm: Brent's Method\n * Search Interval: [18.000000, 22.000000]\n * Minimizer: 1.863213e+01\n * Minimum: -2.793164e-02\n * Iterations: 11\n * Convergence: max(|x - x_upper|, |x - x_lower|) <= 2*(1.5e-08*|x|+2.2e-16\n): true\n * Objective Function Calls: 12","category":"page"},{"location":"odes/01-ode_minmax/","page":"Finding Maxima and Minima of Ordinary Differential Equation Solutions","title":"Finding Maxima and Minima of Ordinary Differential Equation Solutions","text":"From this printout we see that the minimum is at t=18.63 and the value is -2.79e-2. We can get these in code-form via:","category":"page"},{"location":"odes/01-ode_minmax/","page":"Finding Maxima and Minima of Ordinary Differential Equation Solutions","title":"Finding Maxima and Minima of Ordinary Differential Equation Solutions","text":"println(opt.minimizer)\nprintln(opt.minimum)","category":"page"},{"location":"odes/01-ode_minmax/","page":"Finding Maxima and Minima of Ordinary Differential Equation Solutions","title":"Finding Maxima and Minima of Ordinary Differential Equation Solutions","text":"18.632127451866573\n-0.02793163565154488","category":"page"},{"location":"odes/01-ode_minmax/","page":"Finding Maxima and Minima of Ordinary Differential Equation Solutions","title":"Finding Maxima and Minima of Ordinary Differential Equation Solutions","text":"To get the maximum, we just minimize the negative of the function:","category":"page"},{"location":"odes/01-ode_minmax/","page":"Finding Maxima and Minima of Ordinary Differential Equation Solutions","title":"Finding Maxima and Minima of Ordinary Differential Equation Solutions","text":"f = (t) -> -sol(first(t),idxs=4)\nopt2 = optimize(f,0.0,22.0)","category":"page"},{"location":"odes/01-ode_minmax/","page":"Finding Maxima and Minima of Ordinary Differential Equation Solutions","title":"Finding Maxima and Minima of Ordinary Differential Equation Solutions","text":"Results of Optimization Algorithm\n * Algorithm: Brent's Method\n * Search Interval: [0.000000, 22.000000]\n * Minimizer: 1.399975e+01\n * Minimum: -2.269411e-02\n * Iterations: 13\n * Convergence: max(|x - x_upper|, |x - x_lower|) <= 2*(1.5e-08*|x|+2.2e-16\n): true\n * Objective Function Calls: 14","category":"page"},{"location":"odes/01-ode_minmax/","page":"Finding Maxima and Minima of Ordinary Differential Equation Solutions","title":"Finding Maxima and Minima of Ordinary Differential Equation Solutions","text":"Let's add the maxima and minima to the plots:","category":"page"},{"location":"odes/01-ode_minmax/","page":"Finding Maxima and Minima of Ordinary Differential Equation Solutions","title":"Finding Maxima and Minima of Ordinary Differential Equation Solutions","text":"plot(sol, vars=(0,4), plotdensity=10000)\nscatter!([opt.minimizer],[opt.minimum],label=\"Local Min\")\nscatter!([opt2.minimizer],[-opt2.minimum],label=\"Local Max\")","category":"page"},{"location":"odes/01-ode_minmax/","page":"Finding Maxima and Minima of Ordinary Differential Equation Solutions","title":"Finding Maxima and Minima of Ordinary Differential Equation Solutions","text":"(Image: )","category":"page"},{"location":"odes/01-ode_minmax/","page":"Finding Maxima and Minima of Ordinary Differential Equation Solutions","title":"Finding Maxima and Minima of Ordinary Differential Equation Solutions","text":"Brent's method will locally minimize over the full interval. If we instead want a local maxima nearest to a point, we can use BFGS(). In this case, we need to optimize a vector [t], and thus dereference it to a number using first(t).","category":"page"},{"location":"odes/01-ode_minmax/","page":"Finding Maxima and Minima of Ordinary Differential Equation Solutions","title":"Finding Maxima and Minima of Ordinary Differential Equation Solutions","text":"f = (t) -> -sol(first(t),idxs=4)\nopt = optimize(f,[20.0],BFGS())","category":"page"},{"location":"odes/01-ode_minmax/","page":"Finding Maxima and Minima of Ordinary Differential Equation Solutions","title":"Finding Maxima and Minima of Ordinary Differential Equation Solutions","text":"* Status: success\n\n * Candidate solution\n    Final objective value:     -2.588588e-02\n\n * Found with\n    Algorithm:     BFGS\n\n * Convergence measures\n    |x - x'|               = 1.11e-04 ≰ 0.0e+00\n    |x - x'|/|x'|          = 4.78e-06 ≰ 0.0e+00\n    |f(x) - f(x')|         = 1.68e-10 ≰ 0.0e+00\n    |f(x) - f(x')|/|f(x')| = 6.49e-09 ≰ 0.0e+00\n    |g(x)|                 = 8.44e-12 ≤ 1.0e-08\n\n * Work counters\n    Seconds run:   0  (vs limit Inf)\n    Iterations:    4\n    f(x) calls:    16\n    ∇f(x) calls:   16","category":"page"},{"location":"odes/01-ode_minmax/#Global-Optimization","page":"Finding Maxima and Minima of Ordinary Differential Equation Solutions","title":"Global Optimization","text":"","category":"section"},{"location":"odes/01-ode_minmax/","page":"Finding Maxima and Minima of Ordinary Differential Equation Solutions","title":"Finding Maxima and Minima of Ordinary Differential Equation Solutions","text":"If we instead want to find global maxima and minima, we need to look somewhere else. For this there are many choices. A pure Julia option is BlackBoxOptim.jl, but I will use NLopt.jl. Following the NLopt.jl tutorial but replacing their function with out own:","category":"page"},{"location":"odes/01-ode_minmax/","page":"Finding Maxima and Minima of Ordinary Differential Equation Solutions","title":"Finding Maxima and Minima of Ordinary Differential Equation Solutions","text":"import NLopt, ForwardDiff\n\ncount = 0 # keep track of # function evaluations\n\nfunction g(t::Vector, grad::Vector)\n  if length(grad) > 0\n    #use ForwardDiff for the gradients\n    grad[1] = ForwardDiff.derivative((t)->sol(first(t),idxs=4),t)\n  end\n  sol(first(t),idxs=4)\nend\nopt = NLopt.Opt(:GN_ORIG_DIRECT_L, 1)\nNLopt.lower_bounds!(opt, [0.0])\nNLopt.upper_bounds!(opt, [40.0])\nNLopt.xtol_rel!(opt,1e-8)\nNLopt.min_objective!(opt, g)\n(minf,minx,ret) = NLopt.optimize(opt,[20.0])\nprintln(minf,\" \",minx,\" \",ret)\nNLopt.max_objective!(opt, g)\n(maxf,maxx,ret) = NLopt.optimize(opt,[20.0])\nprintln(maxf,\" \",maxx,\" \",ret)","category":"page"},{"location":"odes/01-ode_minmax/","page":"Finding Maxima and Minima of Ordinary Differential Equation Solutions","title":"Finding Maxima and Minima of Ordinary Differential Equation Solutions","text":"Error: ArgumentError: Package ForwardDiff not found in current path:\n- Run `import Pkg; Pkg.add(\"ForwardDiff\")` to install the ForwardDiff packa\nge.","category":"page"},{"location":"odes/01-ode_minmax/","page":"Finding Maxima and Minima of Ordinary Differential Equation Solutions","title":"Finding Maxima and Minima of Ordinary Differential Equation Solutions","text":"plot(sol, vars=(0,4), plotdensity=10000)\nscatter!([minx],[minf],label=\"Global Min\")\nscatter!([maxx],[maxf],label=\"Global Max\")","category":"page"},{"location":"odes/01-ode_minmax/","page":"Finding Maxima and Minima of Ordinary Differential Equation Solutions","title":"Finding Maxima and Minima of Ordinary Differential Equation Solutions","text":"Error: UndefVarError: minx not defined","category":"page"},{"location":"odes/01-ode_minmax/#Appendix","page":"Finding Maxima and Minima of Ordinary Differential Equation Solutions","title":"Appendix","text":"","category":"section"},{"location":"odes/01-ode_minmax/","page":"Finding Maxima and Minima of Ordinary Differential Equation Solutions","title":"Finding Maxima and Minima of Ordinary Differential Equation Solutions","text":"These tutorials are a part of the SciMLTutorials.jl repository, found at: https://github.com/SciML/SciMLTutorials.jl. For more information on high-performance scientific machine learning, check out the SciML Open Source Software Organization https://sciml.ai.","category":"page"},{"location":"odes/01-ode_minmax/","page":"Finding Maxima and Minima of Ordinary Differential Equation Solutions","title":"Finding Maxima and Minima of Ordinary Differential Equation Solutions","text":"To locally run this tutorial, do the following commands:","category":"page"},{"location":"odes/01-ode_minmax/","page":"Finding Maxima and Minima of Ordinary Differential Equation Solutions","title":"Finding Maxima and Minima of Ordinary Differential Equation Solutions","text":"using SciMLTutorials\nSciMLTutorials.weave_file(\"tutorials/ode_extras\",\"03-ode_minmax.jmd\")","category":"page"},{"location":"odes/01-ode_minmax/","page":"Finding Maxima and Minima of Ordinary Differential Equation Solutions","title":"Finding Maxima and Minima of Ordinary Differential Equation Solutions","text":"Computer Information:","category":"page"},{"location":"odes/01-ode_minmax/","page":"Finding Maxima and Minima of Ordinary Differential Equation Solutions","title":"Finding Maxima and Minima of Ordinary Differential Equation Solutions","text":"Julia Version 1.6.2\nCommit 1b93d53fc4 (2021-07-14 15:36 UTC)\nPlatform Info:\n  OS: Linux (x86_64-pc-linux-gnu)\n  CPU: AMD EPYC 7502 32-Core Processor\n  WORD_SIZE: 64\n  LIBM: libopenlibm\n  LLVM: libLLVM-11.0.1 (ORCJIT, znver2)\nEnvironment:\n  JULIA_DEPOT_PATH = /root/.cache/julia-buildkite-plugin/depots/a6029d3a-f78b-41ea-bc97-28aa57c6c6ea\n  JULIA_NUM_THREADS = 16\n","category":"page"},{"location":"odes/01-ode_minmax/","page":"Finding Maxima and Minima of Ordinary Differential Equation Solutions","title":"Finding Maxima and Minima of Ordinary Differential Equation Solutions","text":"Package Information:","category":"page"},{"location":"odes/01-ode_minmax/","page":"Finding Maxima and Minima of Ordinary Differential Equation Solutions","title":"Finding Maxima and Minima of Ordinary Differential Equation Solutions","text":"      Status `/var/lib/buildkite-agent/builds/5-amdci4-julia-csail-mit-edu/julialang/scimltutorials-dot-jl/tutorials/ode_extras/Project.toml`\n  [f3b72e0c] DiffEqDevTools v2.27.2\n  [0c46a032] DifferentialEquations v6.17.1\n  [961ee093] ModelingToolkit v5.17.3\n  [76087f3c] NLopt v0.6.2\n  [2774e3e8] NLsolve v4.5.1\n  [429524aa] Optim v1.3.0\n  [1dea7af3] OrdinaryDiffEq v5.56.0\n  [91a5bcdd] Plots v1.15.2\n  [30cb0354] SciMLTutorials v0.9.0\n  [37e2e46d] LinearAlgebra\n  [2f01184e] SparseArrays","category":"page"},{"location":"odes/01-ode_minmax/","page":"Finding Maxima and Minima of Ordinary Differential Equation Solutions","title":"Finding Maxima and Minima of Ordinary Differential Equation Solutions","text":"And the full manifest:","category":"page"},{"location":"odes/01-ode_minmax/","page":"Finding Maxima and Minima of Ordinary Differential Equation Solutions","title":"Finding Maxima and Minima of Ordinary Differential Equation Solutions","text":"      Status `/var/lib/buildkite-agent/builds/5-amdci4-julia-csail-mit-edu/julialang/scimltutorials-dot-jl/tutorials/ode_extras/Manifest.toml`\n  [c3fe647b] AbstractAlgebra v0.16.0\n  [1520ce14] AbstractTrees v0.3.4\n  [79e6a3ab] Adapt v3.3.0\n  [ec485272] ArnoldiMethod v0.1.0\n  [4fba245c] ArrayInterface v3.1.15\n  [4c555306] ArrayLayouts v0.7.0\n  [aae01518] BandedMatrices v0.16.9\n  [6e4b80f9] BenchmarkTools v1.0.0\n  [764a87c0] BoundaryValueDiffEq v2.7.1\n  [fa961155] CEnum v0.4.1\n  [00ebfdb7] CSTParser v2.5.0\n  [d360d2e6] ChainRulesCore v0.9.44\n  [b630d9fa] CheapThreads v0.2.5\n  [523fee87] CodecBzip2 v0.7.2\n  [944b1d66] CodecZlib v0.7.0\n  [35d6a980] ColorSchemes v3.12.1\n  [3da002f7] ColorTypes v0.11.0\n  [5ae59095] Colors v0.12.8\n  [861a8166] Combinatorics v1.0.2\n  [a80b9123] CommonMark v0.8.1\n  [38540f10] CommonSolve v0.2.0\n  [bbf7d656] CommonSubexpressions v0.3.0\n  [34da2185] Compat v3.30.0\n  [8f4d0f93] Conda v1.5.2\n  [187b0558] ConstructionBase v1.2.1\n  [d38c429a] Contour v0.5.7\n  [a8cc5b0e] Crayons v4.0.4\n  [9a962f9c] DataAPI v1.6.0\n  [864edb3b] DataStructures v0.18.9\n  [e2d170a0] DataValueInterfaces v1.0.0\n  [bcd4f6db] DelayDiffEq v5.31.0\n  [2b5f629d] DiffEqBase v6.62.2\n  [459566f4] DiffEqCallbacks v2.16.1\n  [f3b72e0c] DiffEqDevTools v2.27.2\n  [5a0ffddc] DiffEqFinancial v2.4.0\n  [c894b116] DiffEqJump v6.14.2\n  [77a26b50] DiffEqNoiseProcess v5.7.3\n  [055956cb] DiffEqPhysics v3.9.0\n  [163ba53b] DiffResults v1.0.3\n  [b552c78f] DiffRules v1.0.2\n  [0c46a032] DifferentialEquations v6.17.1\n  [c619ae07] DimensionalPlotRecipes v1.2.0\n  [b4f34e82] Distances v0.10.3\n  [31c24e10] Distributions v0.24.18\n  [ffbed154] DocStringExtensions v0.8.4\n  [e30172f5] Documenter v0.26.3\n  [d4d017d3] ExponentialUtilities v1.8.4\n  [e2ba6199] ExprTools v0.1.3\n  [c87230d0] FFMPEG v0.4.0\n  [7034ab61] FastBroadcast v0.1.8\n  [9aa1b823] FastClosures v0.3.2\n  [1a297f60] FillArrays v0.11.7\n  [6a86dc24] FiniteDiff v2.8.0\n  [53c48c17] FixedPointNumbers v0.8.4\n  [59287772] Formatting v0.4.2\n  [f6369f11] ForwardDiff v0.10.18\n  [069b7b12] FunctionWrappers v1.1.2\n  [28b8d3ca] GR v0.57.4\n  [5c1252a2] GeometryBasics v0.3.12\n  [42e2da0e] Grisu v1.0.2\n  [cd3eb016] HTTP v0.9.9\n  [eafb193a] Highlights v0.4.5\n  [0e44f5e4] Hwloc v2.0.0\n  [7073ff75] IJulia v1.23.2\n  [b5f81e59] IOCapture v0.1.1\n  [615f187c] IfElse v0.1.0\n  [d25df0c9] Inflate v0.1.2\n  [83e8ac13] IniFile v0.5.0\n  [c8e1da08] IterTools v1.3.0\n  [42fd0dbc] IterativeSolvers v0.9.1\n  [82899510] IteratorInterfaceExtensions v1.0.0\n  [692b3bcd] JLLWrappers v1.3.0\n  [682c06a0] JSON v0.21.1\n  [7d188eb4] JSONSchema v0.3.3\n  [98e50ef6] JuliaFormatter v0.13.7\n  [b964fa9f] LaTeXStrings v1.2.1\n  [2ee39098] LabelledArrays v1.6.1\n  [23fbe1c1] Latexify v0.15.5\n  [093fc24a] LightGraphs v1.3.5\n  [d3d80556] LineSearches v7.1.1\n  [2ab3a3ac] LogExpFunctions v0.2.4\n  [bdcacae8] LoopVectorization v0.12.23\n  [1914dd2f] MacroTools v0.5.6\n  [b8f27783] MathOptInterface v0.9.22\n  [fdba3010] MathProgBase v0.7.8\n  [739be429] MbedTLS v1.0.3\n  [442fdcdd] Measures v0.3.1\n  [e1d29d7a] Missings v1.0.0\n  [961ee093] ModelingToolkit v5.17.3\n  [46d2c3a1] MuladdMacro v0.2.2\n  [f9640e96] MultiScaleArrays v1.8.1\n  [ffc61752] Mustache v1.0.10\n  [d8a4904e] MutableArithmetics v0.2.19\n  [d41bc354] NLSolversBase v7.8.0\n  [76087f3c] NLopt v0.6.2\n  [2774e3e8] NLsolve v4.5.1\n  [77ba4419] NaNMath v0.3.5\n  [8913a72c] NonlinearSolve v0.3.8\n  [6fe1bfb0] OffsetArrays v1.9.0\n  [429524aa] Optim v1.3.0\n  [bac558e1] OrderedCollections v1.4.1\n  [1dea7af3] OrdinaryDiffEq v5.56.0\n  [90014a1f] PDMats v0.11.0\n  [65888b18] ParameterizedFunctions v5.10.0\n  [d96e819e] Parameters v0.12.2\n  [69de0a69] Parsers v1.1.0\n  [ccf2f8ad] PlotThemes v2.0.1\n  [995b91a9] PlotUtils v1.0.10\n  [91a5bcdd] Plots v1.15.2\n  [e409e4f3] PoissonRandom v0.4.0\n  [f517fe37] Polyester v0.3.1\n  [85a6dd25] PositiveFactorizations v0.2.4\n  [21216c6a] Preferences v1.2.2\n  [1fd47b50] QuadGK v2.4.1\n  [74087812] Random123 v1.3.1\n  [fb686558] RandomExtensions v0.4.3\n  [e6cf234a] RandomNumbers v1.4.0\n  [3cdcf5f2] RecipesBase v1.1.1\n  [01d81517] RecipesPipeline v0.3.2\n  [731186ca] RecursiveArrayTools v2.11.4\n  [f2c3362d] RecursiveFactorization v0.1.12\n  [189a3867] Reexport v1.0.0\n  [ae029012] Requires v1.1.3\n  [ae5879a3] ResettableStacks v1.1.0\n  [79098fc4] Rmath v0.7.0\n  [47965b36] RootedTrees v1.0.0\n  [7e49a35a] RuntimeGeneratedFunctions v0.5.2\n  [476501e8] SLEEFPirates v0.6.20\n  [1bc83da4] SafeTestsets v0.0.1\n  [0bca4576] SciMLBase v1.13.4\n  [30cb0354] SciMLTutorials v0.9.0\n  [6c6a2e73] Scratch v1.0.3\n  [efcf1570] Setfield v0.7.0\n  [992d4aef] Showoff v1.0.3\n  [699a6c99] SimpleTraits v0.9.3\n  [b85f4697] SoftGlobalScope v1.1.0\n  [a2af1166] SortingAlgorithms v1.0.0\n  [47a9eef4] SparseDiffTools v1.13.2\n  [276daf66] SpecialFunctions v1.4.1\n  [aedffcd0] Static v0.2.4\n  [90137ffa] StaticArrays v1.2.0\n  [82ae8749] StatsAPI v1.0.0\n  [2913bbd2] StatsBase v0.33.8\n  [4c63d2b9] StatsFuns v0.9.8\n  [9672c7b4] SteadyStateDiffEq v1.6.2\n  [789caeaf] StochasticDiffEq v6.34.1\n  [7792a7ef] StrideArraysCore v0.1.11\n  [09ab397b] StructArrays v0.5.1\n  [c3572dad] Sundials v4.4.3\n  [d1185830] SymbolicUtils v0.11.2\n  [0c5d862f] Symbolics v0.1.25\n  [3783bdb8] TableTraits v1.0.1\n  [bd369af6] Tables v1.4.2\n  [8290d209] ThreadingUtilities v0.4.4\n  [a759f4b9] TimerOutputs v0.5.9\n  [0796e94c] Tokenize v0.5.16\n  [3bb67fe8] TranscodingStreams v0.9.5\n  [a2a6695c] TreeViews v0.3.0\n  [5c2747f8] URIs v1.3.0\n  [3a884ed6] UnPack v1.0.2\n  [1986cc42] Unitful v1.7.0\n  [3d5dd08c] VectorizationBase v0.20.11\n  [81def892] VersionParsing v1.2.0\n  [19fa3120] VertexSafeGraphs v0.1.2\n  [44d3d7a6] Weave v0.10.8\n  [ddb6d928] YAML v0.4.6\n  [c2297ded] ZMQ v1.2.1\n  [a5390f91] ZipFile v0.9.3\n  [700de1a5] ZygoteRules v0.2.1\n  [6e34b625] Bzip2_jll v1.0.6+5\n  [83423d85] Cairo_jll v1.16.0+6\n  [5ae413db] EarCut_jll v2.1.5+1\n  [2e619515] Expat_jll v2.2.10+0\n  [b22a6f82] FFMPEG_jll v4.3.1+4\n  [a3f928ae] Fontconfig_jll v2.13.1+14\n  [d7e528f0] FreeType2_jll v2.10.1+5\n  [559328eb] FriBidi_jll v1.0.5+6\n  [0656b61e] GLFW_jll v3.3.4+0\n  [d2c73de3] GR_jll v0.57.2+0\n  [78b55507] Gettext_jll v0.21.0+0\n  [7746bdde] Glib_jll v2.68.1+0\n  [e33a78d0] Hwloc_jll v2.4.1+0\n  [aacddb02] JpegTurbo_jll v2.0.1+3\n  [c1c5ebd0] LAME_jll v3.100.0+3\n  [dd4b983a] LZO_jll v2.10.1+0\n  [dd192d2f] LibVPX_jll v1.9.0+1\n  [e9f186c6] Libffi_jll v3.2.2+0\n  [d4300ac3] Libgcrypt_jll v1.8.7+0\n  [7e76a0d4] Libglvnd_jll v1.3.0+3\n  [7add5ba3] Libgpg_error_jll v1.42.0+0\n  [94ce4f54] Libiconv_jll v1.16.1+0\n  [4b2f31a3] Libmount_jll v2.35.0+0\n  [89763e89] Libtiff_jll v4.1.0+2\n  [38a345b3] Libuuid_jll v2.36.0+0\n  [079eb43e] NLopt_jll v2.7.0+0\n  [e7412a2a] Ogg_jll v1.3.4+2\n  [458c3c95] OpenSSL_jll v1.1.1+6\n  [efe28fd5] OpenSpecFun_jll v0.5.4+0\n  [91d4177d] Opus_jll v1.3.1+3\n  [2f80f16e] PCRE_jll v8.44.0+0\n  [30392449] Pixman_jll v0.40.1+0\n  [ea2cea3b] Qt5Base_jll v5.15.2+0\n  [f50d1b31] Rmath_jll v0.3.0+0\n  [fb77eaff] Sundials_jll v5.2.0+1\n  [a2964d1f] Wayland_jll v1.17.0+4\n  [2381bf8a] Wayland_protocols_jll v1.18.0+4\n  [02c8fc9c] XML2_jll v2.9.12+0\n  [aed1982a] XSLT_jll v1.1.34+0\n  [4f6342f7] Xorg_libX11_jll v1.6.9+4\n  [0c0b7dd1] Xorg_libXau_jll v1.0.9+4\n  [935fb764] Xorg_libXcursor_jll v1.2.0+4\n  [a3789734] Xorg_libXdmcp_jll v1.1.3+4\n  [1082639a] Xorg_libXext_jll v1.3.4+4\n  [d091e8ba] Xorg_libXfixes_jll v5.0.3+4\n  [a51aa0fd] Xorg_libXi_jll v1.7.10+4\n  [d1454406] Xorg_libXinerama_jll v1.1.4+4\n  [ec84b674] Xorg_libXrandr_jll v1.5.2+4\n  [ea2f1a96] Xorg_libXrender_jll v0.9.10+4\n  [14d82f49] Xorg_libpthread_stubs_jll v0.1.0+3\n  [c7cfdc94] Xorg_libxcb_jll v1.13.0+3\n  [cc61e674] Xorg_libxkbfile_jll v1.1.0+4\n  [12413925] Xorg_xcb_util_image_jll v0.4.0+1\n  [2def613f] Xorg_xcb_util_jll v0.4.0+1\n  [975044d2] Xorg_xcb_util_keysyms_jll v0.4.0+1\n  [0d47668e] Xorg_xcb_util_renderutil_jll v0.3.9+1\n  [c22f9ab0] Xorg_xcb_util_wm_jll v0.4.1+1\n  [35661453] Xorg_xkbcomp_jll v1.4.2+4\n  [33bec58e] Xorg_xkeyboard_config_jll v2.27.0+4\n  [c5fb5394] Xorg_xtrans_jll v1.4.0+3\n  [8f1865be] ZeroMQ_jll v4.3.2+6\n  [3161d3a3] Zstd_jll v1.5.0+0\n  [0ac62f75] libass_jll v0.14.0+4\n  [f638f0a6] libfdk_aac_jll v0.1.6+4\n  [b53b4c65] libpng_jll v1.6.38+0\n  [a9144af2] libsodium_jll v1.0.20+0\n  [f27f6e37] libvorbis_jll v1.3.6+6\n  [1270edf5] x264_jll v2020.7.14+2\n  [dfaa095f] x265_jll v3.0.0+3\n  [d8fb68d0] xkbcommon_jll v0.9.1+5\n  [0dad84c5] ArgTools\n  [56f22d72] Artifacts\n  [2a0f44e3] Base64\n  [ade2ca70] Dates\n  [8bb1440f] DelimitedFiles\n  [8ba89e20] Distributed\n  [f43a241f] Downloads\n  [7b1f6079] FileWatching\n  [9fa8497b] Future\n  [b77e0a4c] InteractiveUtils\n  [b27032c2] LibCURL\n  [76f85450] LibGit2\n  [8f399da3] Libdl\n  [37e2e46d] LinearAlgebra\n  [56ddb016] Logging\n  [d6f4376e] Markdown\n  [a63ad114] Mmap\n  [ca575930] NetworkOptions\n  [44cfe95a] Pkg\n  [de0858da] Printf\n  [3fa0cd96] REPL\n  [9a3f8284] Random\n  [ea8e919c] SHA\n  [9e88b42a] Serialization\n  [1a1011a3] SharedArrays\n  [6462fe0b] Sockets\n  [2f01184e] SparseArrays\n  [10745b16] Statistics\n  [4607b0f0] SuiteSparse\n  [fa267f1f] TOML\n  [a4e569a6] Tar\n  [8dfed614] Test\n  [cf7118a7] UUIDs\n  [4ec0a83e] Unicode\n  [e66e0078] CompilerSupportLibraries_jll\n  [deac9b47] LibCURL_jll\n  [29816b5a] LibSSH2_jll\n  [c8ffd9c3] MbedTLS_jll\n  [14a3606d] MozillaCACerts_jll\n  [4536629a] OpenBLAS_jll\n  [bea87d4a] SuiteSparse_jll\n  [83775a58] Zlib_jll\n  [8e850ede] nghttp2_jll\n  [3f19e933] p7zip_jll","category":"page"}]
}
